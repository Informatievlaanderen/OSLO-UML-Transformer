{"version":3,"file":"Resolve.js","sourceRoot":"","sources":["Resolve.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nexport function resolve(relativeIRI: string, baseIRI?: string): string {\n  baseIRI = baseIRI || '';\n  const baseFragmentPos: number = baseIRI.indexOf('#');\n\n  // Ignore any fragments in the base IRI\n  if (baseFragmentPos > 0) {\n    baseIRI = baseIRI.substr(0, baseFragmentPos);\n  }\n\n  // Convert empty value directly to base IRI\n  if (!relativeIRI.length) {\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    if (baseIRI.indexOf(':') < 0) {\n      throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    return baseIRI;\n  }\n\n  // If the value starts with a query character, concat directly (but strip the existing query)\n  if (relativeIRI.startsWith('?')) {\n    const baseQueryPos: number = baseIRI.indexOf('?');\n    if (baseQueryPos > 0) {\n      baseIRI = baseIRI.substr(0, baseQueryPos);\n    }\n    return baseIRI + relativeIRI;\n  }\n\n  // If the value starts with a fragment character, concat directly\n  if (relativeIRI.startsWith('#')) {\n    return baseIRI + relativeIRI;\n  }\n\n  // Ignore baseIRI if it is empty\n  if (!baseIRI.length) {\n    const relativeColonPos = relativeIRI.indexOf(':');\n    if (relativeColonPos < 0) {\n      throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n    }\n    return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n  }\n\n  // Ignore baseIRI if the value is absolute\n  const valueColonPos: number = relativeIRI.indexOf(':');\n  if (valueColonPos >= 0) {\n    return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n  }\n\n  // At this point, the baseIRI MUST be absolute, otherwise we error\n  const baseColonPos: number = baseIRI.indexOf(':');\n  if (baseColonPos < 0) {\n    throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n  }\n\n  const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n  // Inherit the baseIRI scheme if the value starts with '//'\n  if (relativeIRI.indexOf('//') === 0) {\n    return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n  }\n\n  // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n  let baseSlashAfterColonPos;\n  if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n    // If there is no additional '/' after the '//'.\n    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n    if (baseSlashAfterColonPos < 0) {\n      // If something other than a '/' follows the '://', append the value after a '/',\n      // otherwise, prefix the value with only the baseIRI scheme.\n      if (baseIRI.length > baseColonPos + 3) {\n        return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n      } else {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n      }\n    }\n  } else {\n    // If there is not even a single '/' after the ':'\n    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n    if (baseSlashAfterColonPos < 0) {\n      // If we don't have a '/' after the ':',\n      // prefix the value with only the baseIRI scheme.\n      return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n  }\n\n  // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n  if (relativeIRI.indexOf('/') === 0) {\n    return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n  }\n\n  let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n  const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n\n  // Ignore everything after the last '/' in the baseIRI path\n  if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n    baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n    // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n    // This change is only allowed if there is something else following the path\n    if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n      relativeIRI = relativeIRI.substr(1);\n    }\n  }\n\n  // Prefix the value with the baseIRI path where\n  relativeIRI = baseIRIPath + relativeIRI;\n\n  // Remove dot segment from the IRI\n  relativeIRI = removeDotSegments(relativeIRI);\n\n  // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n  return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\n\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nexport function removeDotSegments(path: string): string {\n  // Prepare a buffer with segments between each '/.\n  // Each segment represents an array of characters.\n  const segmentBuffers: string[][] = [];\n\n  let i = 0;\n  while (i < path.length) {\n    // Remove '/.' or '/..'\n    switch (path[i]) {\n    case '/':\n      if (path[i + 1] === '.') {\n        if (path[i + 2] === '.') {\n          // Start a new segment if we find an invalid character after the '.'\n          if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n            segmentBuffers.push([]);\n            i++;\n            break;\n          }\n\n          // Go to parent directory,\n          // so we remove a parent segment\n          segmentBuffers.pop();\n\n          // Ensure that we end with a slash if there is a trailing '/..'\n          if (!path[i + 3]) {\n            segmentBuffers.push([]);\n          }\n\n          i += 3;\n        } else {\n          // Start a new segment if we find an invalid character after the '.'\n          if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n            segmentBuffers.push([]);\n            i++;\n            break;\n          }\n\n          // Ensure that we end with a slash if there is a trailing '/.'\n          if (!path[i + 2]) {\n            segmentBuffers.push([]);\n          }\n\n          // Go to the current directory,\n          // so we do nothing\n          i += 2;\n        }\n      } else {\n        // Start a new segment\n        segmentBuffers.push([]);\n        i++;\n      }\n      break;\n    case '#':\n    case '?':\n      // Query and fragment string should be appended unchanged\n      if (!segmentBuffers.length) {\n        segmentBuffers.push([]);\n      }\n      segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n      // Break the while loop\n      i = path.length;\n      break;\n    default:\n      // Not a special character, just append it to our buffer\n      if (!segmentBuffers.length) {\n        segmentBuffers.push([]);\n      }\n      segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n      i++;\n      break;\n    }\n  }\n\n  return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\n\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nexport function removeDotSegmentsOfPath(iri: string, colonPosition: number): string {\n  // Determine where we should start looking for the first '/' that indicates the start of the path\n  let searchOffset = colonPosition + 1;\n  if (colonPosition >= 0) {\n    if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n      searchOffset = colonPosition + 3;\n    }\n  } else {\n    if (iri[0] === '/' && iri[1] === '/') {\n      searchOffset = 2;\n    }\n  }\n\n  // Determine the path\n  const pathSeparator = iri.indexOf('/', searchOffset);\n  if (pathSeparator < 0) {\n    return iri;\n  }\n  const base = iri.substr(0, pathSeparator);\n  const path = iri.substr(pathSeparator);\n\n  // Remove dot segments from the path\n  return base + removeDotSegments(path);\n}\n\nfunction isCharacterAllowedAfterRelativePathSegment(character: string) {\n  return !character || character === '#' || character === '?' || character === '/';\n}\n"]}