{"version":3,"file":"MicrodataRdfParser.js","sourceRoot":"","sources":["MicrodataRdfParser.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { DomHandler } from 'domhandler';\nimport { Parser as HtmlParser } from 'htmlparser2';\nimport { PassThrough, Transform } from 'readable-stream';\nimport type { BufferedTagEvent } from './BufferedTagEvent';\nimport type { IHtmlParseListener } from './IHtmlParseListener';\nimport type { IItemScope } from './IItemScope';\nimport type { IVocabRegistry } from './IVocabRegistry';\nimport type { IItemPropertyHandler } from './propertyhandler/IItemPropertyHandler';\nimport { ItemPropertyHandlerContent } from './propertyhandler/ItemPropertyHandlerContent';\nimport { ItemPropertyHandlerNumber } from './propertyhandler/ItemPropertyHandlerNumber';\nimport { ItemPropertyHandlerTime } from './propertyhandler/ItemPropertyHandlerTime';\nimport { ItemPropertyHandlerUrl } from './propertyhandler/ItemPropertyHandlerUrl';\nimport { Util } from './Util';\nimport * as VOCAB_REGISTRY_DEFAULT from './vocab-registry-default.json';\nimport EventEmitter = NodeJS.EventEmitter;\n\n/**\n * A stream transformer that parses Microdata (text) streams to an {@link RDF.Stream}.\n */\nexport class MicrodataRdfParser extends Transform implements RDF.Sink<EventEmitter, RDF.Stream> {\n  private static readonly ITEM_PROPERTY_HANDLERS: IItemPropertyHandler[] = [\n    new ItemPropertyHandlerContent(),\n    new ItemPropertyHandlerUrl('a', 'href'),\n    new ItemPropertyHandlerUrl('area', 'href'),\n    new ItemPropertyHandlerUrl('audio', 'src'),\n    new ItemPropertyHandlerUrl('embed', 'src'),\n    new ItemPropertyHandlerUrl('iframe', 'src'),\n    new ItemPropertyHandlerUrl('img', 'src'),\n    new ItemPropertyHandlerUrl('link', 'href'),\n    new ItemPropertyHandlerUrl('object', 'data'),\n    new ItemPropertyHandlerUrl('source', 'src'),\n    new ItemPropertyHandlerUrl('track', 'src'),\n    new ItemPropertyHandlerUrl('video', 'src'),\n    new ItemPropertyHandlerNumber('data', 'value'),\n    new ItemPropertyHandlerNumber('meter', 'value'),\n    new ItemPropertyHandlerTime(),\n  ];\n\n  private readonly options: IMicrodataRdfParserOptions;\n  private readonly util: Util;\n  private readonly defaultGraph?: RDF.Quad_Graph;\n  private readonly parser: HtmlParser;\n  private readonly htmlParseListener?: IHtmlParseListener;\n  private readonly vocabRegistry: IVocabRegistry;\n\n  // Stacks, where the key is the current depth.\n  private itemScopeStack: (IItemScope | undefined)[] = [];\n  private textBufferStack: (string[] | undefined)[] = [];\n\n  // Variables for managing itemrefs.\n  private isEmittingReferences = false;\n  private readonly pendingItemRefsDomain: Record<string, IItemScope[]> = {};\n  private readonly pendingItemRefsRangeFinalized: Record<string, {\n    events: BufferedTagEvent[];\n    ids: RDF.Quad_Subject[];\n  }> = {};\n  // eslint-disable-next-line lines-between-class-members\n  private readonly pendingItemRefsRangeCollecting: Record<string, {\n    events: BufferedTagEvent[];\n    counter: number;\n    ids: RDF.Quad_Subject[];\n  }> = {};\n  // eslint-disable-next-line lines-between-class-members\n  private emittingReferencesItemScopeIdGenerator: (() => (RDF.NamedNode | RDF.BlankNode)) | undefined;\n\n  public constructor(options?: IMicrodataRdfParserOptions) {\n    super({ readableObjectMode: true });\n    options = options || {};\n    this.options = options;\n\n    this.util = new Util(options.dataFactory, options.baseIRI);\n    this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n    this.htmlParseListener = options.htmlParseListener;\n    this.vocabRegistry = options.vocabRegistry || VOCAB_REGISTRY_DEFAULT;\n\n    this.parser = this.initializeParser(!!options.xmlMode);\n  }\n\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n  public import(stream: EventEmitter): RDF.Stream {\n    const output = new PassThrough({ readableObjectMode: true });\n    stream.on('error', (error: Error) => parsed.emit('error', error));\n    stream.on('data', (data: RDF.Quad) => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new MicrodataRdfParser(this.options));\n    return parsed;\n  }\n\n  public _transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    this.parser.write(chunk.toString());\n    callback();\n  }\n\n  public _flush(callback: (error?: Error | null, data?: any) => void): void {\n    this.parser.end();\n    callback();\n  }\n\n  /**\n   * Get the current item scope for the current depth.\n   * This will skip all undefined item scopes.\n   * @param parent If we should start looking one level higher in the stack.\n   */\n  protected getItemScope(parent?: boolean): IItemScope | undefined {\n    let parentTagI: number = this.itemScopeStack.length - (parent ? 2 : 1);\n    while (parentTagI > 0 && !this.itemScopeStack[parentTagI]) {\n      parentTagI--;\n    }\n    return this.itemScopeStack[parentTagI];\n  }\n\n  /**\n   * Get the current stack depth.\n   */\n  protected getDepth(): number {\n    return this.itemScopeStack.length;\n  }\n\n  public onTagOpen(name: string, attributes: Record<string, string>): void {\n    if (!this.isEmittingReferences) {\n      // If the tag has an 'id', start collecting the whole stack in the item reference buffer\n      if ('id' in attributes) {\n        const id = attributes.id;\n        this.pendingItemRefsRangeCollecting[id] = {\n          events: [],\n          counter: 0,\n          ids: [],\n        };\n      }\n\n      // Store this event in all collecting item reference buffers\n      for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n        buffer.counter++;\n        buffer.events.push({ type: 'open', name, attributes });\n      }\n    }\n\n    // Ensure the text buffer stack is in line with the stack depth\n    this.textBufferStack.push(undefined);\n    // Processing steps based on https://w3c.github.io/microdata-rdf/#rdf-conversion-algorithm\n\n    // 1. Determine the current item scope\n    let itemScope: IItemScope | undefined;\n    if ('itemscope' in attributes) {\n      // Create a new item scope\n      let subject: RDF.NamedNode | RDF.BlankNode;\n      if (this.emittingReferencesItemScopeIdGenerator) {\n        subject = this.emittingReferencesItemScopeIdGenerator();\n      } else {\n        subject = 'itemid' in attributes && this.util.createSubject(attributes.itemid) ||\n          this.util.dataFactory.blankNode();\n\n        // Store the genererated id in all collecting item reference buffers\n        for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n          buffer.ids.push(subject);\n        }\n      }\n      itemScope = { subject };\n\n      // If the id was reused from a reference, block any new triples to be generated from it\n      if (this.isEmittingReferences) {\n        itemScope.blockEmission = true;\n      }\n\n      // Inherit vocab from parent item scope\n      const parentItemScope = this.getItemScope();\n      if (parentItemScope && parentItemScope.vocab) {\n        itemScope.vocab = parentItemScope.vocab;\n      }\n\n      // 2. Push any changes to the item scope to the stack\n      this.itemScopeStack.push(itemScope);\n    } else {\n      // Determine the parent item scope\n      itemScope = this.getItemScope();\n      // 2. Push any changes to the item scope to the stack\n      this.itemScopeStack.push(undefined);\n    }\n\n    // If we have a valid item scope, process the current node\n    if (itemScope) {\n      // 3. Handle item types\n      if ('itemtype' in attributes) {\n        for (const type of this.util.createVocabIris(attributes.itemtype, itemScope, false)) {\n          // 4. Vocab identifier is the first valid item\n          if (!itemScope.vocab) {\n            // 5. Modify vocab based on registry\n            itemScope.vocab = this.util.deriveVocab(type.value, this.vocabRegistry);\n          }\n\n          // Emit item type\n          if (!itemScope.blockEmission) {\n            this.emitTriple(\n              itemScope.subject,\n              this.util.dataFactory.namedNode(`${Util.RDF}type`),\n              type,\n            );\n          }\n        }\n      }\n\n      // Save language in item scope\n      if ('lang' in attributes) {\n        itemScope.language = attributes.lang;\n      }\n      if ('xml:lang' in attributes) {\n        itemScope.language = attributes['xml:lang'];\n      }\n\n      // Handle itemrefs (only if we also had an itemscope)\n      // If we have an itemref, store it in our domain buffer.\n      if ('itemscope' in attributes &&\n        !this.isEmittingReferences && 'itemref' in attributes) {\n        for (const reference of attributes.itemref.split(/\\s+/u)) {\n          if (!(reference in this.pendingItemRefsDomain)) {\n            this.pendingItemRefsDomain[reference] = [];\n          }\n          this.pendingItemRefsDomain[reference].push(itemScope);\n          this.tryToEmitReferences(reference, itemScope);\n        }\n      }\n    }\n\n    // 6. Handle item properties\n    if ('itemprop' in attributes) {\n      this.handleItemProperties(attributes.itemprop, false, itemScope, name, attributes);\n    }\n    // Handle reverse item properties\n    // https://w3c.github.io/microdata-rdf/#reverse-itemprop\n    if ('itemprop-reverse' in attributes) {\n      this.handleItemProperties(attributes['itemprop-reverse'], true, itemScope, name, attributes);\n    }\n  }\n\n  public onText(data: string): void {\n    // Store this event in all collecting item reference buffers\n    if (!this.isEmittingReferences) {\n      for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n        buffer.events.push({ type: 'text', data });\n      }\n    }\n\n    // Save the text inside all item scopes that need to collect text\n    for (const textBuffer of this.textBufferStack) {\n      if (textBuffer) {\n        textBuffer.push(data);\n      }\n    }\n  }\n\n  public onTagClose(): void {\n    // Store this event in all collecting item reference buffers\n    if (!this.isEmittingReferences) {\n      for (const [ reference, buffer ] of Object.entries(this.pendingItemRefsRangeCollecting)) {\n        buffer.counter--;\n        buffer.events.push({ type: 'close' });\n\n        // Once the counter becomes zero, the tag is fully buffered, so we finalize it.\n        if (buffer.counter === 0) {\n          this.pendingItemRefsRangeFinalized[reference] = buffer;\n          delete this.pendingItemRefsRangeCollecting[reference];\n\n          // Try to emit this reference with buffered domain items\n          this.tryToEmitReferences(reference);\n        }\n      }\n    }\n\n    // Emit all triples that were determined in the active tag\n    const itemScope = this.getItemScope(true);\n    if (itemScope) {\n      const depth = this.getDepth();\n      if (itemScope.predicates && depth in itemScope.predicates) {\n        for (const [ predicateKey, predicates ] of Object.entries(itemScope.predicates[depth])) {\n          // First check if we have a child item scope, otherwise get the text content\n          // Safely cast textBufferStack, as it is always defined when itemScope.predicates is defined.\n          const object = this.util.createLiteral(this.textBufferStack[depth]!.join(''), itemScope);\n          this.emitPredicateTriples(itemScope, predicates, object, predicateKey === 'reverse');\n          delete itemScope.predicates[depth][<'forward' | 'reverse'> predicateKey];\n        }\n      }\n    }\n\n    // Remove the active tag from the stack\n    this.itemScopeStack.pop();\n    this.textBufferStack.pop();\n  }\n\n  public onEnd(): void {\n    // Nothing important should happen here.\n  }\n\n  /**\n   * Initialize a new HtmlParser.\n   * @param xmlMode If the parser should be setup in strict mode.\n   */\n  protected initializeParser(xmlMode: boolean): HtmlParser {\n    return new HtmlParser(\n      <DomHandler> <any> {\n        onclosetag: () => {\n          try {\n            this.onTagClose();\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onTagClose();\n            }\n          } catch (error: unknown) {\n            this.emit('error', error);\n          }\n        },\n        onend: () => {\n          try {\n            this.onEnd();\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onEnd();\n            }\n          } catch (error: unknown) {\n            this.emit('error', error);\n          }\n        },\n        onopentag: (name: string, attributes: Record<string, string>) => {\n          try {\n            this.onTagOpen(name, attributes);\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onTagOpen(name, attributes);\n            }\n          } catch (error: unknown) {\n            this.emit('error', error);\n          }\n        },\n        ontext: (data: string) => {\n          try {\n            this.onText(data);\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onText(data);\n            }\n          } catch (error: unknown) {\n            this.emit('error', error);\n          }\n        },\n      },\n      {\n        decodeEntities: true,\n        recognizeSelfClosing: true,\n        xmlMode,\n      },\n    );\n  }\n\n  /**\n   * Handle the given item properties.\n   * @param itempropValue The value of itemprop or itemprop-reverse.\n   * @param reverse If the item properties are reversed (itemprop-reverse).\n   * @param itemScope The current item scope.\n   * @param tagName The current tag name.\n   * @param tagAttributes The current tag attributes.\n   */\n  protected handleItemProperties(\n    itempropValue: string,\n    reverse: boolean,\n    itemScope: IItemScope | undefined,\n    tagName: string,\n    tagAttributes: Record<string, string>,\n  ): void {\n    const parentItemScope = this.getItemScope(true);\n    if (parentItemScope) {\n      // Set predicates in the scope, and handle them on tag close.\n      const depth = this.getDepth();\n      const predicates = this.util.createVocabIris(itempropValue, parentItemScope, true);\n      if (!parentItemScope.predicates) {\n        parentItemScope.predicates = {};\n      }\n      if (!parentItemScope.predicates[depth]) {\n        parentItemScope.predicates[depth] = {};\n      }\n      const predicatesKey = reverse ? 'reverse' : 'forward';\n      parentItemScope.predicates[depth][predicatesKey] = predicates;\n\n      // Append rdf:type predicate if vocabulary expansion applies\n      for (const vocabularyExpansionType of this.util.getVocabularyExpansionType(\n        itempropValue,\n        parentItemScope,\n        this.vocabRegistry,\n      )) {\n        predicates.push(vocabularyExpansionType);\n      }\n\n      // Check if a property handler that applies, forcefully use that as predicate value.\n      // But DON'T call handlers in this prop is a direct (nested) itemscope.\n      if (itemScope && 'itemscope' in tagAttributes) {\n        this.emitPredicateTriples(parentItemScope, predicates, itemScope.subject, reverse);\n\n        // Finalize the predicates, so text values do not apply to them.\n        delete parentItemScope.predicates[depth][predicatesKey];\n      } else {\n        for (const handler of MicrodataRdfParser.ITEM_PROPERTY_HANDLERS) {\n          if (handler.canHandle(tagName, tagAttributes)) {\n            const object = handler.getObject(tagAttributes, this.util, parentItemScope);\n            this.emitPredicateTriples(parentItemScope, predicates, object, reverse);\n\n            // Finalize the predicates, so text values do not apply to them.\n            delete parentItemScope.predicates[depth][predicatesKey];\n          }\n        }\n      }\n\n      // If no valid handler was found, indicate that we should collect text at this depth.\n      if (parentItemScope.predicates[depth][predicatesKey]) {\n        this.textBufferStack[depth] = [];\n      }\n    }\n  }\n\n  /**\n   * Emit the given object for the given predicates.\n   * @param itemScope The current item scope.\n   * @param predicates An array of predicates.\n   * @param object An object.\n   * @param reverse If the triples should be reversed.\n   */\n  protected emitPredicateTriples(\n    itemScope: IItemScope,\n    predicates: RDF.NamedNode[],\n    object: RDF.Quad_Object,\n    reverse: boolean,\n  ): void {\n    if (!itemScope.blockEmission) {\n      for (const predicate of predicates) {\n        if (reverse) {\n          // Literals can not exist in subject position, so they must be ignored.\n          if (object.termType !== 'Literal') {\n            this.emitTriple(object, predicate, itemScope.subject);\n          }\n        } else {\n          this.emitTriple(itemScope.subject, predicate, object);\n        }\n      }\n    }\n  }\n\n  /**\n   * Emit the given triple to the stream.\n   * @param {Quad_Subject} subject A subject term.\n   * @param {Quad_Predicate} predicate A predicate term.\n   * @param {Quad_Object} object An object term.\n   */\n  protected emitTriple(subject: RDF.Quad_Subject, predicate: RDF.Quad_Predicate, object: RDF.Quad_Object): void {\n    this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n  }\n\n  /**\n   * Attempt to emit all pending itemrefs for the given reference.\n   * @param reference An item reference id.\n   * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.\n   */\n  protected tryToEmitReferences(reference: string, itemScopeDomain?: IItemScope): void {\n    const range = this.pendingItemRefsRangeFinalized[reference];\n    if (range) {\n      // Determine the item scope domains to emit\n      let applicableItemScopes: IItemScope[] | undefined;\n      if (itemScopeDomain) {\n        applicableItemScopes = [ itemScopeDomain ];\n\n        // Remove the item from the pending array\n        // Element is guaranteed to exist in buffer\n        const itemScopeDomainIndex = this.pendingItemRefsDomain[reference].indexOf(itemScopeDomain);\n        this.pendingItemRefsDomain[reference].splice(itemScopeDomainIndex, 1);\n      } else {\n        applicableItemScopes = this.pendingItemRefsDomain[reference];\n\n        // Remove all items from the pending array\n        delete this.pendingItemRefsDomain[reference];\n      }\n\n      if (applicableItemScopes) {\n        // Save the stack state\n        const itemScopeStackOld = this.itemScopeStack;\n        const textBufferStackOld = this.textBufferStack;\n        this.isEmittingReferences = true;\n\n        // For all applicable item scopes, emit the buffered events.\n        for (const itemScope of applicableItemScopes) {\n          this.itemScopeStack = [ itemScope ];\n          this.textBufferStack = [ undefined ];\n          const pendingIds = [ ...range.ids ];\n          this.emittingReferencesItemScopeIdGenerator = () => <RDF.NamedNode | RDF.BlankNode> pendingIds.shift();\n          for (const event of range.events) {\n            switch (event.type) {\n              case 'open':\n                this.onTagOpen(event.name, event.attributes);\n                break;\n              case 'text':\n                this.onText(event.data);\n                break;\n              case 'close':\n                this.onTagClose();\n                break;\n            }\n          }\n        }\n\n        // Restore the stack state\n        this.emittingReferencesItemScopeIdGenerator = undefined;\n        this.itemScopeStack = itemScopeStackOld;\n        this.textBufferStack = textBufferStackOld;\n        this.isEmittingReferences = false;\n      }\n    }\n  }\n}\n\nexport interface IMicrodataRdfParserOptions {\n  /**\n   * A custom RDFJS DataFactory to construct terms and triples.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * An initital default base IRI.\n   */\n  baseIRI?: string;\n  /**\n   * The default graph for constructing quads.\n   */\n  defaultGraph?: RDF.Quad_Graph;\n  /**\n   * An optional listener for the internal HTML parse events.\n   */\n  htmlParseListener?: IHtmlParseListener;\n  /**\n   * If the parser should assume strict X(HT)ML documents.\n   */\n  xmlMode?: boolean;\n  /**\n   * A vocabulary registry to define specific behaviour for given URI prefixes.\n   */\n  vocabRegistry?: IVocabRegistry;\n}\n"]}