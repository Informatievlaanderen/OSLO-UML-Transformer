{"version":3,"file":"Util.js","sourceRoot":"","sources":["Util.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { resolve } from 'relative-to-absolute-iri';\nimport type { IItemScope } from './IItemScope';\nimport type { IVocabRegistry } from './IVocabRegistry';\n\n/**\n * A collection of utility functions.\n */\nexport class Util {\n  public static readonly RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  public static readonly XSD = 'http://www.w3.org/2001/XMLSchema#';\n  public static readonly RDFA = 'http://www.w3.org/ns/rdfa#';\n\n  private static readonly IRI_REGEX: RegExp = /^([A-Za-z][\\d+-.A-Za-z]*|_):[^ \"<>[\\\\\\]`{|}]*$/u;\n\n  public readonly dataFactory: RDF.DataFactory;\n  public baseIRI: string;\n\n  public constructor(dataFactory?: RDF.DataFactory, baseIRI?: string) {\n    this.dataFactory = dataFactory || new DataFactory();\n    this.baseIRI = baseIRI || '';\n  }\n\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n  public static isValidIri(iri: string): boolean {\n    return Util.IRI_REGEX.test(iri);\n  }\n\n  /**\n   * Create vocab terms for the given terms attribute.\n   *\n   * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.\n   *\n   * @param {string} terms An attribute value.\n   * @param {IItemScope} itemScope The active item scope.\n   * @param {boolean} allowRelativeIris If relative IRIs are allowed.\n   * @return {Term[]} The IRI terms.\n   */\n  public createVocabIris(terms: string, itemScope: IItemScope, allowRelativeIris: boolean): RDF.NamedNode[] {\n    return <RDF.NamedNode[]> terms.split(/\\s+/u)\n      .filter(term => !!term)\n      .map(property => {\n        if (!Util.isValidIri(property)) {\n          if (!allowRelativeIris) {\n            return;\n          }\n          property = `${itemScope.vocab || `${this.baseIRI}#`}${property}`;\n        }\n        return this.dataFactory.namedNode(property);\n      })\n      .filter(term => !!term);\n  }\n\n  /**\n   * Get the predicates for which the given itemprop value should cause vocabulary expansion.\n   * @param terms An attribute value.\n   * @param itemScope The active item scope.\n   * @param vocabRegistry The active vocabulary registry.\n   */\n  public getVocabularyExpansionType(\n    terms: string,\n    itemScope: IItemScope,\n    vocabRegistry: IVocabRegistry,\n  ): RDF.NamedNode[] {\n    // Check the presence of subPropertyOf or equivalentProperty\n    const parts = terms.split(/\\s+/u);\n    if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {\n      return [ this.dataFactory.namedNode(`${Util.RDF}type`) ];\n    }\n\n    // Check in the item scope's vocab\n    if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {\n      let predicates: RDF.NamedNode[] = [];\n      for (const [ property, expansions ] of Object\n        .entries(vocabRegistry[itemScope.vocab].properties!)) {\n        if (parts.includes(property)) {\n          predicates = [ ...Object.values(expansions).map(iri => this.dataFactory.namedNode(iri)) ];\n        }\n      }\n      return predicates;\n    }\n\n    return [];\n  }\n\n  /**\n   * Create a named node for the given term, which can be relative to the document base.\n   * @param {string} iri A term string.\n   * @return {Term} An RDF term, or undefined if invalid.\n   */\n  public createSubject(iri: string): RDF.NamedNode | undefined {\n    if (!Util.isValidIri(iri)) {\n      try {\n        iri = resolve(iri, this.baseIRI);\n      } catch {\n        return;\n      }\n    }\n    return this.dataFactory.namedNode(iri);\n  }\n\n  /**\n   * Create a new literal node.\n   * @param {string} literal The literal value.\n   * @param {IActiveTag} activeTag The current active tag.\n   * @return {Literal} A new literal node.\n   */\n  public createLiteral(literal: string, activeTag: IItemScope): RDF.Literal {\n    return this.dataFactory.literal(literal, activeTag.language);\n  }\n\n  /**\n   * Determine the vocab IRI from a given type IRI.\n   * @link https://w3c.github.io/microdata-rdf/#property-uri-generation\n   * @param typeIri A type IRI.\n   * @param vocabRegistry The active vocabulary registry.\n   */\n  public deriveVocab(typeIri: string, vocabRegistry: IVocabRegistry): string {\n    let vocab: string | undefined;\n\n    // First check if we find a prefix in the vocab registry\n    for (const uriPrefix in vocabRegistry) {\n      if (typeIri.startsWith(uriPrefix)) {\n        vocab = uriPrefix;\n        // Append fragment if prefix does not end with a slash\n        if (!vocab.endsWith('/')) {\n          vocab += '#';\n        }\n        break;\n      }\n    }\n    // If no match was found, remove the last path segment from the URI\n    if (!vocab) {\n      const hashPos = typeIri.indexOf('#');\n      if (hashPos > 0) {\n        vocab = typeIri.slice(0, hashPos + 1);\n      } else {\n        vocab = resolve('.', typeIri);\n      }\n    }\n    return vocab;\n  }\n}\n"]}