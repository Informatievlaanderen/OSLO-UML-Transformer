"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
/**
 * A collection of utility functions.
 */
class Util {
    constructor(dataFactory, baseIRI) {
        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
        this.baseIRI = baseIRI || '';
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(iri) {
        return Util.IRI_REGEX.test(iri);
    }
    /**
     * Create vocab terms for the given terms attribute.
     *
     * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.
     *
     * @param {string} terms An attribute value.
     * @param {IItemScope} itemScope The active item scope.
     * @param {boolean} allowRelativeIris If relative IRIs are allowed.
     * @return {Term[]} The IRI terms.
     */
    createVocabIris(terms, itemScope, allowRelativeIris) {
        return terms.split(/\s+/u)
            .filter(term => !!term)
            .map(property => {
            if (!Util.isValidIri(property)) {
                if (!allowRelativeIris) {
                    return;
                }
                property = `${itemScope.vocab || `${this.baseIRI}#`}${property}`;
            }
            return this.dataFactory.namedNode(property);
        })
            .filter(term => !!term);
    }
    /**
     * Get the predicates for which the given itemprop value should cause vocabulary expansion.
     * @param terms An attribute value.
     * @param itemScope The active item scope.
     * @param vocabRegistry The active vocabulary registry.
     */
    getVocabularyExpansionType(terms, itemScope, vocabRegistry) {
        // Check the presence of subPropertyOf or equivalentProperty
        const parts = terms.split(/\s+/u);
        if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {
            return [this.dataFactory.namedNode(`${Util.RDF}type`)];
        }
        // Check in the item scope's vocab
        if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {
            let predicates = [];
            for (const [property, expansions] of Object
                .entries(vocabRegistry[itemScope.vocab].properties)) {
                if (parts.includes(property)) {
                    predicates = [...Object.values(expansions).map(iri => this.dataFactory.namedNode(iri))];
                }
            }
            return predicates;
        }
        return [];
    }
    /**
     * Create a named node for the given term, which can be relative to the document base.
     * @param {string} iri A term string.
     * @return {Term} An RDF term, or undefined if invalid.
     */
    createSubject(iri) {
        if (!Util.isValidIri(iri)) {
            try {
                iri = (0, relative_to_absolute_iri_1.resolve)(iri, this.baseIRI);
            }
            catch (_a) {
                return;
            }
        }
        return this.dataFactory.namedNode(iri);
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */
    createLiteral(literal, activeTag) {
        return this.dataFactory.literal(literal, activeTag.language);
    }
    /**
     * Determine the vocab IRI from a given type IRI.
     * @link https://w3c.github.io/microdata-rdf/#property-uri-generation
     * @param typeIri A type IRI.
     * @param vocabRegistry The active vocabulary registry.
     */
    deriveVocab(typeIri, vocabRegistry) {
        let vocab;
        // First check if we find a prefix in the vocab registry
        for (const uriPrefix in vocabRegistry) {
            if (typeIri.startsWith(uriPrefix)) {
                vocab = uriPrefix;
                // Append fragment if prefix does not end with a slash
                if (!vocab.endsWith('/')) {
                    vocab += '#';
                }
                break;
            }
        }
        // If no match was found, remove the last path segment from the URI
        if (!vocab) {
            const hashPos = typeIri.indexOf('#');
            if (hashPos > 0) {
                vocab = typeIri.slice(0, hashPos + 1);
            }
            else {
                vocab = (0, relative_to_absolute_iri_1.resolve)('.', typeIri);
            }
        }
        return vocab;
    }
}
exports.Util = Util;
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.RDFA = 'http://www.w3.org/ns/rdfa#';
Util.IRI_REGEX = /^([A-Za-z][\d+-.A-Za-z]*|_):[^ "<>[\\\]`{|}]*$/u;
//# sourceMappingURL=Util.js.map