import * as RDF from "@rdfjs/types";
/**
 * The possible quad term entries in an RDFJS quad.
 */
export type QuadTermName = 'subject' | 'predicate' | 'object' | 'graph';
/**
 * All available quad term names.
 * @type {[string , string , string , string]}
 */
export declare const QUAD_TERM_NAMES: QuadTermName[];
/**
 * All available triple term names.
 * @type {[string , string , string]}
 */
export declare const TRIPLE_TERM_NAMES: QuadTermName[];
/**
 * An RDFJS term with a quad term name key.
 */
export interface INamedTerm {
    /**
     * A quad term name.
     */
    key: QuadTermName;
    /**
     * An RDFJS term.
     */
    value: RDF.Term;
}
/**
 * Get all terms in the given quad.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,
 *                                     this term will not be returned in the array.
 *                                     (default: false)
 * @return {Term[]} The available terms in the quad.
 */
export declare function getTerms(quad: RDF.BaseQuad, ignoreDefaultGraph?: boolean): RDF.Term[];
/**
 * Get all terms in the given quad, including nested quads.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,
 *                                     this term will not be returned in the array.
 *                                     (default: false)
 * @return {Term[]} The available terms in the nested quad, excluding quad terms.
 */
export declare function getTermsNested(quad: RDF.BaseQuad, ignoreDefaultGraph?: boolean): RDF.Term[];
/**
 * Convert the given quad to an array of named terms.
 * This is the reverse operation of {@link collectNamedTerms}.
 * @param {BaseQuad} quad An RDFJS quad.
 * @return {INamedTerm[]} An array of named terms.
 */
export declare function getNamedTerms(quad: RDF.BaseQuad): INamedTerm[];
/**
 * Convert an array of named terms to an RDFJS quad.
 * This is the reverse operation of {@link getNamedTerms}.
 * @param {INamedTerm[]} namedTerms An array of named terms.
 * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when
 *                                                     certain terms are not available in the array.
 * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.
 * @return {Q} The resulting RDFJS quad.
 * @template Q The type of quad to output, defaults to RDF.Quad.
 */
export declare function collectNamedTerms<Q extends RDF.BaseQuad = RDF.Quad>(namedTerms: INamedTerm[], defaultCb?: (termName: QuadTermName) => RDF.Term, dataFactory?: RDF.DataFactory<Q>): Q;
/**
 * Iterates over each term.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} cb A callback function.
 */
export declare function forEachTerms(quad: RDF.BaseQuad, cb: (value: RDF.Term, key: QuadTermName) => void): void;
/**
 * Iterates over each leaf term, while recursing into quoted triples.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} cb A callback function.
 * @param QuadTermName[] keys The current key path.
 */
export declare function forEachTermsNested(quad: RDF.BaseQuad, cb: (value: RDF.Term, keys: QuadTermName[]) => void, keys?: QuadTermName[]): void;
/**
 * Get all terms in the given quad that return true on the given filter function.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.
 * @return {Term[]} The list of matching terms.
 */
export declare function filterTerms(quad: RDF.BaseQuad, filter: (value: RDF.Term, key: QuadTermName) => boolean): RDF.Term[];
/**
 * Get all terms in the given quad that return true on the given filter function, while recursing into quoted triples.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.
 * @param QuadTermName[] keys The current key path.
 * @return {Term[]} The list of matching terms.
 */
export declare function filterTermsNested(quad: RDF.BaseQuad, filter: (value: RDF.Term, keys: QuadTermName[]) => boolean, keys?: QuadTermName[]): RDF.Term[];
/**
 * Get all quad term names in the given quad that return true on the given filter function.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.
 * @return {QuadTermName[]} The list of matching quad term names.
 */
export declare function filterQuadTermNames(quad: RDF.BaseQuad, filter: (value: RDF.Term, key: QuadTermName) => boolean): QuadTermName[];
/**
 * Get all quad term names in the given quad that return true on the given filter function, while recursing into quoted triples.
 * @param {BaseQuad} quad A quad.
 * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.
 * @param QuadTermName[] keys The current key path.
 * @return {QuadTermName[]} The list of matching quad term names.
 */
export declare function filterQuadTermNamesNested(quad: RDF.BaseQuad, filter: (value: RDF.Term, keys: QuadTermName[]) => boolean, keys?: QuadTermName[]): QuadTermName[][];
/**
 * Map all terms of a quad.
 * @param {Quad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.
 * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.
 * @return {Quad} A new RDFJS quad.
 * @template Q The type of quad, defaults to RDF.Quad.
 */
export declare function mapTerms<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, mapper: (term: RDF.Term, key: QuadTermName) => RDF.Term, dataFactory?: RDF.DataFactory<Q>): Q;
/**
 * Map all terms of a quad, while recursing into quoted triples.
 * @param {Quad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.
 * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.
 * @param QuadTermName[] keys The current key path.
 * @return {Quad} A new RDFJS quad.
 * @template Q The type of quad, defaults to RDF.Quad.
 */
export declare function mapTermsNested<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, mapper: (term: RDF.Term, keys: QuadTermName[]) => RDF.Term, dataFactory?: RDF.DataFactory<Q>, keys?: QuadTermName[]): Q;
/**
 * Reduce all terms of a quad.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.
 * @param {U} initialValue The initial value.
 * @return {U} The final value.
 */
export declare function reduceTerms<U>(quad: RDF.BaseQuad, reducer: (previousValue: U, currentValue: RDF.Term, key: QuadTermName) => U, initialValue: U): U;
/**
 * Reduce all terms of a quad, while recursing into quoted triples.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.
 * @param {U} initialValue The initial value.
 * @param QuadTermName[] keys The current key path.
 * @return {U} The final value.
 */
export declare function reduceTermsNested<U>(quad: RDF.BaseQuad, reducer: (previousValue: U, currentValue: RDF.Term, keys: QuadTermName[]) => U, initialValue: U, keys?: QuadTermName[]): U;
/**
 * Determines whether all terms satisfy the specified test.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @return {boolean} If all terms satisfy the specified test.
 */
export declare function everyTerms(quad: RDF.BaseQuad, checker: (value: RDF.Term, key: QuadTermName) => boolean): boolean;
/**
 * Determines whether all terms satisfy the specified test, while recursing into quoted triples.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @param QuadTermName[] keys The current key path.
 * @return {boolean} If all terms satisfy the specified test.
 */
export declare function everyTermsNested(quad: RDF.BaseQuad, checker: (value: RDF.Term, keys: QuadTermName[]) => boolean, keys?: QuadTermName[]): boolean;
/**
 * Determines whether at least one term satisfies the specified test.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @return {boolean} If at least one term satisfies the specified test.
 */
export declare function someTerms(quad: RDF.BaseQuad, checker: (value: RDF.Term, key: QuadTermName) => boolean): boolean;
/**
 * Determines whether at least one term satisfies the specified test, while recursing into quoted triples.
 * @param {BaseQuad} quad An RDFJS quad.
 * @param {(value: Term, key: QuadTermName} checker A checker function.
 * @param QuadTermName[] keys The current key path.
 * @return {boolean} If at least one term satisfies the specified test.
 */
export declare function someTermsNested(quad: RDF.BaseQuad, checker: (value: RDF.Term, keys: QuadTermName[]) => boolean, keys?: QuadTermName[]): boolean;
/**
 * Get the nested value inside a quoted triple by the given path of quad keys.
 * @param term A term, that can be a quoted triple.
 * @param keys A path of quad term names.
 */
export declare function getValueNestedPath(term: RDF.Term, keys: QuadTermName[]): RDF.Term;
/**
 * Check if the given terms match.
 *
 * At least one of the following must be true:
 * * Term B is undefined.
 * * Term B is a variable.
 * * Term A and B are quads, and return true for `matchPatternComplete`.
 * * Quad term and term are equal (`termB.equals(termA)` return true)
 *
 * @param termA A term.
 * @param termB An optional term.
 */
export declare function matchTerm(termA: RDF.Term, termB?: RDF.Term): boolean;
/**
 * Check if the given quad matches with the given quad terms.
 *
 * Each term must match at least one of the following:
 * * Term is undefined.
 * * Term is a variable.
 * * Quad term and term are both quads, and return true for `matchPatternComplete`.
 * * Quad term and term are equal (`quadTerm.equals(term)` return true)
 *
 * @param {BaseQuad} quad A quad to match with (can not contain variables).
 * @param {Term} subject An optional subject.
 * @param {Term} predicate An optional predicate.
 * @param {Term} object An optional object.
 * @param {Term} graph An optional graph.
 * @return {boolean} If the quad matches with the quad terms.
 */
export declare function matchPattern(quad: RDF.BaseQuad, subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): boolean;
/**
 * Check if the first quad matches with all terms from the second quad.
 *
 * Each term must match at least one of the following:
 * * Quad2 term is a variable.
 * * Quad1 term and Quad2 term are equal (`term1.equals(term2)` return true)
 *
 * @param {BaseQuad} quad A quad (can not contain variables).
 * @param {BaseQuad} pattern A quad pattern (can contain variables).
 * @return {boolean} If the quad terms match.
 */
export declare function matchPatternComplete(quad: RDF.BaseQuad, pattern: RDF.BaseQuad): boolean;
/**
 * Check if the first quad matches against all terms in the pattern,
 * by taking into account the mappings of the variables.
 * If the same variable occurs multiple times in the pattern,
 * then the corresponding terms in the quad must be equal.
 *
 * Each term in the quad must satisfy the following:
 * * The pattern term is a variable, and all other variables with the same value - map to the same terms in the quad
 * * Both the quad term and pattern term are quads - and they satisfy the same conditions
 * * The pattern and quad terms are equal and not variables or quads
 *
 * @param quad A quad - possibly containing variables
 * @param pattern A pattern - possibly containing variables
 * @param options
 *    skipVarMapping - don't add variables in the quad to the mapping
 *    returnMappings - return the mappings if it is a valid match
 */
export declare function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad): boolean;
export declare function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad, opt: {
    skipVarMapping?: boolean;
    returnMappings?: false;
}): boolean;
export declare function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad, opt: {
    skipVarMapping?: boolean;
    returnMappings: true;
}): false | Record<string, RDF.Term>;
