{"version":3,"file":"QuadTermUtil.js","sourceRoot":"","sources":["QuadTermUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataFactory } from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\n\nconst DF = new DataFactory();\n\n/*\n * Utility methods for handling terms in RDFJS quads.\n */\n\n/**\n * The possible quad term entries in an RDFJS quad.\n */\nexport type QuadTermName = 'subject' | 'predicate' | 'object' | 'graph';\n\n/**\n * All available quad term names.\n * @type {[string , string , string , string]}\n */\nexport const QUAD_TERM_NAMES: QuadTermName[] = ['subject', 'predicate', 'object', 'graph'];\n\n/**\n * All available triple term names.\n * @type {[string , string , string]}\n */\nexport const TRIPLE_TERM_NAMES: QuadTermName[] = ['subject', 'predicate', 'object'];\n\n/**\n * An RDFJS term with a quad term name key.\n */\nexport interface INamedTerm {\n  /**\n   * A quad term name.\n   */\n  key: QuadTermName;\n  /**\n   * An RDFJS term.\n   */\n  value: RDF.Term;\n}\n\n/**\n * Get all terms in the given quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the quad.\n */\nexport function getTerms(quad: RDF.BaseQuad, ignoreDefaultGraph?: boolean): RDF.Term[] {\n  if (ignoreDefaultGraph && quad.graph.termType === 'DefaultGraph') {\n    return [ quad.subject, quad.predicate, quad.object ];\n  }\n  return [ quad.subject, quad.predicate, quad.object, quad.graph ];\n}\n\n/**\n * Get all terms in the given quad, including nested quads.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the nested quad, excluding quad terms.\n */\nexport function getTermsNested(quad: RDF.BaseQuad, ignoreDefaultGraph?: boolean): RDF.Term[] {\n  const terms: RDF.Term[] = [];\n  for (const term of getTerms(quad, ignoreDefaultGraph)) {\n    if (term.termType === 'Quad') {\n      getTermsNested(term, ignoreDefaultGraph).forEach(subTerm => terms.push(subTerm));\n    } else {\n      terms.push(term);\n    }\n  }\n  return terms;\n}\n\n/**\n * Convert the given quad to an array of named terms.\n * This is the reverse operation of {@link collectNamedTerms}.\n * @param {BaseQuad} quad An RDFJS quad.\n * @return {INamedTerm[]} An array of named terms.\n */\nexport function getNamedTerms(quad: RDF.BaseQuad): INamedTerm[] {\n  return [\n    { key: 'subject',   value: quad.subject },\n    { key: 'predicate', value: quad.predicate },\n    { key: 'object',    value: quad.object },\n    { key: 'graph',     value: quad.graph },\n  ];\n}\n\n/**\n * Convert an array of named terms to an RDFJS quad.\n * This is the reverse operation of {@link getNamedTerms}.\n * @param {INamedTerm[]} namedTerms An array of named terms.\n * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when\n *                                                     certain terms are not available in the array.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Q} The resulting RDFJS quad.\n * @template Q The type of quad to output, defaults to RDF.Quad.\n */\nexport function collectNamedTerms<Q extends RDF.BaseQuad = RDF.Quad>(\n  namedTerms: INamedTerm[], defaultCb?: (termName: QuadTermName) => RDF.Term, dataFactory?: RDF.DataFactory<Q>): Q {\n  const elements: {[id: string]: RDF.Term} = {};\n  namedTerms.forEach((namedTerm: INamedTerm) => elements[namedTerm.key] = namedTerm.value);\n  if (defaultCb) {\n    elements.subject   = elements.subject   || defaultCb('subject');\n    elements.predicate = elements.predicate || defaultCb('predicate');\n    elements.object    = elements.object    || defaultCb('object');\n    elements.graph     = elements.graph     || defaultCb('graph');\n  }\n  return (dataFactory || <RDF.DataFactory<Q>> <any> DF).quad(\n    elements.subject, elements.predicate, elements.object, elements.graph);\n}\n\n/**\n * Iterates over each term.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} cb A callback function.\n */\nexport function forEachTerms(quad: RDF.BaseQuad,\n                             cb: (value: RDF.Term, key: QuadTermName) => void) {\n  cb(quad.subject,   'subject');\n  cb(quad.predicate, 'predicate');\n  cb(quad.object,    'object');\n  cb(quad.graph,     'graph');\n}\n\n/**\n * Iterates over each leaf term, while recursing into quoted triples.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} cb A callback function.\n * @param QuadTermName[] keys The current key path.\n */\nexport function forEachTermsNested(quad: RDF.BaseQuad,\n                                   cb: (value: RDF.Term, keys: QuadTermName[]) => void,\n                                   keys: QuadTermName[] = []) {\n  if (quad.subject.termType === 'Quad') {\n    forEachTermsNested(quad.subject, cb, [ ...keys, 'subject' ]);\n  } else {\n    cb(quad.subject,   [ ...keys, 'subject' ]);\n  }\n  if (quad.predicate.termType === 'Quad') {\n    forEachTermsNested(quad.predicate, cb, [ ...keys, 'predicate' ]);\n  } else {\n    cb(quad.predicate,   [ ...keys, 'predicate' ]);\n  }\n  if (quad.object.termType === 'Quad') {\n    forEachTermsNested(quad.object, cb, [ ...keys, 'object' ]);\n  } else {\n    cb(quad.object,   [ ...keys, 'object' ]);\n  }\n  if (quad.graph.termType === 'Quad') {\n    forEachTermsNested(quad.graph, cb, [ ...keys, 'graph' ]);\n  } else {\n    cb(quad.graph,   [ ...keys, 'graph' ]);\n  }\n}\n\n/**\n * Get all terms in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.\n * @return {Term[]} The list of matching terms.\n */\nexport function filterTerms(quad: RDF.BaseQuad, filter: (value: RDF.Term, key: QuadTermName) => boolean): RDF.Term[] {\n  const terms: RDF.Term[] = [];\n  if (filter(quad.subject, 'subject')) {\n    terms.push(quad.subject);\n  }\n  if (filter(quad.predicate, 'predicate')) {\n    terms.push(quad.predicate);\n  }\n  if (filter(quad.object, 'object')) {\n    terms.push(quad.object);\n  }\n  if (filter(quad.graph, 'graph')) {\n    terms.push(quad.graph);\n  }\n  return terms;\n}\n\n/**\n * Get all terms in the given quad that return true on the given filter function, while recursing into quoted triples.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.\n * @param QuadTermName[] keys The current key path.\n * @return {Term[]} The list of matching terms.\n */\nexport function filterTermsNested(quad: RDF.BaseQuad, filter: (value: RDF.Term, keys: QuadTermName[]) => boolean,\n                                  keys: QuadTermName[] = []): RDF.Term[] {\n  let terms: RDF.Term[] = [];\n  if (quad.subject.termType === 'Quad') {\n    terms = [ ...terms, ...filterTermsNested(quad.subject, filter, [ ...keys, 'subject' ]) ];\n  } else {\n    if (filter(quad.subject, [ ...keys, 'subject' ])) {\n      terms.push(quad.subject);\n    }\n  }\n  if (quad.predicate.termType === 'Quad') {\n    terms = [ ...terms, ...filterTermsNested(quad.predicate, filter, [ ...keys, 'predicate' ]) ];\n  } else {\n    if (filter(quad.predicate, [ ...keys, 'predicate' ])) {\n      terms.push(quad.predicate);\n    }\n  }\n  if (quad.object.termType === 'Quad') {\n    terms = [ ...terms, ...filterTermsNested(quad.object, filter, [ ...keys, 'object' ]) ];\n  } else {\n    if (filter(quad.object, [...keys, 'object'])) {\n      terms.push(quad.object);\n    }\n  }\n  if (quad.graph.termType === 'Quad') {\n    terms = [ ...terms, ...filterTermsNested(quad.graph, filter, [ ...keys, 'graph' ]) ];\n  } else {\n    if (filter(quad.graph, [...keys, 'graph'])) {\n      terms.push(quad.graph);\n    }\n  }\n  return terms;\n}\n\n/**\n * Get all quad term names in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.\n * @return {QuadTermName[]} The list of matching quad term names.\n */\nexport function filterQuadTermNames(quad: RDF.BaseQuad,\n                                    filter: (value: RDF.Term, key: QuadTermName) => boolean): QuadTermName[] {\n  const names: QuadTermName[] = [];\n  if (filter(quad.subject, 'subject')) {\n    names.push('subject');\n  }\n  if (filter(quad.predicate, 'predicate')) {\n    names.push('predicate');\n  }\n  if (filter(quad.object, 'object')) {\n    names.push('object');\n  }\n  if (filter(quad.graph, 'graph')) {\n    names.push('graph');\n  }\n  return names;\n}\n\n/**\n * Get all quad term names in the given quad that return true on the given filter function, while recursing into quoted triples.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.\n * @param QuadTermName[] keys The current key path.\n * @return {QuadTermName[]} The list of matching quad term names.\n */\nexport function filterQuadTermNamesNested(quad: RDF.BaseQuad,\n                                          filter: (value: RDF.Term, keys: QuadTermName[]) => boolean,\n                                          keys: QuadTermName[] = []): QuadTermName[][] {\n  let names: QuadTermName[][] = [];\n  const keysS: QuadTermName[] = [ ...keys, 'subject' ];\n  if (quad.subject.termType === 'Quad') {\n    names = [ ...names, ...filterQuadTermNamesNested(quad.subject, filter, keysS) ];\n  } else {\n    if (filter(quad.subject, keysS)) {\n      names.push(keysS);\n    }\n  }\n  const keysP: QuadTermName[] = [ ...keys, 'predicate' ];\n  if (quad.predicate.termType === 'Quad') {\n    names = [ ...names, ...filterQuadTermNamesNested(quad.predicate, filter, keysP) ];\n  } else {\n    if (filter(quad.predicate, keysP)) {\n      names.push(keysP);\n    }\n  }\n  const keysO: QuadTermName[] = [ ...keys, 'object' ];\n  if (quad.object.termType === 'Quad') {\n    names = [ ...names, ...filterQuadTermNamesNested(quad.object, filter, keysO) ];\n  } else {\n    if (filter(quad.object, keysO)) {\n      names.push(keysO);\n    }\n  }\n  const keysG: QuadTermName[] = [ ...keys, 'graph' ];\n  if (quad.graph.termType === 'Quad') {\n    names = [ ...names, ...filterQuadTermNamesNested(quad.graph, filter, keysG) ];\n  } else {\n    if (filter(quad.graph, keysG)) {\n      names.push(keysG);\n    }\n  }\n  return names;\n}\n\n/**\n * Map all terms of a quad.\n * @param {Quad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Quad} A new RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function mapTerms<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q,\n                                                            mapper: (term: RDF.Term, key: QuadTermName) => RDF.Term,\n                                                            dataFactory?: RDF.DataFactory<Q>): Q {\n  return (dataFactory || <RDF.DataFactory<Q>> <any> DF).quad(\n    mapper(quad.subject, 'subject'),\n    mapper(quad.predicate, 'predicate'),\n    mapper(quad.object, 'object'),\n    mapper(quad.graph, 'graph'),\n  );\n}\n\n/**\n * Map all terms of a quad, while recursing into quoted triples.\n * @param {Quad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @param QuadTermName[] keys The current key path.\n * @return {Quad} A new RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function mapTermsNested<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q,\n                                                                  mapper: (term: RDF.Term, keys: QuadTermName[]) => RDF.Term,\n                                                                  dataFactory?: RDF.DataFactory<Q>,\n                                                                  keys: QuadTermName[] = []): Q {\n  return (dataFactory || <RDF.DataFactory<Q>> <any> DF).quad(\n    quad.subject.termType === 'Quad' ?\n      mapTermsNested(quad.subject, mapper, dataFactory, [ ...keys, 'subject' ]) :\n      mapper(quad.subject, [ ...keys, 'subject' ]),\n    quad.predicate.termType === 'Quad' ?\n      mapTermsNested(quad.predicate, mapper, dataFactory, [ ...keys, 'predicate' ]) :\n      mapper(quad.predicate, [ ...keys, 'predicate' ]),\n    quad.object.termType === 'Quad' ?\n      mapTermsNested(quad.object, mapper, dataFactory, [ ...keys, 'object' ]) :\n      mapper(quad.object, [ ...keys, 'object' ]),\n    quad.graph.termType === 'Quad' ?\n      mapTermsNested(quad.graph, mapper, dataFactory, [ ...keys, 'graph' ]) :\n      mapper(quad.graph, [ ...keys, 'graph' ]),\n  );\n}\n\n/**\n * Reduce all terms of a quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.\n * @param {U} initialValue The initial value.\n * @return {U} The final value.\n */\nexport function reduceTerms<U>(quad: RDF.BaseQuad,\n                               reducer: (previousValue: U, currentValue: RDF.Term, key: QuadTermName) => U,\n                               initialValue: U): U {\n  let value: U = initialValue;\n  value = reducer(value, quad.subject,   'subject');\n  value = reducer(value, quad.predicate, 'predicate');\n  value = reducer(value, quad.object,    'object');\n  return  reducer(value, quad.graph,     'graph');\n}\n\n/**\n * Reduce all terms of a quad, while recursing into quoted triples.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.\n * @param {U} initialValue The initial value.\n * @param QuadTermName[] keys The current key path.\n * @return {U} The final value.\n */\nexport function reduceTermsNested<U>(quad: RDF.BaseQuad,\n                                     reducer: (previousValue: U, currentValue: RDF.Term, keys: QuadTermName[]) => U,\n                                     initialValue: U,\n                                     keys: QuadTermName[] = []): U {\n  let value: U = initialValue;\n  if (quad.subject.termType === 'Quad') {\n    value = reduceTermsNested(quad.subject, reducer, value, [ ...keys, 'subject' ]);\n  } else {\n    value = reducer(value, quad.subject,   [ ...keys, 'subject' ]);\n  }\n  if (quad.predicate.termType === 'Quad') {\n    value = reduceTermsNested(quad.predicate, reducer, value, [ ...keys, 'predicate' ]);\n  } else {\n    value = reducer(value, quad.predicate,   [ ...keys, 'predicate' ]);\n  }\n  if (quad.object.termType === 'Quad') {\n    value = reduceTermsNested(quad.object, reducer, value, [ ...keys, 'object' ]);\n  } else {\n    value = reducer(value, quad.object,   [ ...keys, 'object' ]);\n  }\n  if (quad.graph.termType === 'Quad') {\n    value = reduceTermsNested(quad.graph, reducer, value, [ ...keys, 'graph' ]);\n  } else {\n    value = reducer(value, quad.graph,   [ ...keys, 'graph' ]);\n  }\n  return value;\n}\n\n/**\n * Determines whether all terms satisfy the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If all terms satisfy the specified test.\n */\nexport function everyTerms(quad: RDF.BaseQuad,\n                           checker: (value: RDF.Term, key: QuadTermName) => boolean): boolean {\n  return checker(quad.subject,   'subject')\n      && checker(quad.predicate, 'predicate')\n      && checker(quad.object,    'object')\n      && checker(quad.graph,     'graph');\n}\n\n/**\n * Determines whether all terms satisfy the specified test, while recursing into quoted triples.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @param QuadTermName[] keys The current key path.\n * @return {boolean} If all terms satisfy the specified test.\n */\nexport function everyTermsNested(quad: RDF.BaseQuad,\n                                 checker: (value: RDF.Term, keys: QuadTermName[]) => boolean,\n                                 keys: QuadTermName[] = []): boolean {\n  return (quad.subject.termType === 'Quad' ?\n    everyTermsNested(quad.subject, checker, [ ...keys, 'subject' ]) :\n    checker(quad.subject, [ ...keys, 'subject' ]))\n    && (quad.predicate.termType === 'Quad' ?\n      everyTermsNested(quad.predicate, checker, [ ...keys, 'predicate' ]) :\n      checker(quad.predicate, [ ...keys, 'predicate' ]))\n    && (quad.object.termType === 'Quad' ?\n      everyTermsNested(quad.object, checker, [ ...keys, 'object' ]) :\n      checker(quad.object, [ ...keys, 'object' ]))\n    && (quad.graph.termType === 'Quad' ?\n      everyTermsNested(quad.graph, checker, [ ...keys, 'graph' ]) :\n      checker(quad.graph, [ ...keys, 'graph' ]))\n}\n\n/**\n * Determines whether at least one term satisfies the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If at least one term satisfies the specified test.\n */\nexport function someTerms(quad: RDF.BaseQuad,\n                          checker: (value: RDF.Term, key: QuadTermName) => boolean): boolean {\n  return checker(quad.subject,   'subject')\n      || checker(quad.predicate, 'predicate')\n      || checker(quad.object,    'object')\n      || checker(quad.graph,     'graph');\n}\n\n/**\n * Determines whether at least one term satisfies the specified test, while recursing into quoted triples.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @param QuadTermName[] keys The current key path.\n * @return {boolean} If at least one term satisfies the specified test.\n */\nexport function someTermsNested(quad: RDF.BaseQuad,\n                                checker: (value: RDF.Term, keys: QuadTermName[]) => boolean,\n                                keys: QuadTermName[] = []): boolean {\n  return (quad.subject.termType === 'Quad' ?\n      someTermsNested(quad.subject, checker, [ ...keys, 'subject' ]) :\n      checker(quad.subject,   [ ...keys, 'subject' ]))\n    || (quad.predicate.termType === 'Quad' ?\n      someTermsNested(quad.predicate, checker, [ ...keys, 'predicate' ]) :\n      checker(quad.predicate,   [ ...keys, 'predicate' ]))\n    || (quad.object.termType === 'Quad' ?\n      someTermsNested(quad.object, checker, [ ...keys, 'object' ]) :\n      checker(quad.object,   [ ...keys, 'object' ]))\n    || (quad.graph.termType === 'Quad' ?\n      someTermsNested(quad.graph, checker, [ ...keys, 'graph' ]) :\n      checker(quad.graph,   [ ...keys, 'graph' ]));\n}\n\n/**\n * Get the nested value inside a quoted triple by the given path of quad keys.\n * @param term A term, that can be a quoted triple.\n * @param keys A path of quad term names.\n */\nexport function getValueNestedPath(term: RDF.Term, keys: QuadTermName[]): RDF.Term {\n  if (keys.length === 0) {\n    return term;\n  }\n  if (term.termType === 'Quad') {\n    return getValueNestedPath(term[keys[0]], keys.slice(1));\n  }\n  throw new Error(`Tried to get ${keys[0]} from term of type ${term.termType}`);\n}\n\n/**\n * Check if the given terms match.\n *\n * At least one of the following must be true:\n * * Term B is undefined.\n * * Term B is a variable.\n * * Term A and B are quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`termB.equals(termA)` return true)\n *\n * @param termA A term.\n * @param termB An optional term.\n */\nexport function matchTerm(termA: RDF.Term, termB?: RDF.Term) {\n  return !termB\n    || termB.termType === 'Variable'\n    || (termB.termType === 'Quad' && termA.termType === 'Quad' && matchPatternComplete(termA, termB))\n    || termB.equals(termA);\n}\n\n/**\n * Check if the given quad matches with the given quad terms.\n *\n * Each term must match at least one of the following:\n * * Term is undefined.\n * * Term is a variable.\n * * Quad term and term are both quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`quadTerm.equals(term)` return true)\n *\n * @param {BaseQuad} quad A quad to match with (can not contain variables).\n * @param {Term} subject An optional subject.\n * @param {Term} predicate An optional predicate.\n * @param {Term} object An optional object.\n * @param {Term} graph An optional graph.\n * @return {boolean} If the quad matches with the quad terms.\n */\nexport function matchPattern(quad: RDF.BaseQuad, subject?: RDF.Term, predicate?: RDF.Term,\n                             object?: RDF.Term, graph?: RDF.Term): boolean {\n  return matchTerm(quad.subject, subject)\n    && matchTerm(quad.predicate, predicate)\n    && matchTerm(quad.object, object)\n    && matchTerm(quad.graph, graph);\n}\n\n/**\n * Check if the first quad matches with all terms from the second quad.\n *\n * Each term must match at least one of the following:\n * * Quad2 term is a variable.\n * * Quad1 term and Quad2 term are equal (`term1.equals(term2)` return true)\n *\n * @param {BaseQuad} quad A quad (can not contain variables).\n * @param {BaseQuad} pattern A quad pattern (can contain variables).\n * @return {boolean} If the quad terms match.\n */\nexport function matchPatternComplete(quad: RDF.BaseQuad, pattern: RDF.BaseQuad): boolean {\n  return matchPattern(quad, pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n}\n\n/**\n * Check if the first quad matches against all terms in the pattern,\n * by taking into account the mappings of the variables.\n * If the same variable occurs multiple times in the pattern,\n * then the corresponding terms in the quad must be equal.\n *\n * Each term in the quad must satisfy the following:\n * * The pattern term is a variable, and all other variables with the same value - map to the same terms in the quad\n * * Both the quad term and pattern term are quads - and they satisfy the same conditions\n * * The pattern and quad terms are equal and not variables or quads\n *\n * @param quad A quad - possibly containing variables\n * @param pattern A pattern - possibly containing variables\n * @param options\n *    skipVarMapping - don't add variables in the quad to the mapping\n *    returnMappings - return the mappings if it is a valid match\n */\nexport function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad): boolean;\nexport function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad, opt: { skipVarMapping?: boolean; returnMappings?: false }): boolean;\nexport function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad, opt: { skipVarMapping?: boolean; returnMappings: true }): false | Record<string, RDF.Term>;\nexport function matchPatternMappings(quad: RDF.BaseQuad, pattern: RDF.BaseQuad, opt: PatternOptions = {}): boolean | Record<string, RDF.Term> {\n  const map: Record<string, RDF.Term> = {};\n  function match(_pattern: RDF.BaseQuad, _quad: RDF.BaseQuad): boolean {\n    return everyTerms(_pattern, (t1, key) => {\n      const t2 = _quad[key];\n      switch (t1.termType) {\n      case 'Variable':\n        return (opt.skipVarMapping && t2.termType === 'Variable')\n          || (map[t1.value]?.equals(t2) ?? (map[t1.value] = t2, true));\n      case 'Quad':\n        return t2.termType === 'Quad' && match(t1, t2);\n      default:\n        return t1.equals(t2);\n      }\n    });\n  }\n  return match(pattern, quad) && (opt.returnMappings ? map : true);\n}\n\ninterface PatternOptions {\n  skipVarMapping?: boolean;\n  returnMappings?: boolean;\n}\n"]}