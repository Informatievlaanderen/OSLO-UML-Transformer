{"version":3,"file":"TermUtil.js","sourceRoot":"","sources":["TermUtil.ts"],"names":[],"mappings":";;;AACA,2CAA0C;AAE1C;;;;GAIG;AACU,QAAA,UAAU,GAAG,CAAE,WAAW,EAAE,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,CAAE,CAAC;AAEtG;;GAEG;AAEH;;;;GAIG;AACH,SAAgB,SAAS,CAAqB,KAAU;IACtD,MAAM,IAAI,GAA4B,EAAE,CAAC;IAEzC,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;QACzB,MAAM,UAAU,GAAG,IAAA,yBAAY,EAAW,IAAI,CAAC,CAAC;QAChD,OAAO,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAA;AACJ,CAAC;AAPD,8BAOC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,KAAiB,EACjB,QAAsF;IAEnH,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,IAAc,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC;AACtE,CAAC;AAJD,wCAIC;AAED;;;;GAIG;AACH,SAAgB,aAAa,CAAC,KAAiB;IAC7C,OAAyB,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AAC9D,CAAC;AAFD,sCAEC;AAED;;;;GAIG;AACH,SAAgB,aAAa,CAAC,KAAiB;IAC7C,OAAyB,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AAC9D,CAAC;AAFD,sCAEC;AAED;;;;GAIG;AACH,SAAgB,WAAW,CAAC,KAAiB;IAC3C,OAAuB,cAAc,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AAC1D,CAAC;AAFD,kCAEC;AAED;;;;GAIG;AACH,SAAgB,YAAY,CAAC,KAAiB;IAC5C,OAAwB,cAAc,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC5D,CAAC;AAFD,oCAEC;AAED;;;;GAIG;AACH,SAAgB,gBAAgB,CAAC,KAAiB;IAChD,OAA4B,cAAc,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;AACpE,CAAC;AAFD,4CAEC;AAED;;;;GAIG;AACH,SAAgB,QAAQ,CAAC,KAAiB;IACxC,OAAwB,cAAc,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACxD,CAAC;AAFD,4BAEC","sourcesContent":["import * as RDF from \"@rdfjs/types\";\nimport { termToString } from 'rdf-string';\n\n/**\n * All known term types.\n * @see RDF.Term\n * @type {[string , string , string , string , string, string]}\n */\nexport const TERM_TYPES = [ 'NamedNode', 'BlankNode', 'Literal', 'Variable', 'DefaultGraph', 'Quad' ];\n\n/*\n * Utility methods for handling RDFJS terms.\n */\n\n/**\n * Create an array of unique terms from the given array.\n * @param {T[]} terms An array of RDFJS terms.\n * @return {T[]} A new array of unique RDFJS terms.\n */\nexport function uniqTerms<T extends RDF.Term>(terms: T[]): T[] {\n  const hash: Record<string, boolean> = {};\n\n  return terms.filter(term => {\n    const termString = termToString<RDF.Term>(term);\n    return !(termString in hash) && (hash[termString] = true);\n  })\n}\n\n/**\n * Find all terms of the given type in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @param {\"NamedNode\" | \"BlankNode\" | \"Literal\" | \"Variable\" | \"DefaultGraph\" | \"Quad\"} termType A term type.\n * @return {Term[]} A new array with elements from the given array only containing elements of the given type.\n */\nexport function getTermsOfType(terms: RDF.Term[],\n                               termType: \"NamedNode\" | \"BlankNode\" | \"Literal\" | \"Variable\" | \"DefaultGraph\" | \"Quad\")\n: RDF.Term[] {\n  return terms.filter((term: RDF.Term) => term.termType === termType);\n}\n\n/**\n * Find all named nodes in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {NamedNode[]} A new array with elements from the given array only containing named nodes.\n */\nexport function getNamedNodes(terms: RDF.Term[]): RDF.NamedNode[] {\n  return <RDF.NamedNode[]> getTermsOfType(terms, 'NamedNode');\n}\n\n/**\n * Find all blank nodes in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {BlankNode[]} A new array with elements from the given array only containing blank nodes.\n */\nexport function getBlankNodes(terms: RDF.Term[]): RDF.BlankNode[] {\n  return <RDF.BlankNode[]> getTermsOfType(terms, 'BlankNode');\n}\n\n/**\n * Find all literals in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {Literal[]} A new array with elements from the given array only containing literals.\n */\nexport function getLiterals(terms: RDF.Term[]): RDF.Literal[] {\n  return <RDF.Literal[]> getTermsOfType(terms, 'Literal');\n}\n\n/**\n * Find all variables in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {Variable[]} A new array with elements from the given array only containing variables.\n */\nexport function getVariables(terms: RDF.Term[]): RDF.Variable[] {\n  return <RDF.Variable[]> getTermsOfType(terms, 'Variable');\n}\n\n/**\n * Find all default graphs in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {DefaultGraph[]} A new array with elements from the given array only containing default graphs.\n */\nexport function getDefaultGraphs(terms: RDF.Term[]): RDF.DefaultGraph[] {\n  return <RDF.DefaultGraph[]> getTermsOfType(terms, 'DefaultGraph');\n}\n\n/**\n * Find all quads in the given array.\n * @param {Term[]} terms An array of RDFJS terms.\n * @return {BaseQuad[]} A new array with elements from the given array only containing quads.\n */\nexport function getQuads(terms: RDF.Term[]): RDF.BaseQuad[] {\n  return <RDF.BaseQuad[]> getTermsOfType(terms, 'Quad');\n}\n"]}