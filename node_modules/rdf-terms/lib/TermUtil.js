"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuads = exports.getDefaultGraphs = exports.getVariables = exports.getLiterals = exports.getBlankNodes = exports.getNamedNodes = exports.getTermsOfType = exports.uniqTerms = exports.TERM_TYPES = void 0;
const rdf_string_1 = require("rdf-string");
/**
 * All known term types.
 * @see RDF.Term
 * @type {[string , string , string , string , string, string]}
 */
exports.TERM_TYPES = ['NamedNode', 'BlankNode', 'Literal', 'Variable', 'DefaultGraph', 'Quad'];
/*
 * Utility methods for handling RDFJS terms.
 */
/**
 * Create an array of unique terms from the given array.
 * @param {T[]} terms An array of RDFJS terms.
 * @return {T[]} A new array of unique RDFJS terms.
 */
function uniqTerms(terms) {
    const hash = {};
    return terms.filter(term => {
        const termString = (0, rdf_string_1.termToString)(term);
        return !(termString in hash) && (hash[termString] = true);
    });
}
exports.uniqTerms = uniqTerms;
/**
 * Find all terms of the given type in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @param {"NamedNode" | "BlankNode" | "Literal" | "Variable" | "DefaultGraph" | "Quad"} termType A term type.
 * @return {Term[]} A new array with elements from the given array only containing elements of the given type.
 */
function getTermsOfType(terms, termType) {
    return terms.filter((term) => term.termType === termType);
}
exports.getTermsOfType = getTermsOfType;
/**
 * Find all named nodes in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {NamedNode[]} A new array with elements from the given array only containing named nodes.
 */
function getNamedNodes(terms) {
    return getTermsOfType(terms, 'NamedNode');
}
exports.getNamedNodes = getNamedNodes;
/**
 * Find all blank nodes in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {BlankNode[]} A new array with elements from the given array only containing blank nodes.
 */
function getBlankNodes(terms) {
    return getTermsOfType(terms, 'BlankNode');
}
exports.getBlankNodes = getBlankNodes;
/**
 * Find all literals in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {Literal[]} A new array with elements from the given array only containing literals.
 */
function getLiterals(terms) {
    return getTermsOfType(terms, 'Literal');
}
exports.getLiterals = getLiterals;
/**
 * Find all variables in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {Variable[]} A new array with elements from the given array only containing variables.
 */
function getVariables(terms) {
    return getTermsOfType(terms, 'Variable');
}
exports.getVariables = getVariables;
/**
 * Find all default graphs in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {DefaultGraph[]} A new array with elements from the given array only containing default graphs.
 */
function getDefaultGraphs(terms) {
    return getTermsOfType(terms, 'DefaultGraph');
}
exports.getDefaultGraphs = getDefaultGraphs;
/**
 * Find all quads in the given array.
 * @param {Term[]} terms An array of RDFJS terms.
 * @return {BaseQuad[]} A new array with elements from the given array only containing quads.
 */
function getQuads(terms) {
    return getTermsOfType(terms, 'Quad');
}
exports.getQuads = getQuads;
//# sourceMappingURL=TermUtil.js.map