{"version":3,"file":"TermUtil.js","sourceRoot":"","sources":["TermUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\n\nconst FACTORY = new DataFactory();\n\n/**\n * Utility methods for converting between string-based RDF representations and RDFJS objects.\n *\n * RDF Terms are represented as follows:\n * * Blank nodes: '_:myBlankNode'\n * * Variables: '_myVariable'\n * * Literals: '\"myString\"', '\"myLanguageString\"@en-us', '\"<p>e</p>\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML>'\n * * URIs: '<http://example.org>'\n *\n * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)\n * as keys, and string-based RDF terms as values.\n */\n\n/**\n * Convert an RDFJS term to a string-based representation.\n * @param {RDF.Term} term An RDFJS term.\n * @return {string} A string-based term representation.\n */\nexport function termToString<T extends RDF.Term | undefined | null>(term: T): T extends RDF.Term ? string : undefined {\n  // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933\n  if (!term) {\n    return <any> undefined;\n  }\n  switch (term.termType) {\n    case 'NamedNode': return <any> (`<${escapeIRI(term.value)}>`);\n    case 'BlankNode': return <any> (`_:${term.value}`);\n    case 'Literal': {\n      const literalValue: RDF.Literal = term;\n      return <any> (`\"${escapeStringRDF(literalValue.value)}\"${\n        literalValue.datatype &&\n        literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' &&\n        literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' ?\n          `^^<${literalValue.datatype.value}>` :\n          ''\n      }${literalValue.language ? `@${literalValue.language}` : ''}`);\n    }\n    case 'Quad': return <any> (`<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ` ${termToString(term.graph)}`}>>`);\n    case 'Variable': return <any> (`?${term.value}`);\n    case 'DefaultGraph': return <any> term.value;\n  }\n}\n\n/**\n * Get the string value of a literal.\n * @param {string} literalValue An RDF literal enclosed by '\"'.\n * @return {string} The literal value inside the '\"'.\n */\nexport function getLiteralValue(literalValue: string): string {\n  const match = /^\"([^]*)\"((\\^\\^.*)|(@.*))?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  return match[1].replace(/\\\\\"/ug, '\"');\n}\n\n/**\n * Get the datatype of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The datatype of the literal.\n */\nexport function getLiteralType(literalValue: string): string {\n  const match = /^\"[^]*\"(?:\\^\\^<([^\"]+)>|(@)[^@\"]+)?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  return match[1] || (match[2] ?\n    'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' :\n    'http://www.w3.org/2001/XMLSchema#string');\n}\n\n/**\n * Get the language of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The language of the literal.\n */\nexport function getLiteralLanguage(literalValue: string): string {\n  const match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  return match[1] ? match[1].toLowerCase() : '';\n}\n\n/**\n * Transform a string-based RDF term to an RDFJS term.\n * @param {string} value A string-based RDF-term.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {RDF.Term} An RDF-JS term.\n */\nexport function stringToTerm(value: string | undefined, dataFactory?: RDF.DataFactory<RDF.BaseQuad>): RDF.Term {\n  dataFactory = dataFactory || FACTORY;\n  if (!value || (value.length === 0)) {\n    return dataFactory.defaultGraph();\n  }\n  switch (value[0]) {\n    case '_': return dataFactory.blankNode(value.slice(2));\n    case '?':\n      if (!dataFactory.variable) {\n        throw new Error(`Missing 'variable()' method on the given DataFactory`);\n      }\n      return dataFactory.variable(value.slice(1));\n    case '\"': {\n      const language: string = getLiteralLanguage(value);\n      const type: RDF.NamedNode = dataFactory.namedNode(getLiteralType(value));\n      return dataFactory.literal(getLiteralValue(value), language || type);\n    }\n    case '<':\n    default:\n      if (value.startsWith('<<') && value.endsWith('>>')) {\n        // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>\n        const terms = value.slice(2, -2);\n        const stringTerms: string[] = [];\n        let ignoreTags = 0;\n        let lastIndex = 0;\n        for (let i = 0; i < terms.length; i++) {\n          const char = terms[i];\n          if (char === '<') {\n            ignoreTags++;\n          }\n          if (char === '>') {\n            if (ignoreTags === 0) {\n              throw new Error(`Found closing tag without opening tag in ${value}`);\n            } else {\n              ignoreTags--;\n            }\n          }\n          if (char === ' ' && ignoreTags === 0) {\n            stringTerms.push(terms.slice(lastIndex, i));\n            lastIndex = i + 1;\n          }\n        }\n        if (ignoreTags !== 0) {\n          throw new Error(`Found opening tag without closing tag in ${value}`);\n        }\n        stringTerms.push(terms.slice(lastIndex, terms.length));\n\n        // We require 3 or 4 components\n        if (stringTerms.length !== 3 && stringTerms.length !== 4) {\n          throw new Error(`Nested quad syntax error ${value}`);\n        }\n\n        return dataFactory.quad(\n          stringToTerm(stringTerms[0]),\n          stringToTerm(stringTerms[1]),\n          stringToTerm(stringTerms[2]),\n          stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined,\n        );\n      }\n      if (!value.startsWith('<') || !value.endsWith('>')) {\n        throw new Error(`Detected invalid iri for named node (must be wrapped in <>): ${value}`);\n      }\n      return dataFactory.namedNode(value.slice(1, -1));\n  }\n}\n\n/**\n * Convert an RDFJS quad to a string-based quad representation.\n * @param {Quad} q An RDFJS quad.\n * @return {IStringQuad} A hash with string-based quad terms.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function quadToStringQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q): IStringQuad {\n  return {\n    subject: termToString(quad.subject),\n    predicate: termToString(quad.predicate),\n    object: termToString(quad.object),\n    graph: termToString(quad.graph),\n  };\n}\n\n/**\n * Convert a string-based quad representation to an RDFJS quad.\n * @param {IStringQuad} stringQuad A hash with string-based quad terms.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {Q} An RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function stringQuadToQuad<Q extends RDF.BaseQuad = RDF.Quad>(\n  stringQuad: IStringQuad,\n  dataFactory?: RDF.DataFactory<Q>,\n): Q {\n  dataFactory = dataFactory! || FACTORY;\n  return dataFactory.quad(\n    stringToTerm(stringQuad.subject, dataFactory),\n    stringToTerm(stringQuad.predicate, dataFactory),\n    stringToTerm(stringQuad.object, dataFactory),\n    stringToTerm(stringQuad.graph, dataFactory),\n  );\n}\n\nfunction escapeIRI(iriValue: string): string {\n  return iriValue.replace(escapePattern, replaceEscapedCharacter);\n}\n\nfunction escapeStringRDF(stringValue: string): string {\n  if (escapePattern.test(stringValue)) {\n    stringValue = stringValue.replace(escapePattern, replaceEscapedCharacter);\n  }\n  return stringValue;\n}\n\n// Characters in literals and IRIs that require escaping\n// Also containing potential surrogate pairs\n/* eslint-disable require-unicode-regexp */ /* eslint-disable unicorn/better-regex */\nconst escapePattern = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n/* eslint-enable require-unicode-regexp */ /* eslint-enable unicorn/better-regex */\nconst escapes = new Map([\n  [ '\\\\', '\\\\\\\\' ],\n  [ '\"', '\\\\\"' ],\n  [ '\\t', '\\\\t' ],\n  [ '\\n', '\\\\n' ],\n  [ '\\r', '\\\\r' ],\n  [ '\\b', '\\\\b' ],\n  [ '\\f', '\\\\f' ],\n]);\n\nfunction replaceEscapedCharacter(character: string): string {\n  // Try simplest case first, get replacement for character\n  const result = escapes.get(character);\n  if (!result) {\n    if (character.length === 1) {\n      // Single unicode charachters, i.e. not a surrogate pair\n      const code = character.charCodeAt(0).toString(16);\n      return `${'\\\\u0000'.slice(0, -code.length)}${code}`;\n    }\n    // Surrogate pairs\n    const code = ((character.charCodeAt(0) - 0xD8_00) * 0x4_00 + character.charCodeAt(1) + 0x24_00).toString(16);\n    return `${'\\\\U00000000'.slice(0, -code.length)}${code}`;\n  }\n  return result;\n}\n\nexport interface IStringQuad {\n  subject: string;\n  predicate: string;\n  object: string;\n  graph?: string;\n}\n"]}