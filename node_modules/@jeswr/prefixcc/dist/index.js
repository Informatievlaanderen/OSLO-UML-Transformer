"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookupAllPrefixes = exports.prefixToUri = exports.uriToPrefix = void 0;
const fragment_1 = require("./fragment");
const lookup_1 = require("./lookup");
function uriToPrefix(uri, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        // Collect the prefix
        try {
            result = yield (0, lookup_1.lookupPrefix)(uri, options);
        }
        catch (_a) {
            if (options === null || options === void 0 ? void 0 : options.mintOnUnknown) {
                // Keep prefixes at most 4 characters long when minting a new one
                result = (0, fragment_1.fragment)(uri).slice(0, 4);
            }
        }
        // If there is a bank of existing prefixes make sure to make a unique one
        // by postfixing a number
        if (typeof result !== 'undefined'
            && typeof (options === null || options === void 0 ? void 0 : options.existingPrefixes) === 'object'
            && result in options.existingPrefixes) {
            let i = 0;
            while (`${result}${i}` in options.existingPrefixes) {
                i += 1;
            }
            result = `${result}${i}`;
        }
        return result;
    });
}
exports.uriToPrefix = uriToPrefix;
/**
 * Lookup the namespace commonly associated with a given prefix
 * @param prefix The prefix to lookup the namespace for
 * @param options You can optionally pass a custom fetch function
 */
function prefixToUri(prefix, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // The await needs to be here so that we can return undefined on rejection
            return yield (0, lookup_1.lookupUri)(prefix, options);
        }
        catch (_a) {
            return undefined;
        }
    });
}
exports.prefixToUri = prefixToUri;
var lookup_2 = require("./lookup");
Object.defineProperty(exports, "lookupAllPrefixes", { enumerable: true, get: function () { return lookup_2.lookupAllPrefixes; } });
