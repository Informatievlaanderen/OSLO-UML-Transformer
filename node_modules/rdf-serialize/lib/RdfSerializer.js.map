{"version":3,"file":"RdfSerializer.js","sourceRoot":"","sources":["RdfSerializer.ts"],"names":[],"mappings":"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","sourcesContent":["import { ActionContext, Actor } from \"@comunica/core\";\nimport * as RDF from \"@rdfjs/types\";\nimport { PassThrough } from \"readable-stream\";\nimport {\n  MediatorRdfSerializeHandle,\n  MediatorRdfSerializeMediaTypes\n} from '@comunica/bus-rdf-serialize';\n\n/**\n * An RdfSerializer can serialize to any RDF serialization, based on a given content type.\n */\nexport class RdfSerializer<Q extends RDF.BaseQuad = RDF.Quad>  {\n\n  // tslint:disable:object-literal-sort-keys\n  public static readonly CONTENT_MAPPINGS: { [id: string]: string } = {\n    ttl      : \"text/turtle\",\n    turtle   : \"text/turtle\",\n    nt       : \"application/n-triples\",\n    ntriples : \"application/n-triples\",\n    nq       : \"application/n-quads\",\n    nquads   : \"application/n-quads\",\n    n3       : \"text/n3\",\n    shc      : \"text/shaclc\",\n    shaclc   : \"text/shaclc\",\n    shce     : \"text/shaclc-ext\",\n    shaclce  : \"text/shaclc-ext\",\n    trig     : \"application/trig\",\n    jsonld   : \"application/ld+json\",\n    json     : \"application/ld+json\",\n  };\n\n  public readonly mediatorRdfSerializeMediatypes: MediatorRdfSerializeMediaTypes;\n  public readonly mediatorRdfSerializeHandle: MediatorRdfSerializeHandle;\n\n  constructor(args: IRdfSerializerArgs) {\n    this.mediatorRdfSerializeMediatypes = args.mediatorRdfSerializeMediatypes;\n    this.mediatorRdfSerializeHandle = args.mediatorRdfSerializeHandle;\n  }\n\n  /**\n   * Get an array of all available content types for this serializer.\n   * @return {Promise<string[]>} A promise resolving to a string array of all content types.\n   */\n  public async getContentTypes(): Promise<string[]> {\n    return Object.keys(await this.getContentTypesPrioritized());\n  }\n\n  /**\n   * Get a hash of all available content types for this serializer, mapped to a numerical priority.\n   * @return {Promise<{[p: string]: number}>} A promise resolving to a hash mapping content type to a priority number.\n   */\n  public async getContentTypesPrioritized(): Promise<{[contentType: string]: number}> {\n    return (await this.mediatorRdfSerializeMediatypes.mediate(\n      { context: new ActionContext(), mediaTypes: true })).mediaTypes;\n  }\n\n  /**\n   * Serialize the given stream.\n   * @param {NodeJS.ReadableStream} stream A string stream.\n   * @param {ISerializeOptions} options Serialization options.\n   * @return {Stream} An RDFJS quad stream.\n   */\n  public serialize(stream: RDF.Stream, options: SerializeOptions): NodeJS.ReadableStream {\n    let contentType: string;\n    if ('contentType' in options && options.contentType) {\n      contentType = options.contentType;\n    } else if ('path' in options && options.path) {\n      contentType = this.getContentTypeFromExtension(options.path);\n      if (!contentType) {\n        throw new Error(`No valid extension could be detected from the given 'path' option: '${options.path}'`);\n      }\n    } else {\n      throw new Error(`Missing 'contentType' or 'path' option while serializing.`);\n    }\n\n    // Create a new readable\n    const readable = new PassThrough({ objectMode: true });\n\n    // Delegate serializing to the mediator\n    const context = new ActionContext(options);\n    this.mediatorRdfSerializeHandle.mediate({\n      context,\n      handle: { quadStream: stream, context },\n      handleMediaType: contentType,\n    })\n      .then((output) => {\n        const data: NodeJS.ReadableStream = output.handle.data;\n        data.on('error', (e) => readable.emit('error', e));\n        data.pipe(readable);\n      })\n      .catch((e) => readable.emit('error', e));\n\n    return readable;\n  }\n\n  /**\n   * Get the content type based on the extension of the given path,\n   * which can be an URL or file path.\n   * @param {string} path A path.\n   * @return {string} A content type or the empty string.\n   */\n  public getContentTypeFromExtension(path: string): string {\n    const dotIndex = path.lastIndexOf('.');\n    if (dotIndex >= 0) {\n      const ext = path.substr(dotIndex);\n      // ignore dot\n      return RdfSerializer.CONTENT_MAPPINGS[ext.substring(1)] || '';\n    }\n    return '';\n  }\n\n}\n\nexport interface IRdfSerializerArgs {\n  mediatorRdfSerializeMediatypes: MediatorRdfSerializeMediaTypes;\n  mediatorRdfSerializeHandle: MediatorRdfSerializeHandle;\n  actors: Actor<any, any, any>[];\n}\n\nexport type SerializeOptions = {\n  /**\n   * The content type of the needed serialization.\n   */\n  contentType: string;\n} | {\n  /**\n   * The file name or URL that will be serialized to.\n   */\n  path: string;\n};\n"]}