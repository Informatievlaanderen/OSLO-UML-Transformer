{"version":3,"file":"sparqlAlgebra.js","sourceRoot":"","sources":["sparqlAlgebra.ts"],"names":[],"mappings":"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","sourcesContent":["import equal = require('fast-deep-equal/es6');\nimport { Quad } from '@rdfjs/types';\nimport * as RDF from '@rdfjs/types'\nimport { termToString } from 'rdf-string';\nimport {\n    AggregateExpression,\n    BgpPattern,\n    ClearDropOperation,\n    CopyMoveAddOperation,\n    CreateOperation,\n    Expression,\n    FilterPattern,\n    GraphQuads,\n    GroupPattern,\n    InsertDeleteOperation,\n    IriTerm,\n    LoadOperation,\n    Ordering,\n    Pattern,\n    PropertyPath,\n    Query,\n    SelectQuery,\n    SparqlQuery,\n    Triple,\n    Update,\n    UpdateOperation, ValuesPattern,\n    Variable,\n    VariableExpression,\n    Wildcard\n} from 'sparqljs';\nimport * as Algebra from './algebra';\nimport Factory from './factory';\nimport Util from './util';\n\nconst Parser = require('sparqljs').Parser;\nconst types = Algebra.types;\n\nlet variables = new Set<string>();\nlet varCount = 0;\nlet useQuads = false;\nlet factory: Factory;\n\n/**\n * Translates the given SPARQL query to SPARQL Algebra.\n * @param sparql - Either a SPARQL string or an object generated by sparql.js\n * @param options - Optional options object. Current options:\n *                    * dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.\n *                    * quads: Boolean indicating whether triples should be converted to Quads (consumes GRAPH statements). Default false.\n *                    * prefixes: Pre-defined prefixes for the given query. Default empty.\n *                    * baseIRI: Base IRI that should be used for the query. Default undefined (throws error if required).\n * @returns {Operation}\n */\nexport default function translate(sparql: SparqlQuery | string, options?:\n    {\n        dataFactory?: RDF.DataFactory,\n        quads?: boolean,\n        prefixes?: {[prefix: string]: string},\n        baseIRI?: string,\n        blankToVariable?: boolean\n        sparqlStar?: boolean;\n    }) : Algebra.Operation\n{\n    options = options || {};\n    factory = new Factory(options.dataFactory);\n\n    let query: SparqlQuery;\n    if (isString(sparql))\n    {\n        let parser = new Parser(options);\n        // resets the identifier counter used for blank nodes\n        // provides nicer and more consistent output if there are multiple calls\n        parser._resetBlanks();\n        query = parser.parse(sparql);\n    } else {\n        query = sparql;\n    }\n\n    return translateQuery(query, options.quads, options.blankToVariable);\n}\n\nfunction translateQuery(sparql: SparqlQuery, quads?: boolean, blankToVariable?: boolean) : Algebra.Operation\n{\n    // this set is filled in during the inScopeVariables call\n    variables = new Set();\n    varCount = 0;\n    useQuads = Boolean(quads);\n\n    // Assume this is an empty query\n    if (!sparql.type)\n        return factory.createNop();\n\n    if (sparql.type !== 'query' && sparql.type !== 'update')\n        throw new Error('Translate only works on complete query or update objects.');\n\n    let res: Algebra.Operation;\n\n    // find ALL variables here to fill `variables` array\n    findAllVariables(sparql);\n\n    if (sparql.type === 'query') {\n        // group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE\n        const group: GroupPattern = { type: 'group', patterns: sparql.where || [] };\n        res = translateGraphPattern(group);\n        res = translateAggregates(sparql, res);\n    }\n    else if(sparql.type === 'update') {\n        res = translateUpdate(sparql);\n    }\n    if (blankToVariable) {\n        res = translateBlankNodesToVariables(res!);\n    }\n\n    return res!;\n}\n\nfunction isString(str: any): str is string\n{\n    return typeof str === 'string';\n}\n\nfunction isTerm(term: any) : term is RDF.Term\n{\n    return Boolean(term?.termType);\n}\n\n// This is not completely correct but this way we also catch SPARQL.js triples\nfunction isTriple(triple: any) : triple is RDF.Quad {\n    return triple.subject && triple.predicate && triple.object;\n}\n\nfunction isVariable(term: any) : term is RDF.Variable\n{\n    return term?.termType === 'Variable';\n}\n\n// Will be used to make sure new variables don't overlap\nfunction findAllVariables(thingy: any): void\n{\n    if (isTerm(thingy))\n    {\n        if (isVariable(thingy))\n        {\n            // Variables don't store the `?`\n            variables.add(`?${thingy.value}`);\n        }\n    }\n    else if (Array.isArray(thingy))\n    {\n        for (const entry of thingy)\n            findAllVariables(entry);\n    }\n    else if (thingy && typeof thingy === 'object')\n    {\n        for (let key of Object.keys(thingy))\n        {\n            // Some variables are hidden in keys (specifically for VALUES)\n            if (key.startsWith('?')) {\n                variables.add(key);\n            } else if (key.startsWith('$')) {\n                variables.add(`?${key.slice(1)}`);\n            }\n\n            findAllVariables(thingy[key]);\n        }\n    }\n}\n\n// 18.2.1\nfunction inScopeVariables(thingy: SparqlQuery | Pattern | PropertyPath | RDF.Term) : {[key: string]: RDF.Variable}\n{\n    let inScope: {[key: string]: RDF.Variable} = {};\n\n    if (isTriple(thingy))\n    {\n        // Note that this could both be an actual Quad or a SPARQL.js triple (without graph)\n        const result = [\n            inScopeVariables(thingy.subject),\n            inScopeVariables(thingy.predicate),\n            inScopeVariables(thingy.object),\n            thingy.graph ? inScopeVariables(thingy.graph) : {}\n        ];\n        Object.assign(inScope, ...result);\n    }\n    else if (isTerm(thingy))\n    {\n        if (isVariable(thingy))\n            inScope[thingy.value] = thingy;\n    }\n    else if (thingy.type === 'bgp')\n    {\n        // Slightly cheating but this is a subset of what we support so is fine\n        const quads = thingy.triples as Quad[];\n        Object.assign(inScope, ...quads.map(inScopeVariables));\n    }\n    else if (thingy.type === 'path') {\n      // A path predicate should not have variables but just iterating so we could theoretically support this\n      Object.assign(inScope, ...thingy.items.map(inScopeVariables));\n    }\n    else if (thingy.type === 'group' || thingy.type === 'union' || thingy.type === 'optional') {\n      Object.assign(inScope, ...thingy.patterns.map(inScopeVariables));\n    }\n    else if (thingy.type === 'service' || thingy.type === 'graph') {\n      Object.assign(inScope, inScopeVariables(thingy.name));\n      Object.assign(inScope, ...thingy.patterns.map(inScopeVariables));\n    }\n    else if (thingy.type === 'bind') {\n        Object.assign(inScope, inScopeVariables(thingy.variable));\n    }\n    else if (thingy.type === 'values')\n    {\n        if (thingy.values.length > 0)\n        {\n            const vars = Object.keys(thingy.values[0]).map(v => factory.createTerm(v));\n            Object.assign(inScope, ...vars.map(inScopeVariables));\n        }\n    }\n    else if (thingy.type === 'query')\n    {\n        if (thingy.queryType === 'SELECT' || thingy.queryType === 'DESCRIBE')\n        {\n            if (thingy.where && thingy.variables.some(Util.isWildcard))\n                Object.assign(inScope, ...thingy.where.map(inScopeVariables));\n            for (const v of thingy.variables)\n            {\n                if (isVariable(v))\n                    Object.assign(inScope, inScopeVariables(v));\n                else if ((v as VariableExpression).variable)\n                    Object.assign(inScope, inScopeVariables((v as VariableExpression).variable));\n            }\n            if (thingy.queryType === 'SELECT')\n            {\n                if (thingy.group)\n                {\n                    // Grouping can be a VariableExpression, typings are wrong\n                    for (const g of thingy.group)\n                    {\n                        if ((g as VariableExpression).variable)\n                            Object.assign(inScope, inScopeVariables((g as VariableExpression).variable));\n                    }\n                }\n                if (thingy.values)\n                {\n                    const values: ValuesPattern = { type: 'values', values: thingy.values };\n                    Object.assign(inScope, inScopeVariables(values));\n                }\n            }\n        }\n    }\n\n    return inScope;\n}\n\nfunction translateGraphPattern(thingy: Pattern) : Algebra.Operation\n{\n    // 18.2.2.1\n    // already done by sparql parser\n\n    // 18.2.2.3\n    // 18.2.2.4\n    // 18.2.2.5\n    // In Sparql.js, a group with a single BGP in it is a single object.\n    if (thingy.type === 'bgp')\n    {\n        return translateBgp(thingy);\n    }\n\n    // 18.2.2.6 - GroupOrUnionGraphPattern\n    if (thingy.type === 'union')\n        return factory.createUnion(thingy.patterns.map((p: any) =>\n        {\n            // sparqljs doesn't always indicate the children are groups\n            if (p.type !== 'group')\n                p = { type: 'group', patterns: [p] };\n            return translateGraphPattern(p);\n        }));\n\n    // 18.2.2.6 - GraphGraphPattern\n    if (thingy.type === 'graph')\n    {\n        // Sparql.js combines the group graph pattern and the graph itself in the same object.\n        // We split here so the group graph pattern can be interpreted correctly.\n        const group: GroupPattern = { type: 'group', patterns: thingy.patterns };\n        let result = translateGraphPattern(group);\n\n        // Output depends on if we use quads or not\n        if (useQuads)\n            result = recurseGraph(result, thingy.name);\n        else\n            result = factory.createGraph(result, thingy.name);\n\n        return result;\n    }\n\n    // 18.2.2.6 - InlineData\n    if (thingy.type === 'values')\n        return translateInlineData(thingy);\n\n    // 18.2.2.6 - SubSelect\n    if (thingy.type === 'query')\n        return translateQuery(thingy, useQuads, false);\n\n    if (thingy.type === 'group')\n    {\n        // 18.2.2.2\n        let filters: FilterPattern[] = [];\n        let nonfilters: Pattern[] = [];\n        for (let pattern of thingy.patterns)\n            (pattern.type === 'filter' ? filters : nonfilters).push(pattern);\n\n        // 18.2.2.6 - GroupGraphPattern\n        let result = nonfilters.reduce(accumulateGroupGraphPattern, factory.createBgp([]));\n\n        // 18.2.2.7\n        let expressions: Algebra.Expression[] = filters.map(filter => translateExpression(filter.expression));\n        if (expressions.length > 0)\n            result = factory.createFilter(result, expressions.reduce((acc, exp) => factory.createOperatorExpression('&&', [acc, exp])));\n\n        return result;\n    }\n\n    throw new Error(`Unexpected type: ${thingy.type}`);\n}\n\nfunction translateExpression(exp: Expression | RDF.Term | Wildcard) : Algebra.Expression\n{\n    if (Util.isSimpleTerm(exp))\n        return factory.createTermExpression(exp);\n    if (Util.isQuad(exp)) {\n        if (Util.hasQuadVariables(exp))\n            return factory.createOperatorExpression('triple', [\n              translateExpression(exp.subject),\n              translateExpression(exp.predicate),\n              translateExpression(exp.object),\n            ]);\n        else\n            return factory.createTermExpression(exp);\n    }\n    if (Util.isWildcard(exp))\n        return factory.createWildcardExpression();\n    if ('aggregation' in exp)\n        return factory.createAggregateExpression(exp.aggregation, translateExpression(exp.expression), Boolean(exp.distinct), exp.separator);\n    if ('function' in exp)\n        // Outdated typings\n        return factory.createNamedExpression(<RDF.NamedNode><unknown> exp.function, exp.args.map(translateExpression));\n    if ('operator' in exp)\n    {\n        if (exp.operator === 'exists' || exp.operator === 'notexists')\n            return factory.createExistenceExpression(exp.operator === 'notexists', translateGraphPattern(exp.args[0] as Pattern));\n        if (exp.operator === 'in' || exp.operator === 'notin')\n            exp.args = [exp.args[0]].concat(exp.args[1]); // sparql.js uses 2 arguments with the second one being a list\n        return factory.createOperatorExpression(exp.operator, exp.args.map(translateExpression));\n    }\n    throw new Error(`Unknown expression: ${JSON.stringify(exp)}`);\n}\n\nfunction translateBgp(thingy: BgpPattern) : Algebra.Operation\n{\n    let patterns: Algebra.Pattern[] = [];\n    let joins: Algebra.Operation[] = [];\n    for (let t of thingy.triples)\n    {\n        if ('pathType' in t.predicate)\n        {\n            // translatePath returns a mix of Quads and Paths\n            let path = translatePath(t as Triple & { predicate: PropertyPath });\n            for (let p of path)\n            {\n                if (p.type === types.PATH)\n                {\n                    if (patterns.length > 0)\n                        joins.push(factory.createBgp(patterns));\n                    patterns = [];\n                    joins.push(p);\n                }\n                else\n                    patterns.push(p);\n            }\n        }\n        else\n            patterns.push(translateQuad(t));\n    }\n    if (patterns.length > 0)\n        joins.push(factory.createBgp(patterns));\n    if (joins.length === 1)\n        return joins[0];\n    return factory.createJoin(joins);\n}\n\nfunction translatePath(triple: Triple & { predicate: PropertyPath }) : (Algebra.Path | Algebra.Pattern)[]\n{\n    let sub = triple.subject;\n    let pred = translatePathPredicate(triple.predicate);\n    let obj = triple.object;\n\n    return simplifyPath(sub, pred, obj);\n}\n\nfunction translatePathPredicate(predicate: IriTerm | PropertyPath) : Algebra.PropertyPathSymbol\n{\n    if (Util.isSimpleTerm(predicate))\n    {\n        if (predicate.termType === 'NamedNode')\n            return factory.createLink(predicate);\n        else\n            throw new Error(`Path predicate should be a NamedNode, got ${JSON.stringify(predicate)}`);\n    }\n\n    if (predicate.pathType === '^')\n        return factory.createInv(translatePathPredicate(predicate.items[0]));\n\n    if (predicate.pathType === '!')\n    {\n        // negation is either over a single predicate or a list of disjuncted properties\n        let normals: RDF.NamedNode[] = [];\n        let inverted: RDF.NamedNode[] = [];\n        let items: (IriTerm | PropertyPath)[];\n        if ('pathType' in predicate.items[0] && predicate.items[0].pathType === '|')\n            items = predicate.items[0].items; // the | element\n        else\n            items = predicate.items;\n\n        for (let item of items)\n        {\n            if (Util.isSimpleTerm(item))\n                normals.push(item);\n            else if (item.pathType === '^')\n                inverted.push(item.items[0] as RDF.NamedNode);\n            else\n                throw new Error(`Unexpected item: ${JSON.stringify(item)}`);\n        }\n\n        // NPS elements do not have the LINK function\n        let normalElement = factory.createNps(normals);\n        let invertedElement = factory.createInv(factory.createNps(inverted));\n\n        if (inverted.length === 0)\n            return normalElement;\n        if (normals.length === 0)\n            return invertedElement;\n        return factory.createAlt([ normalElement, invertedElement, ]);\n    }\n\n    if (predicate.pathType === '/')\n        return factory.createSeq(predicate.items.map(translatePathPredicate));\n    if (predicate.pathType === '|')\n        return factory.createAlt(predicate.items.map(translatePathPredicate));\n    if (predicate.pathType === '*')\n        return factory.createZeroOrMorePath(translatePathPredicate(predicate.items[0]));\n    if (predicate.pathType === '+')\n        return factory.createOneOrMorePath(translatePathPredicate(predicate.items[0]));\n    if (predicate.pathType === '?')\n        return factory.createZeroOrOnePath(translatePathPredicate(predicate.items[0]));\n\n    throw new Error(`Unable to translate path expression ${JSON.stringify(predicate)}`);\n}\n\nfunction simplifyPath(subject: RDF.Quad_Subject, predicate: Algebra.PropertyPathSymbol, object: RDF.Quad_Object) : (Algebra.Pattern | Algebra.Path)[]\n{\n    if (predicate.type === types.LINK)\n        return [factory.createPattern(subject, predicate.iri, object)];\n\n    if (predicate.type === types.INV)\n        return simplifyPath(<RDF.Quad_Subject> object, predicate.path, subject);\n\n    if (predicate.type === types.SEQ)\n    {\n        let joiner: RDF.Quad_Subject | RDF.Variable = subject;\n        return Util.flatten(predicate.input.map((subOp, i) => {\n            const nextJoiner = i === predicate.input.length - 1 ? object : generateFreshVar();\n            const simplifiedPath = simplifyPath(joiner, subOp, nextJoiner);\n            if (nextJoiner.termType === 'Variable') {\n                joiner = nextJoiner;\n            }\n            return simplifiedPath;\n        }));\n    }\n\n    return [ factory.createPath(subject, predicate, object) ];\n}\n\nfunction generateFreshVar() : RDF.Variable\n{\n    let v: string = `?var${varCount++}`;\n    if (variables.has(v))\n        return generateFreshVar();\n    variables.add(v);\n    return <RDF.Variable>factory.createTerm(v);\n}\n\nfunction translateQuad(quad: Triple) : Algebra.Pattern\n{\n    if ('pathType' in quad.predicate) {\n        throw new Error('Trying to translate property path to quad.');\n    }\n    // Graphs are needed here\n    // TODO: investigate if typings are wrong or if we internally add graphs to these\n    return factory.createPattern(quad.subject, quad.predicate, quad.object, (quad as any).graph);\n}\n\nlet typeVals = Object.values(types);\nfunction recurseGraph(thingy: Algebra.Operation, graph: RDF.Term, replacement?: RDF.Variable) : Algebra.Operation\n{\n    if (thingy.type === types.GRAPH)\n    {\n        if (replacement) {\n            // At this point we would lose track of the replacement which would result in incorrect results\n            // This would indicate the library is not being used as intended though\n            throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');\n        }\n        // In case there were nested GRAPH statements that were not recursed yet for some reason\n        thingy = recurseGraph(thingy.input, thingy.name);\n    }\n    else if (thingy.type === types.SERVICE)\n    {\n        // Service blocks are not affected by enclosing GRAPH statements, so nothing is modified in this block.\n        // See https://github.com/joachimvh/SPARQLAlgebra.js/pull/104#issuecomment-1838016303\n    }\n    else if (thingy.type === types.BGP)\n        thingy.patterns = thingy.patterns.map(quad =>\n        {\n            if (replacement)\n            {\n                if (quad.subject.equals(graph)) quad.subject = replacement;\n                if (quad.predicate.equals(graph)) quad.predicate = replacement;\n                if (quad.object.equals(graph)) quad.object = replacement;\n            }\n            if (quad.graph.termType === 'DefaultGraph')\n                quad.graph = graph;\n            return quad;\n        });\n    else if (thingy.type === types.PATH)\n    {\n        if (replacement)\n        {\n            if (thingy.subject.equals(graph)) thingy.subject = replacement;\n            if (thingy.object.equals(graph))  thingy.object = replacement;\n        }\n        if (thingy.graph.termType === 'DefaultGraph')\n            thingy.graph = graph;\n    }\n    // need to replace variables in subqueries should the graph also be a variable of the same name\n    // unless the subquery projects that variable\n    else if (thingy.type === types.PROJECT && !replacement)\n    {\n        if (!thingy.variables.some(v => v.equals(graph)))\n            replacement = generateFreshVar();\n        thingy.input = recurseGraph(thingy.input, graph, replacement);\n    }\n    // this can happen if the query extends an expression to the name of the graph\n    // since the extend happens here there should be no further occurrences of this name\n    // if there are it's the same situation as above\n    else if (thingy.type === types.EXTEND && !replacement)\n    {\n        if (thingy.variable.equals(graph))\n            replacement = generateFreshVar();\n        thingy.input = recurseGraph(thingy.input, graph, replacement);\n    }\n    else\n    {\n        for (let key of Object.keys(thingy))\n        {\n            if (Array.isArray(thingy[key]))\n                thingy[key] = thingy[key].map((x: any) => recurseGraph(x, graph, replacement));\n            else if (typeVals.indexOf(thingy[key].type) >= 0) // can't do instanceof on an interface\n                thingy[key] = recurseGraph(thingy[key], graph, replacement);\n            else if (replacement && isVariable(thingy[key]) && thingy[key].equals(graph))\n                thingy[key] = replacement;\n        }\n    }\n\n    return thingy;\n}\n\nfunction accumulateGroupGraphPattern(G: Algebra.Operation, E: Pattern) : Algebra.Operation\n{\n    if (E.type === 'optional')\n    {\n        // optional input needs to be interpreted as a group\n        const A = translateGraphPattern({ type: 'group', patterns: E.patterns });\n        if (A.type === types.FILTER)\n        {\n            G = factory.createLeftJoin(G, A.input, A.expression);\n        }\n        else\n            G = factory.createLeftJoin(G, A);\n    }\n    else if (E.type === 'minus')\n    {\n        // minus input needs to be interpreted as a group\n        const A = translateGraphPattern({ type: 'group', patterns: E.patterns });\n        G = factory.createMinus(G, A);\n    }\n    else if (E.type === 'bind')\n        G = factory.createExtend(G, <RDF.Variable>E.variable, translateExpression(E.expression));\n    else if (E.type === 'service')\n    {\n        // transform to group so childnodes get parsed correctly\n        const group: GroupPattern = { type: 'group', patterns: E.patterns };\n        const A = factory.createService(translateGraphPattern(group), E.name, E.silent);\n        G = simplifiedJoin(G, A);\n    }\n    else\n    {\n        const A = translateGraphPattern(E);\n        G = simplifiedJoin(G, A);\n    }\n\n    return G;\n}\n\nfunction simplifiedJoin(G: Algebra.Operation, A: Algebra.Operation): Algebra.Operation\n{\n    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.\n    if (G.type  === types.BGP && A.type === types.BGP)\n        G = factory.createBgp([ ...G.patterns, ...A.patterns ]);\n    // 18.2.2.8 (simplification)\n    else if (G.type === types.BGP && G.patterns.length === 0)\n        G = A;\n    else if (A.type === types.BGP && A.patterns.length === 0)\n    {} // do nothing\n    else\n        G = factory.createJoin([ G, A ]);\n    return G;\n}\n\nfunction translateInlineData(values: any) : Algebra.Values\n{\n    let variables = <RDF.Variable[]>(values.values.length === 0 ? [] : Object.keys(values.values[0])).map(factory.createTerm.bind(factory));\n    let bindings = values.values.map((binding: any) =>\n    {\n        let keys = Object.keys(binding);\n        keys = keys.filter(k => binding[k] !== undefined);\n        let map: any = {};\n        for (let key of keys)\n            map[key] = binding[key];\n        return map;\n    });\n    return factory.createValues(variables, bindings);\n}\n\n// --------------------------------------- AGGREGATES\nfunction translateAggregates(query: Query, res: Algebra.Operation) : Algebra.Operation\n{\n    // Typings for ConstructQuery are wrong and missing several fields so we will cast quite often to SelectQuery to have partial typings\n    const select = query as SelectQuery;\n\n    // 18.2.4.1\n    const E: VariableExpression[] = [];\n\n    const A: NodeJS.Dict<AggregateExpression> = {};\n    select.variables = select.variables && select.variables.map(val => mapAggregate(val, A));\n    select.having = select.having && select.having.map(val => mapAggregate(val, A));\n    select.order = select.order && select.order.map(val => mapAggregate(val, A));\n\n    // if there are any aggregates or if we have a groupBy (both result in a GROUP)\n    if (select.group || Object.keys(A).length > 0)\n    {\n        const aggregates = Object.keys(A).map(v => translateBoundAggregate(<AggregateExpression> A[v], <RDF.Variable>factory.createTerm(v)));\n        const vars: RDF.Variable[] = [];\n        if (select.group)\n        {\n            for (const e of select.group)\n            {\n                if (Util.isSimpleTerm(e.expression)) {\n                    vars.push(<RDF.Variable>e.expression); // this will always be a var, otherwise sparql would be invalid\n                } else {\n                    // Incorrect typings, e can have a variable, see for example group-variable test in sparql.js\n                    const v = 'variable' in e ? <RDF.Variable>(e as any).variable : generateFreshVar();\n                    res = factory.createExtend(res, v, translateExpression(e.expression));\n                    vars.push(v);\n                }\n\n            }\n        }\n        res = factory.createGroup(res, vars, aggregates);\n    }\n\n    // 18.2.4.2\n    if (select.having)\n        for (let filter of select.having)\n            res = factory.createFilter(res, translateExpression(filter));\n\n    // 18.2.4.3\n    if (query.values)\n        res = factory.createJoin([ res, translateInlineData(query) ]);\n\n    // 18.2.4.4\n    let PV: (RDF.Variable | RDF.NamedNode)[] = [];\n\n    if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE')\n    {\n        // Sort variables for consistent output\n        if (query.variables.some((e: any) => e && Util.isWildcard(e)))\n            PV = Object.values(inScopeVariables(query))\n              .sort((left, right) => left.value.localeCompare(right.value));\n        else\n        {\n            // Wildcard has been filtered out above\n            for (let v of query.variables as Variable[])\n            {\n                // can have non-variables with DESCRIBE\n                if (isVariable(v) || !('variable' in v))\n                    PV.push(v);\n                else if (v.variable) // ... AS ?x\n                {\n                    PV.push(v.variable);\n                    E.push(v);\n                }\n            }\n        }\n    }\n\n    // TODO: Jena simplifies by having a list of extends\n    for (let v of E)\n        res = factory.createExtend(res, <RDF.Variable>v.variable, translateExpression(v.expression));\n\n    // 18.2.5\n    // not using toList and toMultiset\n\n    // 18.2.5.1\n    if (select.order)\n        res = factory.createOrderBy(res, select.order.map((exp: any) =>\n        {\n            let result = translateExpression(exp.expression);\n            if (exp.descending)\n                result = factory.createOperatorExpression('desc', [result]);\n            return result;\n        }));\n\n    // 18.2.5.2\n    // construct does not need a project (select, ask and describe do)\n    if (query.queryType === 'SELECT')\n        // Named nodes are only possible in a DESCRIBE so this cast is safe\n        res = factory.createProject(res, PV as RDF.Variable[]);\n\n    // 18.2.5.3\n    if (select.distinct)\n        res = factory.createDistinct(res);\n\n    // 18.2.5.4\n    if (select.reduced)\n        res = factory.createReduced(res);\n\n    // NEW: support for ask/construct/describe queries\n    if (query.queryType === 'CONSTRUCT')\n        res = factory.createConstruct(res, (query.template || []).map(translateQuad));\n    else if (query.queryType === 'ASK')\n        res = factory.createAsk(res);\n    else if (query.queryType === 'DESCRIBE')\n        res = factory.createDescribe(res, PV);\n\n    // Slicing needs to happen after construct/describe\n    // 18.2.5.5\n    if (select.offset || select.limit)\n        res = factory.createSlice(res, select.offset || 0, select.limit);\n\n    if (select.from)\n        res = factory.createFrom(res, select.from.default, select.from.named);\n\n    return res;\n}\n\ntype mapAggregateType = Variable | Wildcard | Expression | Ordering;\n\n// rewrites some of the input sparql object to make use of aggregate variables\nfunction mapAggregate (thingy: mapAggregateType, aggregates: NodeJS.Dict<AggregateExpression>) : any\n{\n    if ('type' in thingy && thingy.type === 'aggregate')\n    {\n        let found = false;\n        let v;\n        for (let key of Object.keys(aggregates))\n        {\n            if (equal(aggregates[key], thingy))\n            {\n                v = factory.createTerm(key);\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n        {\n            v = generateFreshVar();\n            aggregates[termToString(v)] = thingy;\n        }\n        return v;\n    }\n\n    // non-aggregate expression\n    if ('expression' in thingy && thingy.expression)\n        return { ...thingy, expression: mapAggregate(thingy.expression, aggregates) };\n    if ('args' in thingy && thingy.args)\n        return { ...thingy, args: thingy.args.map(subthingy => mapAggregate(subthingy, aggregates)) };\n\n    // Normal variable/wildcard\n    return thingy;\n}\n\nfunction translateBoundAggregate (thingy: AggregateExpression, v: RDF.Variable) : Algebra.BoundAggregate\n{\n    if (thingy.type !== 'aggregate' || !thingy.aggregation)\n        throw new Error(`Unexpected input: ${JSON.stringify(thingy)}`);\n\n    const A  = <Algebra.BoundAggregate>translateExpression(thingy);\n    A.variable = v;\n\n    return A;\n}\n\nfunction translateUpdate (thingy: Update) : Algebra.Operation {\n    if (thingy.updates.length === 1)\n        return translateSingleUpdate(thingy.updates[0]);\n    return factory.createCompositeUpdate(thingy.updates.map(translateSingleUpdate));\n}\n\nfunction translateSingleUpdate (thingy: UpdateOperation) : Algebra.Update {\n    if ('type' in thingy) {\n        if (thingy.type === 'load')\n            return translateUpdateGraphLoad(thingy);\n        if (thingy.type === 'clear' || thingy.type === 'create' || thingy.type === 'drop')\n            return translateUpdateGraph(thingy);\n        if (thingy.type === 'add' || thingy.type === 'copy' || thingy.type === 'move')\n            return translateUpdateGraphShortcut(thingy);\n    }\n    else if (thingy.updateType === 'insertdelete' || thingy.updateType === 'deletewhere' || thingy.updateType === 'delete' || thingy.updateType === 'insert')\n        return translateInsertDelete(thingy);\n\n    throw new Error(`Unknown update type ${JSON.stringify(thingy)}`);\n}\n\nfunction translateInsertDelete (thingy: InsertDeleteOperation): Algebra.Update\n{\n    if (!useQuads)\n        throw new Error('INSERT/DELETE operations are only supported with quads option enabled');\n\n    let deleteTriples: Algebra.Pattern[] = [];\n    let insertTriples: Algebra.Pattern[] = [];\n    let where: Algebra.Operation;\n    if (thingy.delete)\n        deleteTriples = Util.flatten(thingy.delete.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n    if (thingy.insert)\n        insertTriples = Util.flatten(thingy.insert.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n    if (thingy.where && thingy.where.length > 0) {\n        where = translateGraphPattern({ type: 'group', patterns: thingy.where });\n        // Wrong typings, see test \"using\" in Sparql.js\n        const use: { default: RDF.NamedNode[], named: RDF.NamedNode[] } | undefined = (thingy as any).using;\n        if (use)\n            where = factory.createFrom(where, use.default, use.named);\n        else if (thingy.graph)\n            // This is equivalent\n            where = recurseGraph(where, thingy.graph);\n    } else if (thingy.updateType === 'deletewhere' && deleteTriples.length > 0) {\n        where = factory.createBgp(deleteTriples);\n    }\n\n    return factory.createDeleteInsert(\n        deleteTriples.length > 0 ? deleteTriples : undefined,\n        insertTriples.length > 0 ? insertTriples : undefined,\n        where!,\n    );\n}\n\n// UPDATE parsing will always return quads and have no GRAPH elements\nfunction translateUpdateTriplesBlock (thingy: BgpPattern | GraphQuads, graph?: RDF.NamedNode): Algebra.Pattern[] {\n    let currentGraph = graph;\n    if (thingy.type === 'graph')\n        currentGraph = thingy.name;\n    let currentTriples = thingy.triples;\n    if (currentGraph)\n        currentTriples = currentTriples.map(triple => Object.assign(triple, { graph: currentGraph }));\n    return currentTriples.map(translateQuad);\n}\n\nfunction translateUpdateGraph (thingy: CreateOperation | ClearDropOperation): Algebra.Update\n{\n    let source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;\n    if (Util.isSimpleTerm(thingy.graph))\n        source = thingy.graph;\n    else if (thingy.graph.all)\n        source = 'ALL';\n    else if (thingy.graph.default)\n        source = 'DEFAULT';\n    else if (thingy.graph.named)\n        source = 'NAMED';\n    else\n        source = thingy.graph.name!;\n\n    switch (thingy.type)\n    {\n        case 'clear': return factory.createClear(source, thingy.silent);\n        case 'create': return factory.createCreate(source as RDF.NamedNode, thingy.silent);\n        case 'drop':  return factory.createDrop(source, thingy.silent);\n    }\n}\n\nfunction translateUpdateGraphLoad (thingy: LoadOperation): Algebra.Load\n{\n    return factory.createLoad(thingy.source, thingy.destination as (RDF.NamedNode | undefined), thingy.silent);\n}\n\nfunction translateUpdateGraphShortcut (thingy: CopyMoveAddOperation): Algebra.Update\n{\n    const source: 'DEFAULT' | RDF.NamedNode = thingy.source.default ? 'DEFAULT' : <RDF.NamedNode> thingy.source.name;\n    const destination: 'DEFAULT' | RDF.NamedNode = thingy.destination.default ? 'DEFAULT' : <RDF.NamedNode> thingy.destination.name;\n    switch (thingy.type)\n    {\n        case 'copy': return factory.createCopy(source, destination, thingy.silent);\n        case 'move': return factory.createMove(source, destination, thingy.silent);\n        case 'add':  return factory.createAdd(source, destination, thingy.silent);\n    }\n}\n\nfunction translateBlankNodesToVariables (res: Algebra.Operation) : Algebra.Operation\n{\n    const blankToVariableMapping: {[bLabel: string]: RDF.Variable} = {};\n    const variablesRaw: {[vLabel: string]: boolean} = Array.from(variables).reduce((acc: {[vLabel: string]: boolean}, variable: string) => {\n        acc[variable] = true;\n        return acc;\n    }, {});\n    return Util.mapOperation(res, {\n        [Algebra.types.DELETE_INSERT]: (op: Algebra.DeleteInsert) => {\n            // Make sure blank nodes remain in the INSERT block, but do update the WHERE block\n            return { \n                result: factory.createDeleteInsert(op.delete, op.insert, op.where && translateBlankNodesToVariables(op.where)), \n                recurse: false,\n            };\n        },\n        [Algebra.types.PATH]: (op: Algebra.Path, factory: Factory) => {\n            return {\n                result: factory.createPath(\n                    blankToVariable(op.subject),\n                    op.predicate,\n                    blankToVariable(op.object),\n                    blankToVariable(op.graph),\n                ),\n                recurse: false,\n            };\n        },\n        [Algebra.types.PATTERN]: (op: Algebra.Pattern, factory: Factory) => {\n            return {\n                result: factory.createPattern(\n                    blankToVariable(op.subject),\n                    blankToVariable(op.predicate),\n                    blankToVariable(op.object),\n                    blankToVariable(op.graph),\n                ),\n                recurse: false,\n            };\n        },\n        [Algebra.types.CONSTRUCT]: (op: Algebra.Construct) => {\n            // Blank nodes in CONSTRUCT templates must be maintained\n            return {\n                result: factory.createConstruct(translateBlankNodesToVariables(op.input), op.template),\n                recurse: false,\n            };\n        },\n    });\n\n    function blankToVariable(term: RDF.Term): RDF.Term\n    {\n        if (term.termType === 'BlankNode') {\n            let variable = blankToVariableMapping[term.value];\n            if (!variable) {\n                variable = Util.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);\n                variablesRaw[variable.value] = true;\n                blankToVariableMapping[term.value] = variable;\n            }\n            return variable;\n        }\n        return term;\n  }\n}\n"]}