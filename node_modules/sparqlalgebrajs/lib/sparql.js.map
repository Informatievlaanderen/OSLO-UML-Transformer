{"version":3,"file":"sparql.js","sourceRoot":"","sources":["sparql.ts"],"names":[],"mappings":"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","sourcesContent":["import { isomorphic } from 'rdf-isomorphic';\nimport * as RDF from '@rdfjs/types'\nimport { stringToTerm, termToString } from 'rdf-string';\nimport {\n    AggregateExpression,\n    BgpPattern,\n    ClearDropOperation,\n    ConstructQuery,\n    CopyMoveAddOperation,\n    CreateOperation,\n    FunctionCallExpression,\n    Generator,\n    GraphOrDefault,\n    GraphPattern,\n    GraphReference,\n    GroupPattern,\n    InsertDeleteOperation,\n    IriTerm,\n    LoadOperation,\n    OperationExpression,\n    Ordering,\n    Pattern,\n    PropertyPath,\n    Query,\n    SelectQuery,\n    ServicePattern,\n    Triple,\n    UnionPattern,\n    Update,\n    ValuePatternRow,\n    ValuesPattern,\n    Variable,\n    Wildcard\n} from 'sparqljs';\nimport * as Algebra from './algebra';\nimport Factory from './factory';\nimport Util from './util';\n\nconst types = Algebra.types;\nconst eTypes = Algebra.expressionTypes;\n\nlet context : { project: boolean, extend: Algebra.Extend[], group: RDF.Variable[], aggregates: Algebra.BoundAggregate[], order: Algebra.Expression[] };\nconst factory = new Factory();\n\nexport function toSparql(op: Algebra.Operation, options = {}): string\n{\n    let generator = new Generator(options);\n    return generator.stringify(toSparqlJs(op));\n}\n\nexport function toSparqlJs(op: Algebra.Operation):  any\n{\n    resetContext();\n    op = removeQuads(op);\n    let result = translateOperation(op);\n    if (result.type === 'group')\n        return result.patterns[0];\n    return result;\n}\n\nfunction resetContext()\n{\n    context = { project: false, extend: [], group: [], aggregates: [], order: [] };\n}\n\nfunction translateOperation(op: Algebra.Operation): any\n{\n    // this allows us to differentiate between BIND and SELECT when translating EXTEND\n    // GRAPH was added because the way graphs get added back here is not the same as how they get added in the future\n    // ^ seems fine but might have to be changed if problems get detected in the future\n    if (op.type !== types.EXTEND && op.type !== types.ORDER_BY && op.type !== types.GRAPH)\n        context.project = false;\n\n    switch(op.type)\n    {\n        case types.EXPRESSION: return translateExpression(op);\n\n        case types.ASK:       return translateProject(op, types.ASK);\n        case types.BGP:       return translateBgp(op);\n        case types.CONSTRUCT: return translateConstruct(op);\n        case types.DESCRIBE:  return translateProject(op, types.DESCRIBE);\n        case types.DISTINCT:  return translateDistinct(op);\n        case types.EXTEND:    return translateExtend(op);\n        case types.FROM:      return translateFrom(op);\n        case types.FILTER:    return translateFilter(op);\n        case types.GRAPH:     return translateGraph(op);\n        case types.GROUP:     return translateGroup(op);\n        case types.JOIN:      return translateJoin(op);\n        case types.LEFT_JOIN: return translateLeftJoin(op);\n        case types.MINUS:     return translateMinus(op);\n        case types.NOP:       return {};\n        case types.ORDER_BY:  return translateOrderBy(op);\n        case types.PATH:      return translatePath(op);\n        case types.PATTERN:   return translatePattern(op);\n        case types.PROJECT:   return translateProject(op, types.PROJECT);\n        case types.REDUCED:   return translateReduced(op);\n        case types.SERVICE:   return translateService(op);\n        case types.SLICE:     return translateSlice(op);\n        case types.UNION:     return translateUnion(op);\n        case types.VALUES:    return translateValues(op);\n        // UPDATE operations\n        case types.COMPOSITE_UPDATE: return translateCompositeUpdate(op);\n        case types.DELETE_INSERT:    return translateDeleteInsert(op);\n        case types.LOAD:             return translateLoad(op);\n        case types.CLEAR:            return translateClear(op);\n        case types.CREATE:           return translateCreate(op);\n        case types.DROP:             return translateDrop(op);\n        case types.ADD:              return translateAdd(op);\n        case types.MOVE:             return translateMove(op);\n        case types.COPY:             return translateCopy(op);\n    }\n\n    throw new Error(`Unknown Operation type ${op.type}`);\n}\n\nfunction translateExpression(expr: Algebra.Expression): any\n{\n    switch(expr.expressionType)\n    {\n        case eTypes.AGGREGATE: return translateAggregateExpression(expr);\n        case eTypes.EXISTENCE: return translateExistenceExpression(expr);\n        case eTypes.NAMED:     return translateNamedExpression(expr);\n        case eTypes.OPERATOR:  return translateOperatorExpression(expr);\n        case eTypes.TERM:      return translateTermExpression(expr);\n        case eTypes.WILDCARD:  return translateWildcardExpression(expr);\n    }\n\n    throw new Error(`Unknown Expression Operation type ${(expr as any).expressionType}`);\n}\n\nfunction translatePathComponent(path: Algebra.Operation): IriTerm | PropertyPath\n{\n    switch(path.type)\n    {\n        case types.ALT:               return translateAlt(path);\n        case types.INV:               return translateInv(path);\n        case types.LINK:              return translateLink(path);\n        case types.NPS:               return translateNps(path);\n        case types.ONE_OR_MORE_PATH:  return translateOneOrMorePath(path);\n        case types.SEQ:               return translateSeq(path);\n        case types.ZERO_OR_MORE_PATH: return translateZeroOrMorePath(path);\n        case types.ZERO_OR_ONE_PATH:  return translateZeroOrOnePath(path);\n    }\n\n    throw new Error(`Unknown Path type ${path.type}`);\n}\n\nfunction translateTerm(term: RDF.Term): string\n{\n    return termToString(term);\n}\n\n// ------------------------- EXPRESSIONS -------------------------\n\nfunction translateAggregateExpression(expr: Algebra.AggregateExpression): AggregateExpression\n{\n    const result: any = {\n        expression: translateExpression(expr.expression),\n        type: 'aggregate',\n        aggregation: expr.aggregator,\n        distinct: expr.distinct\n    };\n\n    if (expr.separator)\n        result.separator = expr.separator;\n\n    return result;\n}\n\nfunction translateExistenceExpression(expr: Algebra.ExistenceExpression): OperationExpression\n{\n    return {\n        type: 'operation',\n        operator: expr.not ? 'notexists' : 'exists',\n        args: [{ \n          type: 'group',\n          patterns: Util.flatten([ translateOperation(expr.input) ])\n        }]\n    };\n}\n\nfunction translateNamedExpression(expr: Algebra.NamedExpression): FunctionCallExpression\n{\n    return {\n        type: 'functionCall',\n        // Wrong typings\n        function: expr.name as any,\n        args: expr.args.map(translateExpression)\n    }\n}\n\nfunction translateOperatorExpression(expr: Algebra.OperatorExpression): Ordering | OperationExpression\n{\n    if (expr.operator === 'desc')\n    {\n        const result: Ordering = { expression: translateExpression(expr.args[0])};\n        result.descending = true;\n        return result;\n    }\n\n    const result: OperationExpression = {\n        type: 'operation',\n        operator: expr.operator,\n        args: expr.args.map(translateExpression)\n    };\n\n    if (result.operator === 'in' || result.operator === 'notin')\n        result.args = [result.args[0]].concat([result.args.slice(1)]);\n\n    return result;\n}\n\nfunction translateTermExpression(expr: Algebra.TermExpression): RDF.Term\n{\n    return expr.term;\n}\n\nfunction translateWildcardExpression(expr: Algebra.WildcardExpression): Wildcard\n{\n    return expr.wildcard;\n}\n\nfunction arrayToPattern(input: any): Pattern\n{\n    if (!Array.isArray(input))\n        return input;\n    if (input.length === 1)\n        return input[0];\n    return {\n        type: 'group',\n        patterns: input,\n    } satisfies GroupPattern\n}\n\n// ------------------------- OPERATIONS -------------------------\n// these get translated in the project function\nfunction translateBoundAggregate(op: Algebra.BoundAggregate): Algebra.BoundAggregate\n{\n    return op;\n}\n\nfunction translateBgp(op: Algebra.Bgp): BgpPattern | null\n{\n    let patterns = op.patterns.map(translatePattern);\n    if (patterns.length === 0)\n        return null;\n    return {\n        type: 'bgp',\n        triples: patterns\n    };\n}\n\nfunction translateConstruct(op: Algebra.Construct): ConstructQuery\n{\n    return {\n        type: 'query',\n        prefixes: {},\n        queryType: 'CONSTRUCT',\n        template: op.template.map(translatePattern),\n        where: Util.flatten([\n            translateOperation(op.input)\n        ])\n    }\n}\n\nfunction translateDistinct(op: Algebra.Distinct): GroupPattern\n{\n    let result = translateOperation(op.input);\n    // project is nested in group object\n    result.patterns[0].distinct = true;\n    return result\n}\n\nfunction translateExtend(op: Algebra.Extend): any\n{\n    if (context.project)\n    {\n        context.extend.push(op);\n        return translateOperation(op.input);\n    }\n    return Util.flatten([\n        translateOperation(op.input),\n        {\n            type: 'bind',\n            variable: op.variable,\n            expression: translateExpression(op.expression)\n        }\n    ])\n}\n\nfunction translateFrom(op: Algebra.From): GroupPattern\n{\n    const result = translateOperation(op.input);\n    // Can't type as CONSTRUCT queries do not have `from` field in their type\n    let obj = result;\n    // project is nested in group object\n    if (result.type === 'group') {\n        obj = result.patterns[0];\n    }\n    obj.from = {\n        default: op.default,\n        named: op.named\n    };\n    return result;\n}\n\nfunction translateFilter(op: Algebra.Filter): GroupPattern\n{\n    return {\n        type: 'group',\n        patterns:  Util.flatten ([\n                translateOperation(op.input),\n                { type : 'filter', expression: translateExpression(op.expression) }\n            ])\n    };\n}\n\nfunction translateGraph(op: Algebra.Graph): GraphPattern\n{\n    return {\n        type: 'graph',\n        patterns: Util.flatten([ translateOperation(op.input) ]),\n        name: op.name as IriTerm\n    }\n}\n\nfunction translateGroup(op: Algebra.Group): any\n{\n    const input = translateOperation(op.input);\n    const aggs = op.aggregates.map(translateBoundAggregate);\n    context.aggregates.push(...aggs);\n    // TODO: apply possible extends\n    context.group.push(...op.variables);\n\n    return input;\n}\n\nfunction translateJoin(op: Algebra.Join): Pattern[]\n{\n    const arr: any[] = Util.flatten(op.input.map(translateOperation));\n\n    // Merge bgps\n    // This is possible if one side was a path and the other a bgp for example\n    return arr.reduce((result, val) => {\n        if (val.type !== 'bgp' || result.length == 0 || result[result.length-1].type !== 'bgp') {\n            result.push(val);\n        } else {\n            result[result.length - 1].triples.push(...val.triples);\n        }\n        return result;\n    }, []);\n}\n\nfunction translateLeftJoin(op: Algebra.LeftJoin): Pattern[]\n{\n    const leftjoin = {\n        type: 'optional',\n        patterns: [\n            translateOperation(op.input[1])\n        ]\n    };\n\n    if (op.expression)\n    {\n        leftjoin.patterns.push(\n            {\n                type: 'filter',\n                expression: translateExpression(op.expression)\n            }\n        );\n    }\n    leftjoin.patterns = Util.flatten(leftjoin.patterns);\n\n    return Util.flatten([\n        translateOperation(op.input[0]),\n        leftjoin\n    ])\n}\n\nfunction translateMinus(op: Algebra.Minus): Pattern[]\n{\n    let patterns = translateOperation(op.input[1]);\n    if (patterns.type === 'group')\n        patterns = patterns.patterns;\n    if (!Array.isArray(patterns))\n        patterns = [ patterns ];\n    return Util.flatten([\n        translateOperation(op.input[0]),\n        {\n            type: 'minus',\n            patterns: patterns\n        }\n    ]);\n}\n\nfunction translateOrderBy(op: Algebra.OrderBy): any\n{\n    context.order.push(...op.expressions);\n    return translateOperation(op.input);\n}\n\nfunction translatePath(op: Algebra.Path): BgpPattern\n{\n    return {\n        type: 'bgp',\n        triples: [{\n            subject  : op.subject as RDF.Quad_Subject,\n            predicate: translatePathComponent(op.predicate),\n            object   : op.object as RDF.Quad_Object\n        }]\n    };\n}\n\nfunction translatePattern(op: Algebra.Pattern): Triple\n{\n    return {\n        subject: op.subject as RDF.Quad_Subject,\n        predicate: op.predicate as RDF.Quad_Predicate,\n        object: op.object as RDF.Quad_Object\n    };\n}\n\nfunction replaceAggregatorVariables(s: any, map: any): any\n{\n    let st = Util.isSimpleTerm(s) ? translateTerm(s) : s;\n\n    if (typeof st === 'string')\n    {\n        if (map[st])\n            return map[st];\n    }\n    else if (Array.isArray(s))\n    {\n        s = s.map(e => replaceAggregatorVariables(e, map));\n    }\n    else\n    {\n        for (let key of Object.keys(s))\n            s[key] = replaceAggregatorVariables(s[key], map);\n    }\n    return s;\n}\n\nfunction translateProject(op: Algebra.Project | Algebra.Ask | Algebra.Describe, type: string): GroupPattern\n{\n    const result: Query = {\n        type: 'query',\n        prefixes: {}\n    } as any;\n\n    // Makes typing easier in some places\n    const select: SelectQuery = result as any;\n    let variables: RDF.Variable[] | undefined;\n\n    if (type === types.PROJECT)\n    {\n        result.queryType = 'SELECT';\n        variables = op.variables;\n    } else if (type === types.ASK) {\n        result.queryType = 'ASK';\n    } else if (type === types.DESCRIBE) {\n        result.queryType = 'DESCRIBE';\n        variables = op.terms;\n    }\n\n    // backup values in case of nested queries\n    // everything in extend, group, etc. is irrelevant for this project call\n    const extend = context.extend;\n    const group = context.group;\n    const aggregates = context.aggregates;\n    const order = context.order;\n    resetContext();\n\n    context.project = true;\n    let input = Util.flatten<any>([ translateOperation(op.input) ]);\n    if (input.length === 1 && input[0].type === 'group')\n        input = input[0].patterns;\n    result.where = input;\n\n    let aggregators: any = {};\n    // these can not reference each other\n    for (let agg of context.aggregates)\n        aggregators[translateTerm(agg.variable)] = translateExpression(agg);\n\n    // do these in reverse order since variables in one extend might apply to an expression in an other extend\n    let extensions: Record<string, any> = {};\n    for (let i = context.extend.length-1; i >= 0; --i)\n    {\n        let e = context.extend[i];\n        extensions[translateTerm(e.variable)] = replaceAggregatorVariables(translateExpression(e.expression), aggregators);\n    }\n    if (context.group.length > 0)\n        select.group = context.group.map(variable =>\n        {\n            let v = translateTerm(variable);\n            if (extensions[v])\n            {\n                let result = extensions[v];\n                delete extensions[v]; // make sure there is only 1 'AS' statement\n                return {\n                    variable,\n                    expression: result\n                };\n            }\n            return { expression: variable };\n        });\n\n    // descending expressions will already be in the correct format due to the structure of those\n    if (context.order.length > 0)\n        select.order = context.order.map(translateOperation).map(o => o.descending ? o : ({ expression: o }));\n\n    // this needs to happen after the group because it might depend on variables generated there\n    if (variables)\n    {\n        select.variables = variables.map((term): Variable => {\n            let v = translateTerm(term);\n            if (extensions[v]) {\n                let result = extensions[v];\n                delete extensions[v]; // remove used extensions so only unused ones remain\n                return {\n                    variable: term,\n                    expression: result,\n                };\n            }\n            return term;\n        });\n        // if the * didn't match any variables this would be empty\n        if (select.variables.length === 0)\n            select.variables = [new Wildcard()];\n    }\n    \n    // It is possible that at this point some extensions have not yet been resolved.\n    // These would be bind operations that are not used in a GROUP BY or SELECT body.\n    // We still need to add them though, as they could be relevant to the other extensions.\n    const extensionEntries = Object.entries(extensions);\n    if (extensionEntries.length > 0) {\n        select.where = select.where || [];\n        for (const [ key, value ] of extensionEntries) {\n            select.where.push({\n                type: 'bind',\n                variable: stringToTerm(key) as RDF.Variable,\n                expression: value\n            });\n        }\n    }\n\n\n    // convert filter to 'having' if it contains an aggregator variable\n    // could always convert, but is nicer to use filter when possible\n    if (result.where.length > 0 && result.where[result.where.length-1].type === 'filter')\n    {\n        const filter = result.where[result.where.length-1];\n        if (objectContainsValues(filter, Object.keys(aggregators)))\n        {\n            select.having = Util.flatten([ replaceAggregatorVariables((filter as any).expression, aggregators) ]);\n            result.where.splice(-1);\n        }\n    }\n\n    context.extend = extend;\n    context.group = group;\n    context.aggregates = aggregates;\n    context.order = order;\n\n    // subqueries need to be in a group, this will be removed again later for the root query\n    return { type: 'group', patterns: [select] };\n}\n\nfunction objectContainsValues(o: any, vals: string[]): boolean\n{\n    if (Util.isSimpleTerm(o))\n        return vals.indexOf(translateTerm(o)) >= 0;\n    if (Array.isArray(o))\n        return o.some(e => objectContainsValues(e, vals));\n    if (o === Object(o))\n        return Object.keys(o).some(key => objectContainsValues(o[key], vals));\n    return vals.indexOf(o) >= 0;\n}\n\nfunction translateReduced(op: Algebra.Reduced): Pattern\n{\n    let result = translateOperation(op.input);\n    // project is nested in group object\n    result.patterns[0].reduced = true;\n    return result\n}\n\nfunction translateService(op: Algebra.Service): ServicePattern\n{\n    let patterns = translateOperation(op.input);\n    if (patterns.type === 'group')\n        patterns = patterns.patterns;\n    if (!Array.isArray(patterns))\n        patterns = [patterns];\n    return {\n        type: 'service',\n        // Typings are wrong, name can also be a variable\n        name: op.name as RDF.NamedNode,\n        silent: op.silent,\n        patterns\n    };\n}\n\nfunction translateSlice(op: Algebra.Slice): Pattern\n{\n    let result = translateOperation(op.input);\n    // results can be nested in a group object\n    let obj = result;\n    if (result.type && result.type === 'group')\n        obj = result.patterns[0];\n    if (op.start !== 0)\n        obj.offset = op.start;\n    if (op.length !== undefined)\n        obj.limit = op.length;\n    return result;\n}\n\nfunction translateUnion(op: Algebra.Union): UnionPattern\n{\n    return {\n        type: 'union',\n        patterns: op.input.map(translateOperation).map(arrayToPattern),\n    }\n}\n\nfunction translateValues(op: Algebra.Values): ValuesPattern\n{\n    // TODO: check if handled correctly when outside of select block\n    return {\n        type: 'values',\n        values: op.bindings.map(binding =>\n        {\n            let result: ValuePatternRow = {};\n            for (let v of op.variables)\n            {\n                let s = `?${v.value}`;\n                if (binding[s])\n                    result[s] = binding[s];\n                else\n                    result[s] = undefined;\n            }\n            return result;\n        })\n    };\n}\n\n// PATH COMPONENTS\n\nfunction translateAlt(path: Algebra.Alt): any\n{\n    const mapped = path.input.map(translatePathComponent);\n    if (mapped.every(entry => 'pathType' in entry && entry.pathType === '!'))\n    {\n        return {\n            type: 'path',\n            pathType: '!',\n            items: [ {\n                type: 'path',\n                pathType: '|',\n                items: Util.flatten(mapped.map(entry => (<PropertyPath> entry).items))\n            } ]\n        }\n    }\n\n    return {\n        type: 'path',\n        pathType: '|',\n        items: mapped\n    }\n}\n\nfunction translateInv(path: Algebra.Inv): PropertyPath\n{\n    if (path.path.type === types.NPS)\n    {\n        const inv: PropertyPath[] = path.path.iris.map((iri: RDF.NamedNode) =>\n        {\n            return {\n                type: 'path',\n                pathType: '^',\n                items: [ iri ]\n            }\n        });\n\n        if (inv.length <= 1)\n            return {\n                type    : 'path',\n                pathType: '!',\n                items   : inv\n            };\n\n        return {\n            type: 'path',\n            pathType: '!',\n            items: [ {\n                type: 'path',\n                pathType: '|',\n                items: inv\n            } ]\n        }\n    }\n\n    return {\n        type: 'path',\n        pathType: '^',\n        items: [ translatePathComponent(path.path) ]\n    }\n}\n\nfunction translateLink(path: Algebra.Link): RDF.NamedNode\n{\n    return path.iri;\n}\n\nfunction translateNps(path: Algebra.Nps): PropertyPath\n{\n    if (path.iris.length <= 1)\n        return {\n            type: 'path',\n            pathType: '!',\n            items: path.iris\n        };\n\n    return {\n        type: 'path',\n        pathType: '!',\n        items: [ {\n            type: 'path',\n            pathType: '|',\n            items: path.iris\n        } ]\n    }\n}\n\nfunction translateOneOrMorePath(path: Algebra.OneOrMorePath): PropertyPath\n{\n    return {\n        type: 'path',\n        pathType: '+',\n        items: [ translatePathComponent(path.path) ]\n    }\n}\n\nfunction translateSeq(path: Algebra.Seq): PropertyPath\n{\n    return {\n        type: 'path',\n        pathType: '/',\n        items: path.input.map(translatePathComponent)\n    }\n}\n\nfunction translateZeroOrMorePath(path: Algebra.ZeroOrMorePath): PropertyPath\n{\n    return {\n        type: 'path',\n        pathType: '*',\n        items: [ translatePathComponent(path.path) ]\n    }\n}\nfunction translateZeroOrOnePath(path: Algebra.ZeroOrOnePath): PropertyPath\n{\n    // Typings are missing '?' operator\n    return {\n        type: 'path',\n        // Typings are missing this path\n        pathType: '?' as any,\n        items: [ translatePathComponent(path.path) ]\n    }\n}\n\n// UPDATE OPERATIONS\n\nfunction translateCompositeUpdate(op: Algebra.CompositeUpdate): Update\n{\n  const updates = op.updates.map(update => {\n    const result = translateOperation(update);\n    return result.updates[0];\n  });\n\n  return { prefixes: {}, type: 'update', updates }\n}\n\nfunction translateDeleteInsert(op: Algebra.DeleteInsert): Update\n{\n    let where: Algebra.Operation | undefined = op.where;\n    let use = undefined;\n    if (where && where.type === types.FROM) {\n        let from = where;\n        where = from.input;\n        use = { default: from.default, named: from.named };\n    }\n\n    const updates: [InsertDeleteOperation] = [{\n        updateType: 'insertdelete',\n        delete: convertUpdatePatterns(op.delete || []),\n        insert: convertUpdatePatterns(op.insert || []),\n    }];\n    // Typings don't support 'using' yet\n    if (use)\n        (updates[0] as any).using = use;\n\n    // corresponds to empty array in SPARQL.js\n    if (!where || (where.type === types.BGP && where.patterns.length === 0))\n        updates[0].where = [];\n    else\n    {\n        const graphs: RDF.NamedNode[] = [];\n        let result = translateOperation(removeQuadsRecursive(where, graphs));\n        if (result.type === 'group')\n            updates[0].where = result.patterns;\n        else\n            updates[0].where = [result];\n        // graph might not be applied yet since there was no project\n        // this can only happen if there was a single graph\n        if (graphs.length > 0) {\n            if (graphs.length !== 1)\n                throw new Error('This is unexpected and might indicate an error in graph handling for updates.');\n            // ignore if default graph\n            if (graphs[0]?.value !== '')\n                updates[0].where = [{ type: 'graph', patterns: updates[0].where!, name: graphs[0] }]\n        }\n    }\n\n    // not really necessary but can give cleaner looking queries\n    if (!op.delete && !op.where) {\n        updates[0].updateType = 'insert';\n        delete updates[0].delete;\n        delete updates[0].where;\n    } else if (!op.insert && !op.where) {\n        delete updates[0].insert;\n        delete updates[0].where;\n        if (op.delete!.some(pattern =>\n          pattern.subject.termType === 'Variable' ||\n          pattern.predicate.termType === 'Variable' ||\n          pattern.object.termType === 'Variable'))\n            updates[0].updateType = 'deletewhere';\n        else\n            updates[0].updateType = 'delete';\n    } else if (!op.insert && op.where && op.where.type === 'bgp') {\n        if (isomorphic(op.delete!, op.where.patterns)) {\n            delete updates[0].where;\n            updates[0].updateType = 'deletewhere';\n        }\n    }\n\n    return { prefixes: {}, type: 'update', updates }\n}\n\nfunction translateLoad(op: Algebra.Load): Update\n{\n    // Typings are wrong, destiniation is optional\n    const updates: [LoadOperation] = [{ type: 'load', silent: Boolean(op.silent), source: op.source } as any];\n    if (op.destination)\n        updates[0].destination = op.destination;\n    return { prefixes: {}, type: 'update', updates }\n}\n\nfunction translateClear(op: Algebra.Clear): Update\n{\n    return translateClearCreateDrop(op, 'clear');\n}\n\nfunction translateCreate(op: Algebra.Create): Update\n{\n    return translateClearCreateDrop(op, 'create');\n}\n\nfunction translateDrop(op: Algebra.Drop): Update\n{\n    return translateClearCreateDrop(op, 'drop');\n}\n\nfunction translateClearCreateDrop(op: Algebra.Clear | Algebra.Create | Algebra.Drop, type: 'clear' | 'create' | 'drop'): Update\n{\n    const updates: [CreateOperation | ClearDropOperation] = [{ type, silent: Boolean(op.silent) } as any];\n    // Typings are wrong, type is not required, see for example \"clear-drop\" test\n    if (op.source === 'DEFAULT')\n        updates[0].graph = { default: true } as GraphOrDefault;\n    else if (op.source === 'NAMED')\n        updates[0].graph = { named: true } as GraphReference;\n    else if (op.source === 'ALL')\n        updates[0].graph = { all: true } as GraphReference;\n    else\n        updates[0].graph = { type: 'graph', name: op.source };\n\n    return { prefixes: {}, type: 'update', updates }\n}\n\nfunction translateAdd(op: Algebra.Add): Update\n{\n    return translateUpdateGraphShortcut(op, 'add');\n}\n\nfunction translateMove(op: Algebra.Move): Update\n{\n    return translateUpdateGraphShortcut(op, 'move');\n}\n\nfunction translateCopy(op: Algebra.Copy): Update\n{\n    return translateUpdateGraphShortcut(op, 'copy');\n}\n\nfunction translateUpdateGraphShortcut(op: Algebra.UpdateGraphShortcut, type: 'add' | 'move' | 'copy'): Update\n{\n    const updates: CopyMoveAddOperation[] = [{ type, silent: Boolean(op.silent) } as any];\n    updates[0].source = op.source === 'DEFAULT' ? { type: 'graph', default: true } : { type: 'graph', name: op.source };\n    updates[0].destination = op.destination === 'DEFAULT' ? { type: 'graph', default: true } : { type: 'graph', name: op.destination };\n\n    return { prefixes: {}, type: 'update', updates }\n}\n\n// similar to removeQuads but more simplified for UPDATEs\nfunction convertUpdatePatterns(patterns: Algebra.Pattern[]): any[]\n{\n    if (!patterns)\n        return [];\n    const graphs: { [graph: string]: Algebra.Pattern[] } = {};\n    patterns.forEach(pattern =>\n    {\n        const graph = pattern.graph.value;\n        if (!graphs[graph])\n            graphs[graph] = [];\n        graphs[graph].push(pattern);\n    });\n    return Object.keys(graphs).map(graph =>\n    {\n        if (graph === '')\n            return { type: 'bgp', triples: graphs[graph].map(translatePattern) };\n        return { type: 'graph', triples: graphs[graph].map(translatePattern), name: graphs[graph][0].graph };\n    });\n}\n\nfunction removeQuads(op: Algebra.Operation): any\n{\n    return removeQuadsRecursive(op, []);\n}\n\n// remove quads\nfunction removeQuadsRecursive(op: any, graphs: RDF.NamedNode[]): any\n{\n    if (Array.isArray(op))\n        return op.map(sub => removeQuadsRecursive(sub, graphs));\n\n    if (!op.type)\n        return op;\n\n    // UPDATE operations with Patterns handle graphs a bit differently\n    if (op.type === types.DELETE_INSERT)\n      return op;\n\n    if ((op.type === types.PATTERN || op.type === types.PATH) && op.graph)\n    {\n        graphs.push(op.graph);\n        // Remove non-default graphs\n        if (op.graph.name !== '')\n            return op.type === types.PATTERN ?\n              factory.createPattern(op.subject, op.predicate, op.object) :\n              factory.createPath(op.subject, op.predicate, op.object);\n        return op;\n    }\n\n    const result: any = {};\n    const keyGraphs: {[id: string]: RDF.NamedNode[]} = {}; // unique graph per key\n    const globalNames: {[id: string]: RDF.NamedNode} = {}; // track all the unique graph names for the entire Operation\n    for (let key of Object.keys(op))\n    {\n        const newGraphs: RDF.NamedNode[] = [];\n        result[key] = removeQuadsRecursive(op[key], newGraphs);\n\n        if (newGraphs.length > 0) {\n            keyGraphs[key] = newGraphs;\n            for (const graph of newGraphs) {\n                globalNames[graph.value] = graph;\n            }\n        }\n    }\n\n    const graphNameSet = Object.keys(globalNames);\n    if (graphNameSet.length > 0)\n    {\n        // We also need to create graph statement if we are at the edge of certain operations\n        if (graphNameSet.length === 1 && ![ types.PROJECT, types.SERVICE ].includes(op.type))\n            graphs.push(globalNames[graphNameSet[0]]);\n        else if (op.type === types.BGP)\n        {\n            // This is the specific case that got changed because of using quads.\n            return splitBgpToGraphs(op, keyGraphs.patterns);\n        } else {\n            // multiple graphs (or project), need to create graph objects for them\n            for (let key of Object.keys(keyGraphs))\n            {\n                const value = result[key];\n                if (Array.isArray(value))\n                    result[key] = value.map((child, idx) => keyGraphs[key][0].value === '' ? child : factory.createGraph(child, keyGraphs[key][idx]));\n                else if (keyGraphs[key][0].value !== '')\n                    result[key] = factory.createGraph(value, keyGraphs[key][0]);\n            }\n        }\n    }\n\n    return result;\n}\n\n// `graphs` should be an array of length identical to `op.patterns`, containing the corresponding graph for each triple.\nfunction splitBgpToGraphs(op: Algebra.Bgp, graphs: RDF.NamedNode[]): Algebra.Operation\n{\n    // Split patterns per graph\n    const graphPatterns: Record<string, { patterns: Algebra.Pattern[], graph: RDF.NamedNode }> = {};\n    for (let i = 0; i < op.patterns.length; ++i)\n    {\n        const pattern = op.patterns[i];\n        const graphName = graphs[i].value;\n        graphPatterns[graphName] = graphPatterns[graphName] ?? { patterns: [], graph: graphs[i] };\n        graphPatterns[graphName].patterns.push(pattern);\n    }\n\n    // Create graph objects for every cluster\n    let children: (Algebra.Graph | Algebra.Bgp)[] = [];\n    for (const [graphName, { patterns, graph }] of Object.entries(graphPatterns))\n    {\n        const bgp = factory.createBgp(patterns);\n        children.push(graphName === '' ? bgp : factory.createGraph(bgp, graph))\n    }\n\n    // Join the graph objects\n    let join: Algebra.Operation = children[0];\n    for (let i = 1; i < children.length; ++i)\n        join = factory.createJoin([join, children[i]]);\n\n    return join;\n}\n"]}