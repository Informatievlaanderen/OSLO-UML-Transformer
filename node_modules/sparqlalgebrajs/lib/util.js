"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const algebra_1 = require("./algebra");
const factory_1 = __importDefault(require("./factory"));
const rdf_terms_1 = require("rdf-terms");
class Util {
    /**
     * Flattens an array of arrays to an array.
     * @param arr - Array of arrays
     */
    static flatten(arr) {
        return Array.prototype.concat(...arr).filter(x => x);
    }
    /**
     * Outputs a JSON object corresponding to the input algebra-like.
     */
    static objectify(algebra) {
        if (algebra.termType) {
            if (algebra.termType === 'Quad') {
                return {
                    type: 'pattern',
                    termType: 'Quad',
                    subject: Util.objectify(algebra.subject),
                    predicate: Util.objectify(algebra.predicate),
                    object: Util.objectify(algebra.object),
                    graph: Util.objectify(algebra.graph),
                };
            }
            else {
                let result = { termType: algebra.termType, value: algebra.value };
                if (algebra.language)
                    result.language = algebra.language;
                if (algebra.datatype)
                    result.datatype = Util.objectify(algebra.datatype);
                return result;
            }
        }
        if (Array.isArray(algebra))
            return algebra.map(e => Util.objectify(e));
        if (algebra === Object(algebra)) {
            let result = {};
            for (let key of Object.keys(algebra))
                result[key] = Util.objectify(algebra[key]);
            return result;
        }
        return algebra;
    }
    /**
     * Detects all in-scope variables.
     * In practice this means iterating through the entire algebra tree, finding all variables,
     * and stopping when a project function is found.
     * @param {Operation} op - Input algebra tree.
     * @returns {Variable[]} - List of unique in-scope variables.
     */
    static inScopeVariables(op) {
        const variables = [];
        function addVariable(v) {
            if (!variables.find(v2 => v.value === v2.value))
                variables.push(v);
        }
        function recurseTerm(quad) {
            if (quad.subject.termType === 'Variable')
                addVariable(quad.subject);
            if (quad.predicate.termType === 'Variable')
                addVariable(quad.predicate);
            if (quad.object.termType === 'Variable')
                addVariable(quad.object);
            if (quad.graph.termType === 'Variable')
                addVariable(quad.graph);
            if (quad.subject.termType === 'Quad')
                recurseTerm(quad.subject);
            if (quad.predicate.termType === 'Quad')
                recurseTerm(quad.predicate);
            if (quad.object.termType === 'Quad')
                recurseTerm(quad.object);
            if (quad.graph.termType === 'Quad')
                recurseTerm(quad.graph);
        }
        // https://www.w3.org/TR/sparql11-query/#variableScope
        Util.recurseOperation(op, {
            [algebra_1.types.EXPRESSION]: (op) => {
                if (op.expressionType === algebra_1.expressionTypes.AGGREGATE && op.variable) {
                    addVariable(op.variable);
                }
                return true;
            },
            [algebra_1.types.EXTEND]: (op) => {
                addVariable(op.variable);
                return true;
            },
            [algebra_1.types.GRAPH]: (op) => {
                if (op.name.termType === 'Variable')
                    addVariable(op.name);
                return true;
            },
            [algebra_1.types.GROUP]: (op) => {
                op.variables.forEach(addVariable);
                return true;
            },
            [algebra_1.types.PATH]: (op) => {
                if (op.subject.termType === 'Variable')
                    addVariable(op.subject);
                if (op.object.termType === 'Variable')
                    addVariable(op.object);
                if (op.graph.termType === 'Variable')
                    addVariable(op.graph);
                if (op.subject.termType === 'Quad')
                    recurseTerm(op.subject);
                if (op.object.termType === 'Quad')
                    recurseTerm(op.object);
                if (op.graph.termType === 'Quad')
                    recurseTerm(op.graph);
                return true;
            },
            [algebra_1.types.PATTERN]: (op) => {
                recurseTerm(op);
                return true;
            },
            [algebra_1.types.PROJECT]: (op) => {
                op.variables.forEach(addVariable);
                return false;
            },
            [algebra_1.types.SERVICE]: (op) => {
                if (op.name.termType === 'Variable')
                    addVariable(op.name);
                return true;
            },
            [algebra_1.types.VALUES]: (op) => {
                op.variables.forEach(addVariable);
                return true;
            },
        });
        return variables;
    }
    /**
     * Recurses through the given algebra tree
     * A map of callback functions can be provided for individual Operation types to gather data.
     * The return value of those callbacks should indicate whether recursion should be applied or not.
     * Making modifications will change the original input object.
     * @param {Operation} op - The Operation to recurse on.
     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.
     */
    static recurseOperation(op, callbacks) {
        let result = op;
        let doRecursion = true;
        const callback = callbacks[op.type];
        if (callback)
            // Not sure how to get typing correct for op here
            doRecursion = callback(op);
        if (!doRecursion)
            return;
        let recurseOp = (op) => Util.recurseOperation(op, callbacks);
        switch (result.type) {
            case algebra_1.types.ALT:
                result.input.map(recurseOp);
                break;
            case algebra_1.types.ASK:
                recurseOp(result.input);
                break;
            case algebra_1.types.BGP:
                result.patterns.forEach(recurseOp);
                break;
            case algebra_1.types.CONSTRUCT:
                recurseOp(result.input);
                result.template.map(recurseOp);
                break;
            case algebra_1.types.DESCRIBE:
                recurseOp(result.input);
                break;
            case algebra_1.types.DISTINCT:
                recurseOp(result.input);
                break;
            case algebra_1.types.EXPRESSION:
                if (result.expressionType === algebra_1.expressionTypes.EXISTENCE) {
                    recurseOp(result.input);
                }
                break;
            case algebra_1.types.EXTEND:
                recurseOp(result.input);
                recurseOp(result.expression);
                break;
            case algebra_1.types.FILTER:
                recurseOp(result.input);
                recurseOp(result.expression);
                break;
            case algebra_1.types.FROM:
                recurseOp(result.input);
                break;
            case algebra_1.types.GRAPH:
                recurseOp(result.input);
                break;
            case algebra_1.types.GROUP:
                recurseOp(result.input);
                result.aggregates.forEach(recurseOp);
                break;
            case algebra_1.types.INV:
                recurseOp(result.path);
                break;
            case algebra_1.types.JOIN:
                result.input.map(recurseOp);
                break;
            case algebra_1.types.LEFT_JOIN:
                result.input.map(recurseOp);
                if (result.expression)
                    recurseOp(result.expression);
                break;
            case algebra_1.types.LINK:
                break;
            case algebra_1.types.MINUS:
                result.input.map(recurseOp);
                break;
            case algebra_1.types.NOP:
                break;
            case algebra_1.types.NPS:
                break;
            case algebra_1.types.ONE_OR_MORE_PATH:
                recurseOp(result.path);
                break;
            case algebra_1.types.ORDER_BY:
                recurseOp(result.input);
                result.expressions.forEach(recurseOp);
                break;
            case algebra_1.types.PATH:
                recurseOp(result.predicate);
                break;
            case algebra_1.types.PATTERN:
                break;
            case algebra_1.types.PROJECT:
                recurseOp(result.input);
                break;
            case algebra_1.types.REDUCED:
                recurseOp(result.input);
                break;
            case algebra_1.types.SEQ:
                result.input.map(recurseOp);
                break;
            case algebra_1.types.SERVICE:
                recurseOp(result.input);
                break;
            case algebra_1.types.SLICE:
                recurseOp(result.input);
                break;
            case algebra_1.types.UNION:
                result.input.map(recurseOp);
                break;
            case algebra_1.types.VALUES:
                break;
            case algebra_1.types.ZERO_OR_MORE_PATH:
                recurseOp(result.path);
                break;
            case algebra_1.types.ZERO_OR_ONE_PATH:
                recurseOp(result.path);
                break;
            // UPDATE operations
            case algebra_1.types.COMPOSITE_UPDATE:
                result.updates.forEach(update => recurseOp(update));
                break;
            case algebra_1.types.DELETE_INSERT:
                if (result.delete)
                    result.delete.forEach(pattern => recurseOp(pattern));
                if (result.insert)
                    result.insert.forEach(pattern => recurseOp(pattern));
                if (result.where)
                    recurseOp(result.where);
                break;
            // all of these only have graph IDs as values
            case algebra_1.types.LOAD: break;
            case algebra_1.types.CLEAR: break;
            case algebra_1.types.CREATE: break;
            case algebra_1.types.DROP: break;
            case algebra_1.types.ADD: break;
            case algebra_1.types.MOVE: break;
            case algebra_1.types.COPY: break;
            default: throw new Error(`Unknown Operation type ${result.type}`);
        }
    }
    /**
     * Creates a deep copy of the given Operation.
     * Creates shallow copies of the non-Operation values.
     * A map of callback functions can be provided for individual Operation types
     * to specifically modify the given objects before triggering recursion.
     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.
     * @param {Operation} op - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapOperation(op, callbacks, factory) {
        let result = op;
        let doRecursion = true;
        let copyMetadata = true;
        factory = factory || new factory_1.default();
        const callback = callbacks[op.type];
        if (callback) {
            // Not sure how to get typing correct for op here
            const recurseResult = callback(op, factory);
            result = recurseResult.result;
            doRecursion = recurseResult.recurse;
            copyMetadata = recurseResult.copyMetadata !== false;
        }
        let toCopyMetadata;
        if (copyMetadata && (result.metadata || op.metadata)) {
            toCopyMetadata = { ...result.metadata, ...op.metadata };
        }
        if (!doRecursion) {
            // Inherit metadata
            if (toCopyMetadata) {
                result.metadata = toCopyMetadata;
            }
            return result;
        }
        let mapOp = (op) => Util.mapOperation(op, callbacks, factory);
        // Several casts here might be wrong though depending on the callbacks output
        switch (result.type) {
            case algebra_1.types.ALT:
                result = factory.createAlt(result.input.map(mapOp));
                break;
            case algebra_1.types.ASK:
                result = factory.createAsk(mapOp(result.input));
                break;
            case algebra_1.types.BGP:
                result = factory.createBgp(result.patterns.map(mapOp));
                break;
            case algebra_1.types.CONSTRUCT:
                result = factory.createConstruct(mapOp(result.input), result.template.map(mapOp));
                break;
            case algebra_1.types.DESCRIBE:
                result = factory.createDescribe(mapOp(result.input), result.terms);
                break;
            case algebra_1.types.DISTINCT:
                result = factory.createDistinct(mapOp(result.input));
                break;
            case algebra_1.types.EXPRESSION:
                result = Util.mapExpression(result, callbacks, factory);
                break;
            case algebra_1.types.EXTEND:
                result = factory.createExtend(mapOp(result.input), result.variable, mapOp(result.expression));
                break;
            case algebra_1.types.FILTER:
                result = factory.createFilter(mapOp(result.input), mapOp(result.expression));
                break;
            case algebra_1.types.FROM:
                result = factory.createFrom(mapOp(result.input), [...result.default], [...result.named]);
                break;
            case algebra_1.types.GRAPH:
                result = factory.createGraph(mapOp(result.input), result.name);
                break;
            case algebra_1.types.GROUP:
                result = factory.createGroup(mapOp(result.input), [].concat(result.variables), result.aggregates.map(mapOp));
                break;
            case algebra_1.types.INV:
                result = factory.createInv(mapOp(result.path));
                break;
            case algebra_1.types.JOIN:
                result = factory.createJoin(result.input.map(mapOp));
                break;
            case algebra_1.types.LEFT_JOIN:
                result = factory.createLeftJoin(mapOp(result.input[0]), mapOp(result.input[1]), result.expression ? mapOp(result.expression) : undefined);
                break;
            case algebra_1.types.LINK:
                result = factory.createLink(result.iri);
                break;
            case algebra_1.types.MINUS:
                result = factory.createMinus(mapOp(result.input[0]), mapOp(result.input[1]));
                break;
            case algebra_1.types.NOP:
                result = factory.createNop();
                break;
            case algebra_1.types.NPS:
                result = factory.createNps([].concat(result.iris));
                break;
            case algebra_1.types.ONE_OR_MORE_PATH:
                result = factory.createOneOrMorePath(mapOp(result.path));
                break;
            case algebra_1.types.ORDER_BY:
                result = factory.createOrderBy(mapOp(result.input), result.expressions.map(mapOp));
                break;
            case algebra_1.types.PATH:
                result = factory.createPath(result.subject, mapOp(result.predicate), result.object, result.graph);
                break;
            case algebra_1.types.PATTERN:
                result = factory.createPattern(result.subject, result.predicate, result.object, result.graph);
                break;
            case algebra_1.types.PROJECT:
                result = factory.createProject(mapOp(result.input), [...result.variables]);
                break;
            case algebra_1.types.REDUCED:
                result = factory.createReduced(mapOp(result.input));
                break;
            case algebra_1.types.SEQ:
                result = factory.createSeq(result.input.map(mapOp));
                break;
            case algebra_1.types.SERVICE:
                result = factory.createService(mapOp(result.input), result.name, result.silent);
                break;
            case algebra_1.types.SLICE:
                result = factory.createSlice(mapOp(result.input), result.start, result.length);
                break;
            case algebra_1.types.UNION:
                result = factory.createUnion(result.input.map(mapOp));
                break;
            case algebra_1.types.VALUES:
                result = factory.createValues([].concat(result.variables), result.bindings.map(b => Object.assign({}, b)));
                break;
            case algebra_1.types.ZERO_OR_MORE_PATH:
                result = factory.createZeroOrMorePath(mapOp(result.path));
                break;
            case algebra_1.types.ZERO_OR_ONE_PATH:
                result = factory.createZeroOrOnePath(mapOp(result.path));
                break;
            // UPDATE operations
            case algebra_1.types.COMPOSITE_UPDATE:
                result = factory.createCompositeUpdate(result.updates.map(mapOp));
                break;
            case algebra_1.types.DELETE_INSERT:
                result = factory.createDeleteInsert(result.delete ? result.delete.map(mapOp) : undefined, result.insert ? result.insert.map(mapOp) : undefined, result.where ? mapOp(result.where) : undefined);
                break;
            case algebra_1.types.LOAD:
                result = factory.createLoad(result.source, result.destination, result.silent);
                break;
            case algebra_1.types.CLEAR:
                result = factory.createClear(result.source, result.silent);
                break;
            case algebra_1.types.CREATE:
                result = factory.createCreate(result.source, result.silent);
                break;
            case algebra_1.types.DROP:
                result = factory.createDrop(result.source, result.silent);
                break;
            case algebra_1.types.ADD:
                result = factory.createAdd(result.source, result.destination);
                break;
            case algebra_1.types.MOVE:
                result = factory.createMove(result.source, result.destination);
                break;
            case algebra_1.types.COPY:
                result = factory.createCopy(result.source, result.destination);
                break;
            default: throw new Error(`Unknown Operation type ${result.type}`);
        }
        // Inherit metadata
        if (toCopyMetadata) {
            result.metadata = toCopyMetadata;
        }
        return result;
    }
    /**
     * Similar to the {@link mapOperation} function but specifically for expressions.
     * Both functions call each other while copying.
     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.
     * @param {Expression} expr - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapExpression(expr, callbacks, factory) {
        let result = expr;
        let doRecursion = true;
        factory = factory || new factory_1.default();
        const callback = callbacks[expr.expressionType];
        if (callback)
            ({ result, recurse: doRecursion } = callback(expr, factory));
        if (!doRecursion)
            return result;
        let mapOp = (op) => Util.mapOperation(op, callbacks, factory);
        switch (expr.expressionType) {
            case algebra_1.expressionTypes.AGGREGATE:
                if (expr.variable) {
                    return factory.createBoundAggregate(expr.variable, expr.aggregator, mapOp(expr.expression), expr.distinct, expr.separator);
                }
                return factory.createAggregateExpression(expr.aggregator, mapOp(expr.expression), expr.distinct, expr.separator);
            case algebra_1.expressionTypes.EXISTENCE:
                return factory.createExistenceExpression(expr.not, mapOp(expr.input));
            case algebra_1.expressionTypes.NAMED:
                return factory.createNamedExpression(expr.name, expr.args.map(mapOp));
            case algebra_1.expressionTypes.OPERATOR:
                return factory.createOperatorExpression(expr.operator, expr.args.map(mapOp));
            case algebra_1.expressionTypes.TERM:
                return factory.createTermExpression(expr.term);
            case algebra_1.expressionTypes.WILDCARD:
                return factory.createWildcardExpression();
            default: throw new Error(`Unknown Expression type ${expr.expressionType}`);
        }
    }
    /**
     * Creates a deep clone of the operation.
     * This is syntactic sugar for calling {@link mapOperation} without callbacks.
     * @param {Operation} op - The operation to copy.
     * @returns {Operation} - The deep copy.
     */
    static cloneOperation(op) {
        return Util.mapOperation(op, {});
    }
    /**
     * Creates a deep clone of the expression.
     * This is syntactic sugar for calling {@link mapExpression} without callbacks.
     * @param {Expression} expr - The operation to copy.
     * @returns {Expression} - The deep copy.
     */
    static cloneExpression(expr) {
        return Util.mapExpression(expr, {});
    }
    static createUniqueVariable(label, variables, dataFactory) {
        let counter = 0;
        let labelLoop = label;
        while (variables[labelLoop]) {
            labelLoop = `${label}${counter++}`;
        }
        return dataFactory.variable(labelLoop);
    }
    // separate terms from wildcard since we handle them differently
    static isSimpleTerm(term) {
        return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'Wildcard';
    }
    static isQuad(term) {
        return term.termType === 'Quad';
    }
    static hasQuadVariables(quad) {
        return (0, rdf_terms_1.someTermsNested)(quad, term => term.termType === 'Variable');
    }
    static isWildcard(term) {
        return term.termType === 'Wildcard';
    }
}
exports.default = Util;
//# sourceMappingURL=util.js.map