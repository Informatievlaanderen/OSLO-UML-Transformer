import { Wildcard } from 'sparqljs';
import * as A from "./algebra";
import { TypedOperation, TypedExpression } from './algebra';
import Factory from "./factory";
import { BaseQuad, Variable } from '@rdfjs/types';
import * as RDF from '@rdfjs/types';
export default class Util {
    /**
     * Flattens an array of arrays to an array.
     * @param arr - Array of arrays
     */
    static flatten<T>(arr: T[][]): T[];
    /**
     * Outputs a JSON object corresponding to the input algebra-like.
     */
    static objectify(algebra: any): any;
    /**
     * Detects all in-scope variables.
     * In practice this means iterating through the entire algebra tree, finding all variables,
     * and stopping when a project function is found.
     * @param {Operation} op - Input algebra tree.
     * @returns {Variable[]} - List of unique in-scope variables.
     */
    static inScopeVariables(op: A.Operation): Variable[];
    /**
     * Recurses through the given algebra tree
     * A map of callback functions can be provided for individual Operation types to gather data.
     * The return value of those callbacks should indicate whether recursion should be applied or not.
     * Making modifications will change the original input object.
     * @param {Operation} op - The Operation to recurse on.
     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.
     */
    static recurseOperation(op: A.Operation, callbacks: {
        [T in A.types]?: (op: TypedOperation<T>) => boolean;
    }): void;
    /**
     * Creates a deep copy of the given Operation.
     * Creates shallow copies of the non-Operation values.
     * A map of callback functions can be provided for individual Operation types
     * to specifically modify the given objects before triggering recursion.
     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.
     * @param {Operation} op - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapOperation(op: A.Operation, callbacks: {
        [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult;
    } & {
        [T in A.expressionTypes]?: (expr: TypedExpression<T>, factory: Factory) => ExpressionRecurseResult;
    }, factory?: Factory): A.Operation;
    /**
     * Similar to the {@link mapOperation} function but specifically for expressions.
     * Both functions call each other while copying.
     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.
     * @param {Expression} expr - The Operation to recurse on.
     * @param callbacks - A map of required callback Operations.
     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.
     * @returns {Operation} - The copied result.
     */
    static mapExpression(expr: A.Expression, callbacks: {
        [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult;
    } & {
        [T in A.expressionTypes]?: (expr: TypedExpression<T>, factory: Factory) => ExpressionRecurseResult;
    }, factory?: Factory): A.Expression;
    /**
     * Creates a deep clone of the operation.
     * This is syntactic sugar for calling {@link mapOperation} without callbacks.
     * @param {Operation} op - The operation to copy.
     * @returns {Operation} - The deep copy.
     */
    static cloneOperation(op: A.Operation): A.Operation;
    /**
     * Creates a deep clone of the expression.
     * This is syntactic sugar for calling {@link mapExpression} without callbacks.
     * @param {Expression} expr - The operation to copy.
     * @returns {Expression} - The deep copy.
     */
    static cloneExpression(expr: A.Expression): A.Expression;
    static createUniqueVariable(label: string, variables: {
        [vLabel: string]: boolean;
    }, dataFactory: RDF.DataFactory<BaseQuad, BaseQuad>): RDF.Variable;
    static isSimpleTerm(term: any): term is RDF.Term;
    static isQuad(term: any): term is RDF.Quad;
    static hasQuadVariables(quad: RDF.Quad): boolean;
    static isWildcard(term: any): term is Wildcard;
}
/**
 * @interface RecurseResult
 * @property {Operation} result - The resulting A.Operation.
 * @property {boolean} recurse - Whether to continue with recursion.
 * @property {boolean} copyMetadata - If the metadata object should be copied. Defaults to true.
 */
export interface RecurseResult {
    result: A.Operation;
    recurse: boolean;
    copyMetadata?: boolean;
}
/**
 * @interface ExpressionRecurseResult
 * @property {Expression} result - The resulting A.Expression.
 * @property {boolean} recurse - Whether to continue with recursion.
 * @property {boolean} copyMetadata - If the metadata object should be copied. Defaults to true.
 */
export interface ExpressionRecurseResult {
    result: A.Expression;
    recurse: boolean;
    copyMetadata?: boolean;
}
