{"version":3,"file":"algebra.js","sourceRoot":"","sources":["algebra.ts"],"names":[],"mappings":";;;AAIA,IAAY,KA2CX;AA3CD,WAAY,KAAK;IACb,oBAAyB,CAAA;IACzB,oBAAyB,CAAA;IACzB,oBAAyB,CAAA;IACzB,gCAA+B,CAAA;IAC/B,8BAA8B,CAAA;IAC9B,8BAA8B,CAAA;IAC9B,kCAAgC,CAAA;IAChC,0BAA4B,CAAA;IAC5B,0BAA4B,CAAA;IAC5B,sBAA0B,CAAA;IAC1B,wBAA2B,CAAA;IAC3B,wBAA2B,CAAA;IAC3B,oBAAyB,CAAA;IACzB,sBAA0B,CAAA;IAC1B,+BAA8B,CAAA;IAC9B,sBAA0B,CAAA;IAC1B,wBAA2B,CAAA;IAC3B,oBAAyB,CAAA;IACzB,oBAAyB,CAAA;IACzB,2CAAmC,CAAA;IACnC,6BAA6B,CAAA;IAC7B,sBAA0B,CAAA;IAC1B,4BAA6B,CAAA;IAC7B,4BAA6B,CAAA;IAC7B,4BAA6B,CAAA;IAC7B,oBAAyB,CAAA;IACzB,4BAA6B,CAAA;IAC7B,wBAA2B,CAAA;IAC3B,wBAA2B,CAAA;IAC3B,0BAA4B,CAAA;IAC5B,6CAAoC,CAAA;IACpC,2CAAmC,CAAA;IAEnC,6CAAqC,CAAA;IACrC,uCAAkC,CAAA;IAClC,sBAA0B,CAAA;IAC1B,wBAA2B,CAAA;IAC3B,0BAA4B,CAAA;IAC5B,sBAA0B,CAAA;IAC1B,oBAAyB,CAAA;IACzB,sBAA0B,CAAA;IAC1B,sBAA0B,CAAA;AAC9B,CAAC,EA3CW,KAAK,GAAL,aAAK,KAAL,aAAK,QA2ChB;AAED,IAAY,eAOX;AAPD,WAAY,eAAe;IACvB,0CAAsB,CAAA;IACtB,0CAAsB,CAAA;IACtB,kCAAkB,CAAA;IAClB,wCAAqB,CAAA;IACrB,gCAAiB,CAAA;IACjB,wCAAqB,CAAA;AACzB,CAAC,EAPW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAO1B","sourcesContent":["import * as rdfjs from '@rdfjs/types';\nimport { Wildcard } from 'sparqljs';\nimport { Term } from '@rdfjs/types';\n\nexport enum types {\n    ALT=                'alt',\n    ASK=                'ask',\n    BGP=                'bgp',\n    CONSTRUCT=          'construct',\n    DESCRIBE=           'describe',\n    DISTINCT=           'distinct',\n    EXPRESSION=         'expression',\n    EXTEND=             'extend',\n    FILTER=             'filter',\n    FROM=               'from',\n    GRAPH=              'graph',\n    GROUP=              'group',\n    INV=                'inv',\n    JOIN=               'join',\n    LEFT_JOIN=          'leftjoin',\n    LINK=               'link',\n    MINUS=              'minus',\n    NOP=                'nop',\n    NPS=                'nps',\n    ONE_OR_MORE_PATH=   'OneOrMorePath',\n    ORDER_BY=           'orderby',\n    PATH=               'path',\n    PATTERN=            'pattern',\n    PROJECT=            'project',\n    REDUCED=            'reduced',\n    SEQ=                'seq',\n    SERVICE=            'service',\n    SLICE=              'slice',\n    UNION=              'union',\n    VALUES=             'values',\n    ZERO_OR_MORE_PATH=  'ZeroOrMorePath',\n    ZERO_OR_ONE_PATH=   'ZeroOrOnePath',\n\n    COMPOSITE_UPDATE=   'compositeupdate',\n    DELETE_INSERT=      'deleteinsert',\n    LOAD=               'load',\n    CLEAR=              'clear',\n    CREATE=             'create',\n    DROP=               'drop',\n    ADD=                'add',\n    MOVE=               'move',\n    COPY=               'copy',\n}\n\nexport enum expressionTypes {\n    AGGREGATE= 'aggregate',\n    EXISTENCE= 'existence',\n    NAMED=     'named',\n    OPERATOR=  'operator',\n    TERM=      'term',\n    WILDCARD=  'wildcard',\n}\n\n// Helper type\ntype valueOf<T> = T[keyof T];\n\n// ----------------------- OPERATIONS -----------------------\nexport type Operation =\n  Ask | Expression | Bgp | Construct | Describe | Distinct | Extend | From | Filter | Graph | Group | Join | LeftJoin |\n  Minus | Nop | OrderBy | Path | Pattern | Project | PropertyPathSymbol | Reduced | Service | Slice | Union | Values |\n  Update;\n\nexport type Expression = AggregateExpression | GroupConcatExpression | ExistenceExpression | NamedExpression |\n  OperatorExpression | TermExpression | WildcardExpression | BoundAggregate;\n\nexport type PropertyPathSymbol = Alt | Inv | Link | Nps | OneOrMorePath | Seq | ZeroOrMorePath | ZeroOrOnePath;\n\nexport type Update = CompositeUpdate | DeleteInsert | Load | Clear | Create | Drop | Add | Move | Copy | Nop;\n\n// Returns the correct type based on the type enum\nexport type TypedOperation<T extends types> = Extract<Operation, { type: T }>;\nexport type TypedExpression<T extends expressionTypes> = Extract<Expression, { expressionType: T }>;\n// ----------------------- ABSTRACTS -----------------------\n\nexport interface BaseOperation\n{\n    [key:string]: any;\n    metadata?: Record<string, unknown>;\n    type: types;\n}\n\nexport interface Single extends BaseOperation\n{\n    input: Operation;\n}\n\nexport interface Multi extends BaseOperation\n{\n    input: Operation[];\n}\n\nexport interface Double extends Multi\n{\n    input: [Operation, Operation];\n}\n\nexport interface BaseExpression extends BaseOperation\n{\n    type: types.EXPRESSION;\n    expressionType: expressionTypes;\n}\n\nexport interface AggregateExpression extends BaseExpression\n{\n    expressionType: expressionTypes.AGGREGATE,\n    aggregator: 'avg' | 'count' | 'group_concat' | 'max' | 'min' | 'sample' | 'sum';\n    distinct: boolean;\n    expression: Expression;\n}\n\nexport interface GroupConcatExpression extends AggregateExpression\n{\n    aggregator: 'group_concat';\n    separator?: string;\n}\n\n\nexport interface ExistenceExpression extends BaseExpression\n{\n    expressionType: expressionTypes.EXISTENCE;\n    not: boolean;\n    input: Operation;\n}\n\nexport interface NamedExpression extends BaseExpression\n{\n    expressionType: expressionTypes.NAMED;\n    name: rdfjs.NamedNode;\n    args: Expression[];\n}\n\nexport interface OperatorExpression extends BaseExpression\n{\n    expressionType: expressionTypes.OPERATOR;\n    operator: string;\n    args: Expression[];\n}\n\nexport interface TermExpression extends BaseExpression\n{\n    expressionType: expressionTypes.TERM;\n    term: Term;\n}\n\nexport interface WildcardExpression extends BaseExpression\n{\n    expressionType: expressionTypes.WILDCARD,\n    wildcard: Wildcard;\n}\n\n\n// TODO: currently not differentiating between lists and multisets\n\n// ----------------------- ACTUAL FUNCTIONS -----------------------\n\n\nexport interface Alt extends Multi\n{\n    type: types.ALT;\n    input: PropertyPathSymbol[];\n}\n\nexport interface Ask extends Single\n{\n    type: types.ASK;\n}\n\n// also an expression\nexport interface BoundAggregate extends AggregateExpression\n{\n    variable: rdfjs.Variable;\n}\n\nexport interface Bgp extends BaseOperation\n{\n    type: types.BGP;\n    patterns: Pattern[];\n}\n\nexport interface Construct extends Single\n{\n    type: types.CONSTRUCT;\n    template: Pattern[];\n}\n\nexport interface Describe extends Single\n{\n    type: types.DESCRIBE;\n    terms: (rdfjs.Variable | rdfjs.NamedNode)[];\n}\n\nexport interface Distinct extends Single\n{\n    type: types.DISTINCT;\n}\n\nexport interface Extend extends Single\n{\n    type: types.EXTEND;\n    variable: rdfjs.Variable;\n    expression: Expression;\n}\n\nexport interface From extends Single\n{\n    type: types.FROM;\n    default: rdfjs.NamedNode[];\n    named: rdfjs.NamedNode[];\n}\n\nexport interface Filter extends Single\n{\n    type: types.FILTER;\n    expression: Expression;\n}\n\nexport interface Graph extends Single\n{\n    type: types.GRAPH;\n    name: rdfjs.Variable | rdfjs.NamedNode;\n}\n\nexport interface Group extends Single\n{\n    type: types.GROUP;\n    variables: rdfjs.Variable[];\n    aggregates: BoundAggregate[];\n}\n\nexport interface Inv extends BaseOperation\n{\n    type: types.INV;\n    path: PropertyPathSymbol;\n}\n\nexport interface Join extends Multi\n{\n    type: types.JOIN\n}\n\nexport interface LeftJoin extends Double\n{\n    type: types.LEFT_JOIN;\n    expression?: Expression;\n}\n\nexport interface Link extends BaseOperation\n{\n    type: types.LINK;\n    iri: rdfjs.NamedNode;\n}\n\nexport interface Minus extends Double\n{\n    type: types.MINUS;\n}\n\nexport interface Nop extends BaseOperation\n{\n    type: types.NOP;\n}\n\nexport interface Nps extends BaseOperation\n{\n    type: types.NPS;\n    iris: rdfjs.NamedNode[];\n}\n\nexport interface OneOrMorePath extends BaseOperation\n{\n    type: types.ONE_OR_MORE_PATH;\n    path: PropertyPathSymbol;\n}\n\nexport interface OrderBy extends Single\n{\n    type: types.ORDER_BY;\n    expressions: Expression[];\n}\n\nexport interface Path extends BaseOperation\n{\n    type: types.PATH;\n    subject: rdfjs.Term;\n    predicate: PropertyPathSymbol;\n    object: rdfjs.Term;\n    graph: rdfjs.Term;\n}\n\nexport interface Pattern extends BaseOperation, rdfjs.BaseQuad\n{\n    type: types.PATTERN;\n}\n\nexport interface Project extends Single\n{\n    type: types.PROJECT;\n    variables: rdfjs.Variable[];\n}\n\nexport interface Reduced extends Single\n{\n    type: types.REDUCED;\n}\n\nexport interface Seq extends Multi\n{\n    type: types.SEQ;\n    input: PropertyPathSymbol[];\n}\n\nexport interface Service extends Single\n{\n    type: types.SERVICE;\n    name: rdfjs.Variable | rdfjs.NamedNode;\n    silent: boolean;\n}\n\nexport interface Slice extends Single\n{\n    type: types.SLICE;\n    start: number;\n    length?: number;\n}\n\nexport interface Union extends Multi\n{\n    type: types.UNION;\n}\n\nexport interface Values extends BaseOperation\n{\n    type: types.VALUES;\n    variables: rdfjs.Variable[];\n    bindings: {[key: string]: rdfjs.Literal | rdfjs.NamedNode}[];\n}\n\nexport interface ZeroOrMorePath extends BaseOperation\n{\n    type: types.ZERO_OR_MORE_PATH;\n    path: PropertyPathSymbol;\n}\n\nexport interface ZeroOrOnePath extends BaseOperation\n{\n    type: types.ZERO_OR_ONE_PATH;\n    path: PropertyPathSymbol;\n}\n\n// ----------------------- UPDATE FUNCTIONS -----------------------\nexport interface CompositeUpdate extends BaseOperation {\n    type: types.COMPOSITE_UPDATE;\n    updates: Update[];\n}\n\nexport interface DeleteInsert extends BaseOperation\n{\n    type: types.DELETE_INSERT;\n    delete?: Pattern[];\n    insert?: Pattern[];\n    where?: Operation;\n}\n\nexport interface UpdateGraph extends BaseOperation\n{\n    silent?: boolean;\n}\n\nexport interface Load extends UpdateGraph\n{\n    type: types.LOAD;\n    source: rdfjs.NamedNode;\n    destination?: rdfjs.NamedNode;\n}\n\nexport interface Clear extends UpdateGraph\n{\n    type: types.CLEAR;\n    source: 'DEFAULT' | 'NAMED' | 'ALL' | rdfjs.NamedNode;\n}\n\nexport interface Create extends UpdateGraph\n{\n    type: types.CREATE;\n    source: rdfjs.NamedNode;\n}\n\nexport interface Drop extends UpdateGraph\n{\n    type: types.DROP;\n    source: 'DEFAULT' | 'NAMED' | 'ALL' | rdfjs.NamedNode;\n}\n\nexport interface UpdateGraphShortcut extends UpdateGraph\n{\n    source: 'DEFAULT' | rdfjs.NamedNode;\n    destination: 'DEFAULT' | rdfjs.NamedNode;\n}\n\nexport interface Add extends UpdateGraphShortcut\n{\n    type: types.ADD;\n}\n\nexport interface Move extends UpdateGraphShortcut\n{\n    type: types.MOVE;\n}\n\nexport interface Copy extends UpdateGraphShortcut\n{\n    type: types.COPY;\n}\n"]}