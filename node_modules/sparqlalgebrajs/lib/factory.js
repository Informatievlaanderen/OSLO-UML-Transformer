"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const A = __importStar(require("./algebra"));
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const sparqljs_1 = require("sparqljs");
class Factory {
    constructor(dataFactory) {
        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
        this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');
    }
    createAlt(input, flatten = true) { return this.flattenMulti({ type: A.types.ALT, input }, flatten); }
    createAsk(input) { return { type: A.types.ASK, input }; }
    createBoundAggregate(variable, aggregate, expression, distinct, separator) {
        const result = this.createAggregateExpression(aggregate, expression, distinct, separator);
        result.variable = variable;
        return result;
    }
    createBgp(patterns) { return { type: A.types.BGP, patterns }; }
    createConstruct(input, template) { return { type: A.types.CONSTRUCT, input, template }; }
    createDescribe(input, terms) { return { type: A.types.DESCRIBE, input, terms }; }
    createDistinct(input) { return { type: A.types.DISTINCT, input }; }
    createExtend(input, variable, expression) { return { type: A.types.EXTEND, input, variable, expression }; }
    createFrom(input, def, named) { return { type: A.types.FROM, input, default: def, named }; }
    createFilter(input, expression) { return { type: A.types.FILTER, input, expression }; }
    createGraph(input, name) { return { type: A.types.GRAPH, input, name }; }
    createGroup(input, variables, aggregates) { return { type: A.types.GROUP, input, variables, aggregates }; }
    createInv(path) { return { type: A.types.INV, path }; }
    createJoin(input, flatten = true) { return this.flattenMulti({ type: A.types.JOIN, input }, flatten); }
    createLeftJoin(left, right, expression) {
        if (expression)
            return { type: A.types.LEFT_JOIN, input: [left, right], expression };
        return { type: A.types.LEFT_JOIN, input: [left, right] };
    }
    createLink(iri) { return { type: A.types.LINK, iri }; }
    createMinus(left, right) { return { type: A.types.MINUS, input: [left, right] }; }
    createNop() { return { type: A.types.NOP }; }
    createNps(iris) { return { type: A.types.NPS, iris }; }
    createOneOrMorePath(path) { return { type: A.types.ONE_OR_MORE_PATH, path }; }
    createOrderBy(input, expressions) { return { type: A.types.ORDER_BY, input, expressions }; }
    createPath(subject, predicate, object, graph) {
        if (graph)
            return { type: A.types.PATH, subject, predicate, object, graph };
        return { type: A.types.PATH, subject, predicate, object, graph: this.dataFactory.defaultGraph() };
    }
    createPattern(subject, predicate, object, graph) {
        const pattern = this.dataFactory.quad(subject, predicate, object, graph);
        pattern.type = A.types.PATTERN;
        return pattern;
    }
    createProject(input, variables) { return { type: A.types.PROJECT, input, variables }; }
    createReduced(input) { return { type: A.types.REDUCED, input }; }
    createSeq(input, flatten = true) { return this.flattenMulti({ type: A.types.SEQ, input }, flatten); }
    createService(input, name, silent) { return { type: A.types.SERVICE, input, name, silent: Boolean(silent) }; }
    createSlice(input, start, length) {
        start = start || 0;
        if (length !== undefined)
            return { type: A.types.SLICE, input, start, length };
        return { type: A.types.SLICE, input, start };
    }
    createUnion(input, flatten = true) { return this.flattenMulti({ type: A.types.UNION, input }, flatten); }
    createValues(variables, bindings) { return { type: A.types.VALUES, variables, bindings }; }
    createZeroOrMorePath(path) { return { type: A.types.ZERO_OR_MORE_PATH, path }; }
    createZeroOrOnePath(path) { return { type: A.types.ZERO_OR_ONE_PATH, path }; }
    createAggregateExpression(aggregator, expression, distinct, separator) {
        if (separator)
            return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.AGGREGATE, aggregator: aggregator, expression, separator, distinct };
        return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.AGGREGATE, aggregator: aggregator, expression, distinct };
    }
    createExistenceExpression(not, input) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.EXISTENCE, not, input }; }
    createNamedExpression(name, args) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.NAMED, name, args }; }
    createOperatorExpression(operator, args) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.OPERATOR, operator, args }; }
    createTermExpression(term) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.TERM, term }; }
    createWildcardExpression() { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.WILDCARD, wildcard: new sparqljs_1.Wildcard() }; }
    createTerm(str) {
        if (str[0] === '$') {
            str = str.replace('$', '?');
        }
        return (0, rdf_string_1.stringToTerm)(str, this.dataFactory);
    }
    // Update functions
    createCompositeUpdate(updates) { return { type: A.types.COMPOSITE_UPDATE, updates }; }
    createDeleteInsert(deleteQuads, insertQuads, where) {
        const result = { type: A.types.DELETE_INSERT };
        if (deleteQuads)
            result.delete = deleteQuads;
        if (insertQuads)
            result.insert = insertQuads;
        if (where)
            result.where = where;
        return result;
    }
    createLoad(source, destination, silent) {
        const result = { type: A.types.LOAD, source };
        if (destination)
            result.destination = destination;
        return this.addSilent(result, Boolean(silent));
    }
    createClear(source, silent) {
        return this.addSilent({ type: A.types.CLEAR, source }, Boolean(silent));
    }
    createCreate(source, silent) {
        return this.addSilent({ type: A.types.CREATE, source }, Boolean(silent));
    }
    createDrop(source, silent) {
        return this.addSilent({ type: A.types.DROP, source }, Boolean(silent));
    }
    createAdd(source, destination, silent) {
        return this.addSilent({ type: A.types.ADD, source, destination }, Boolean(silent));
    }
    createMove(source, destination, silent) {
        return this.addSilent({ type: A.types.MOVE, source, destination }, Boolean(silent));
    }
    createCopy(source, destination, silent) {
        return this.addSilent({ type: A.types.COPY, source, destination }, Boolean(silent));
    }
    addSilent(input, silent) {
        if (silent)
            input.silent = silent;
        return input;
    }
    flattenMulti(input, flatten) {
        if (!flatten) {
            return input;
        }
        const type = input.type;
        const children = input.input;
        let newChildren = [];
        for (const child of children) {
            if (child.type === type) {
                newChildren.push(...child.input);
            }
            else {
                newChildren.push(child);
            }
        }
        input.input = newChildren;
        return input;
    }
}
exports.default = Factory;
//# sourceMappingURL=factory.js.map