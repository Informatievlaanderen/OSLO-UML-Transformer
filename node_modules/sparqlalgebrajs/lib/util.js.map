{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":";;;;;AAEA,uCAA2G;AAC3G,wDAAgC;AAEhC,yCAA4C;AAI5C,MAAqB,IAAI;IAErB;;;OAGG;IACI,MAAM,CAAC,OAAO,CAAI,GAAU;QAE/B,OAAO,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,SAAS,CAAE,OAAY;QAEjC,IAAI,OAAO,CAAC,QAAQ,EACpB;YACI,IAAI,OAAO,CAAC,QAAQ,KAAK,MAAM,EAAE;gBAC7B,OAAO;oBACH,IAAI,EAAE,SAAS;oBACf,QAAQ,EAAE,MAAM;oBAChB,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC;oBACxC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC;oBAC5C,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC;oBACtC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC;iBACvC,CAAA;aACJ;iBAAM;gBACH,IAAI,MAAM,GAAQ,EAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAC,CAAC;gBACrE,IAAI,OAAO,CAAC,QAAQ;oBAChB,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBACvC,IAAI,OAAO,CAAC,QAAQ;oBAChB,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;gBACvD,OAAO,MAAM,CAAC;aACjB;SACJ;QACD,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;YACtB,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,OAAO,KAAK,MAAM,CAAC,OAAO,CAAC,EAC/B;YACI,IAAI,MAAM,GAAQ,EAAE,CAAC;YACrB,KAAK,IAAI,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;gBAChC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/C,OAAO,MAAM,CAAC;SACjB;QACD,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,gBAAgB,CAAC,EAAe;QAE1C,MAAM,SAAS,GAAe,EAAE,CAAC;QAEjC,SAAS,WAAW,CAAC,CAAW;YAE5B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC,KAAK,CAAC;gBAC3C,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1B,CAAC;QAED,SAAS,WAAW,CAAC,IAAc;YAC/B,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,UAAU;gBACpC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,KAAK,UAAU;gBACtC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAChC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,KAAK,UAAU;gBACnC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,UAAU;gBAClC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,MAAM;gBAChC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,KAAK,MAAM;gBAClC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAChC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,KAAK,MAAM;gBAC/B,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7B,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,MAAM;gBAC9B,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC;QAED,sDAAsD;QACtD,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE;YACtB,CAAC,eAAK,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEvB,IAAI,EAAE,CAAC,cAAc,KAAK,yBAAe,CAAC,SAAS,IAAI,EAAE,CAAC,QAAQ,EAClE;oBACI,WAAW,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;iBAC5B;gBACD,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEnB,WAAW,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;gBACzB,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAElB,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU;oBAC/B,WAAW,CAAY,EAAE,CAAC,IAAI,CAAC,CAAC;gBACpC,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAElB,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gBAClC,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEjB,IAAI,EAAE,CAAC,OAAO,CAAC,QAAQ,KAAK,UAAU;oBAClC,WAAW,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;gBAC5B,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,KAAK,UAAU;oBACjC,WAAW,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;gBAC3B,IAAI,EAAE,CAAC,KAAK,CAAC,QAAQ,KAAK,UAAU;oBAChC,WAAW,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;gBAC1B,IAAI,EAAE,CAAC,OAAO,CAAC,QAAQ,KAAK,MAAM;oBAC9B,WAAW,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;gBAC5B,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,KAAK,MAAM;oBAC7B,WAAW,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;gBAC3B,IAAI,EAAE,CAAC,KAAK,CAAC,QAAQ,KAAK,MAAM;oBAC5B,WAAW,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;gBAC1B,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEpB,WAAW,CAAC,EAAE,CAAC,CAAC;gBAChB,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEpB,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gBAClC,OAAO,KAAK,CAAC;YACjB,CAAC;YACD,CAAC,eAAK,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEpB,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU;oBAC/B,WAAW,CAAY,EAAE,CAAC,IAAI,CAAC,CAAC;gBACpC,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,CAAC,eAAK,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;gBAEnB,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gBAClC,OAAO,IAAI,CAAC;YAChB,CAAC;SACJ,CAAC,CAAC;QAEH,OAAO,SAAS,CAAC;IACrB,CAAC;IACD;;;;;;;OAOG;IACI,MAAM,CAAC,gBAAgB,CAAC,EAAe,EAAE,SAAkE;QAE9G,IAAI,MAAM,GAAgB,EAAE,CAAC;QAC7B,IAAI,WAAW,GAAG,IAAI,CAAC;QAEvB,MAAM,QAAQ,GAAG,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,QAAQ;YACR,iDAAiD;YACjD,WAAW,GAAG,QAAQ,CAAC,EAAS,CAAC,CAAC;QAEtC,IAAI,CAAC,WAAW;YACZ,OAAO;QAEX,IAAI,SAAS,GAAG,CAAC,EAAe,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;QAE1E,QAAQ,MAAM,CAAC,IAAI,EACnB;YACI,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACX,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACT,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;gBACnC,MAAM;YACV,KAAK,eAAK,CAAC,SAAS;gBAChB,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC/B,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,UAAU;gBACjB,IAAI,MAAM,CAAC,cAAc,KAAK,yBAAe,CAAC,SAAS,EACvD;oBACI,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAC3B;gBACD,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBAC7B,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBAC7B,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;gBACrC,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACvB,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,SAAS;gBAChB,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,IAAI,MAAM,CAAC,UAAU;oBAAE,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBACpD,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM;YACV,KAAK,eAAK,CAAC,gBAAgB;gBACvB,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACvB,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;gBACtC,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACxB,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5B,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,MAAM;YACV,KAAK,eAAK,CAAC,iBAAiB;gBACxB,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACvB,MAAM;YACV,KAAK,eAAK,CAAC,gBAAgB;gBACvB,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACvB,MAAM;YACV,oBAAoB;YACpB,KAAK,eAAK,CAAC,gBAAgB;gBACvB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;gBACpD,MAAM;YACV,KAAK,eAAK,CAAC,aAAa;gBACpB,IAAI,MAAM,CAAC,MAAM;oBACb,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;gBACzD,IAAI,MAAM,CAAC,MAAM;oBACb,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;gBACzD,IAAI,MAAM,CAAC,KAAK;oBACZ,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC5B,MAAM;YACV,6CAA6C;YAC7C,KAAK,eAAK,CAAC,IAAI,CAAC,CAAC,MAAM;YACvB,KAAK,eAAK,CAAC,KAAK,CAAC,CAAC,MAAM;YACxB,KAAK,eAAK,CAAC,MAAM,CAAC,CAAC,MAAM;YACzB,KAAK,eAAK,CAAC,IAAI,CAAC,CAAC,MAAM;YACvB,KAAK,eAAK,CAAC,GAAG,CAAC,CAAC,MAAM;YACtB,KAAK,eAAK,CAAC,IAAI,CAAC,CAAC,MAAM;YACvB,KAAK,eAAK,CAAC,IAAI,CAAC,CAAC,MAAM;YACvB,OAAO,CAAC,CAAC,MAAM,IAAI,KAAK,CAAC,0BAA2B,MAAc,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9E;IACL,CAAC;IAED;;;;;;;;;;OAUG;IACI,MAAM,CAAC,YAAY,CAAC,EAAe,EACxC,SAC0G,EAC1G,OAAiB;QAEf,IAAI,MAAM,GAAgB,EAAE,CAAC;QAC7B,IAAI,WAAW,GAAG,IAAI,CAAC;QACvB,IAAI,YAAY,GAAG,IAAI,CAAC;QAExB,OAAO,GAAG,OAAO,IAAI,IAAI,iBAAO,EAAE,CAAC;QAEnC,MAAM,QAAQ,GAAG,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,QAAQ,EAAE;YACV,iDAAiD;YACjD,MAAM,aAAa,GAAG,QAAQ,CAAC,EAAS,EAAE,OAAO,CAAC,CAAC;YACnD,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;YAC9B,WAAW,GAAG,aAAa,CAAC,OAAO,CAAC;YACpC,YAAY,GAAG,aAAa,CAAC,YAAY,KAAK,KAAK,CAAC;SACvD;QAED,IAAI,cAAc,CAAC;QACnB,IAAI,YAAY,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,EAAE;YAClD,cAAc,GAAG,EAAE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC;SAC3D;QAED,IAAI,CAAC,WAAW,EAAE;YACd,mBAAmB;YACnB,IAAI,cAAc,EAAE;gBAChB,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC;aACpC;YAED,OAAO,MAAM,CAAC;SACjB;QAED,IAAI,KAAK,GAAG,CAAC,EAAe,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAE3E,6EAA6E;QAC7E,QAAQ,MAAM,CAAC,IAAI,EACnB;YACI,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAA0B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC7E,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBAChD,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAAe,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBACrE,MAAM;YACV,KAAK,eAAK,CAAC,SAAS;gBAChB,MAAM,GAAG,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAgB,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBAChG,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;gBACnE,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBACrD,MAAM;YACV,KAAK,eAAK,CAAC,UAAU;gBACjB,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;gBACxD,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,QAAQ,EAAiB,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC7G,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAiB,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC5F,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAE,GAAG,MAAM,CAAC,OAAO,CAAE,EAAE,CAAE,GAAG,MAAM,CAAC,KAAK,CAAE,CAAC,CAAC;gBAC7F,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;gBAC/D,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CACxB,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EACF,EAAG,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,EACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBACvD,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAAwB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACtE,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBACrD,MAAM;YACV,KAAK,eAAK,CAAC,SAAS;gBAChB,MAAM,GAAG,OAAO,CAAC,cAAc,CAC3B,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EACtB,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EACxB,MAAM,CAAC,UAAU,CAAC,CAAC,CAAgB,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;gBAC3E,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACxC,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7E,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;gBAC7B,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAAmB,EAAG,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACtE,MAAM;YACV,KAAK,eAAK,CAAC,gBAAgB;gBACvB,MAAM,GAAG,OAAO,CAAC,mBAAmB,CAAwB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChF,MAAM;YACV,KAAK,eAAK,CAAC,QAAQ;gBACf,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAmB,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBACpG,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAyB,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;gBACzH,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC9F,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAE,GAAG,MAAM,CAAC,SAAS,CAAE,CAAC,CAAC;gBAC7E,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBACpD,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAA0B,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC7E,MAAM;YACV,KAAK,eAAK,CAAC,OAAO;gBACd,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAChF,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC/E,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBACtD,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,MAAM,GAAG,OAAO,CAAC,YAAY,CAAkB,EAAG,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7H,MAAM;YACV,KAAK,eAAK,CAAC,iBAAiB;gBACxB,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAwB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACjF,MAAM;YACV,KAAK,eAAK,CAAC,gBAAgB;gBACvB,MAAM,GAAG,OAAO,CAAC,mBAAmB,CAAwB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAChF,MAAM;YACZ,oBAAoB;YAClB,KAAK,eAAK,CAAC,gBAAgB;gBACvB,MAAM,GAAG,OAAO,CAAC,qBAAqB,CAAc,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC/E,MAAM;YACV,KAAK,eAAK,CAAC,aAAa;gBACpB,MAAM,GAAG,OAAO,CAAC,kBAAkB,CACjC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAe,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,EAClE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAe,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,EAClE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAC7C,CAAC;gBACJ,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC9E,MAAM;YACV,KAAK,eAAK,CAAC,KAAK;gBACZ,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC3D,MAAM;YACV,KAAK,eAAK,CAAC,MAAM;gBACb,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC5D,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC1D,MAAM;YACV,KAAK,eAAK,CAAC,GAAG;gBACV,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;gBAC9D,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;gBAC/D,MAAM;YACV,KAAK,eAAK,CAAC,IAAI;gBACX,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;gBAC/D,MAAM;YACV,OAAO,CAAC,CAAC,MAAM,IAAI,KAAK,CAAC,0BAA2B,MAAc,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9E;QAED,mBAAmB;QACnB,IAAI,cAAc,EAAE;YAChB,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC;SACpC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,aAAa,CAAC,IAAkB,EAC5C,SAC0G,EAC1G,OAAiB;QAEf,IAAI,MAAM,GAAiB,IAAI,CAAC;QAChC,IAAI,WAAW,GAAG,IAAI,CAAC;QAEvB,OAAO,GAAG,OAAO,IAAI,IAAI,iBAAO,EAAE,CAAC;QAEnC,MAAM,QAAQ,GAAG,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAChD,IAAI,QAAQ;YACR,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,QAAQ,CAAC,IAAW,EAAE,OAAO,CAAC,CAAC,CAAC;QAExE,IAAI,CAAC,WAAW;YACZ,OAAO,MAAM,CAAC;QAElB,IAAI,KAAK,GAAG,CAAC,EAAe,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAE3E,QAAO,IAAI,CAAC,cAAc,EAC1B;YACI,KAAK,yBAAe,CAAC,SAAS;gBAC1B,IAAI,IAAI,CAAC,QAAQ,EACjB;oBACI,OAAO,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAe,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;iBAC3I;gBACD,OAAO,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,UAAU,EAAe,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAClI,KAAK,yBAAe,CAAC,SAAS;gBAC1B,OAAO,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAC1E,KAAK,yBAAe,CAAC,KAAK;gBACtB,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAmB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAC3F,KAAK,yBAAe,CAAC,QAAQ;gBACzB,OAAO,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,QAAQ,EAAmB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAClG,KAAK,yBAAe,CAAC,IAAI;gBACrB,OAAO,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACnD,KAAK,yBAAe,CAAC,QAAQ;gBACzB,OAAO,OAAO,CAAC,wBAAwB,EAAE,CAAC;YAC9C,OAAO,CAAC,CAAC,MAAM,IAAI,KAAK,CAAC,2BAA4B,IAAY,CAAC,cAAc,EAAE,CAAC,CAAC;SACvF;IACL,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,cAAc,CAAC,EAAe;QACxC,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IACrC,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,eAAe,CAAC,IAAkB;QAC5C,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IACxC,CAAC;IAEM,MAAM,CAAC,oBAAoB,CAAC,KAAa,EAAE,SAAsC,EAAE,WAAgD;QACtI,IAAI,OAAO,GAAW,CAAC,CAAC;QACxB,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,OAAO,SAAS,CAAC,SAAS,CAAC,EAAE;YACzB,SAAS,GAAG,GAAG,KAAK,GAAG,OAAO,EAAE,EAAE,CAAC;SACtC;QACD,OAAO,WAAW,CAAC,QAAS,CAAC,SAAS,CAAC,CAAC;IAC5C,CAAC;IAED,gEAAgE;IACzD,MAAM,CAAC,YAAY,CAAC,IAAS;QAChC,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;IACnG,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,IAAS;QAC1B,OAAO,IAAI,CAAC,QAAQ,KAAK,MAAM,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAAC,IAAc;QACzC,OAAO,IAAA,2BAAe,EAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC,CAAC;IACvE,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,IAAS;QAC9B,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;IACxC,CAAC;CACJ;AA9kBD,uBA8kBC","sourcesContent":["import { Wildcard } from 'sparqljs';\nimport * as A from \"./algebra\";\nimport { Expression, Operation, expressionTypes, types, TypedOperation, TypedExpression } from './algebra';\nimport Factory from \"./factory\";\nimport { BaseQuad, Variable } from '@rdfjs/types';\nimport { someTermsNested } from 'rdf-terms';\nimport * as RDF from '@rdfjs/types'\n\n\nexport default class Util\n{\n    /**\n     * Flattens an array of arrays to an array.\n     * @param arr - Array of arrays\n     */\n    public static flatten<T>(arr: T[][]): T[]\n    {\n        return Array.prototype.concat(...arr).filter(x => x);\n    }\n\n    /**\n     * Outputs a JSON object corresponding to the input algebra-like.\n     */\n    public static objectify (algebra: any): any\n    {\n        if (algebra.termType)\n        {\n            if (algebra.termType === 'Quad') {\n                return {\n                    type: 'pattern',\n                    termType: 'Quad',\n                    subject: Util.objectify(algebra.subject),\n                    predicate: Util.objectify(algebra.predicate),\n                    object: Util.objectify(algebra.object),\n                    graph: Util.objectify(algebra.graph),\n                }\n            } else {\n                let result: any = {termType: algebra.termType, value: algebra.value};\n                if (algebra.language)\n                    result.language = algebra.language;\n                if (algebra.datatype)\n                    result.datatype = Util.objectify(algebra.datatype);\n                return result;\n            }\n        }\n        if (Array.isArray(algebra))\n            return algebra.map(e => Util.objectify(e));\n        if (algebra === Object(algebra))\n        {\n            let result: any = {};\n            for (let key of Object.keys(algebra))\n                result[key] = Util.objectify(algebra[key]);\n            return result;\n        }\n        return algebra;\n    }\n\n    /**\n     * Detects all in-scope variables.\n     * In practice this means iterating through the entire algebra tree, finding all variables,\n     * and stopping when a project function is found.\n     * @param {Operation} op - Input algebra tree.\n     * @returns {Variable[]} - List of unique in-scope variables.\n     */\n    public static inScopeVariables(op: A.Operation): Variable[]\n    {\n        const variables: Variable[] = [];\n\n        function addVariable(v: Variable)\n        {\n            if (!variables.find(v2 => v.value === v2.value))\n                variables.push(v);\n        }\n\n        function recurseTerm(quad: BaseQuad) {\n            if (quad.subject.termType === 'Variable')\n                addVariable(quad.subject);\n            if (quad.predicate.termType === 'Variable')\n                addVariable(quad.predicate);\n            if (quad.object.termType === 'Variable')\n                addVariable(quad.object);\n            if (quad.graph.termType === 'Variable')\n                addVariable(quad.graph);\n            if (quad.subject.termType === 'Quad')\n                recurseTerm(quad.subject);\n            if (quad.predicate.termType === 'Quad')\n                recurseTerm(quad.predicate);\n            if (quad.object.termType === 'Quad')\n                recurseTerm(quad.object);\n            if (quad.graph.termType === 'Quad')\n                recurseTerm(quad.graph);\n        }\n\n        // https://www.w3.org/TR/sparql11-query/#variableScope\n        Util.recurseOperation(op, {\n            [types.EXPRESSION]: (op) =>\n            {\n                if (op.expressionType === expressionTypes.AGGREGATE && op.variable)\n                {\n                    addVariable(op.variable);\n                }\n                return true;\n            },\n            [types.EXTEND]: (op) =>\n            {\n                addVariable(op.variable);\n                return true;\n            },\n            [types.GRAPH]: (op) =>\n            {\n                if (op.name.termType === 'Variable')\n                    addVariable(<Variable> op.name);\n                return true;\n            },\n            [types.GROUP]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return true;\n            },\n            [types.PATH]: (op) =>\n            {\n                if (op.subject.termType === 'Variable')\n                    addVariable(op.subject);\n                if (op.object.termType === 'Variable')\n                    addVariable(op.object);\n                if (op.graph.termType === 'Variable')\n                    addVariable(op.graph);\n                if (op.subject.termType === 'Quad')\n                    recurseTerm(op.subject);\n                if (op.object.termType === 'Quad')\n                    recurseTerm(op.object);\n                if (op.graph.termType === 'Quad')\n                    recurseTerm(op.graph);\n                return true;\n            },\n            [types.PATTERN]: (op) =>\n            {\n                recurseTerm(op);\n                return true;\n            },\n            [types.PROJECT]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return false;\n            },\n            [types.SERVICE]: (op) =>\n            {\n                if (op.name.termType === 'Variable')\n                    addVariable(<Variable> op.name);\n                return true;\n            },\n            [types.VALUES]: (op) =>\n            {\n                op.variables.forEach(addVariable);\n                return true;\n            },\n        });\n\n        return variables;\n    }\n    /**\n     * Recurses through the given algebra tree\n     * A map of callback functions can be provided for individual Operation types to gather data.\n     * The return value of those callbacks should indicate whether recursion should be applied or not.\n     * Making modifications will change the original input object.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.\n     */\n    public static recurseOperation(op: A.Operation, callbacks:{ [T in A.types]?: (op: TypedOperation<T>,) => boolean }): void\n    {\n        let result: A.Operation = op;\n        let doRecursion = true;\n\n        const callback = callbacks[op.type];\n        if (callback)\n            // Not sure how to get typing correct for op here\n            doRecursion = callback(op as any);\n\n        if (!doRecursion)\n            return;\n\n        let recurseOp = (op: A.Operation) => Util.recurseOperation(op, callbacks);\n\n        switch (result.type)\n        {\n            case types.ALT:\n                result.input.map(recurseOp);\n                break;\n            case types.ASK:\n               recurseOp(result.input);\n               break;\n            case types.BGP:\n                result.patterns.forEach(recurseOp);\n                break;\n            case types.CONSTRUCT:\n                recurseOp(result.input);\n                result.template.map(recurseOp);\n                break;\n            case types.DESCRIBE:\n                recurseOp(result.input);\n                break;\n            case types.DISTINCT:\n                recurseOp(result.input);\n                break;\n            case types.EXPRESSION:\n                if (result.expressionType === expressionTypes.EXISTENCE)\n                {\n                    recurseOp(result.input);\n                }\n                break;\n            case types.EXTEND:\n                recurseOp(result.input);\n                recurseOp(result.expression);\n                break;\n            case types.FILTER:\n                recurseOp(result.input);\n                recurseOp(result.expression);\n                break;\n            case types.FROM:\n                recurseOp(result.input);\n                break;\n            case types.GRAPH:\n                recurseOp(result.input);\n                break;\n            case types.GROUP:\n                recurseOp(result.input);\n                result.aggregates.forEach(recurseOp);\n                break;\n            case types.INV:\n                recurseOp(result.path);\n                break;\n            case types.JOIN:\n                result.input.map(recurseOp);\n                break;\n            case types.LEFT_JOIN:\n                result.input.map(recurseOp);\n                if (result.expression) recurseOp(result.expression);\n                break;\n            case types.LINK:\n                break;\n            case types.MINUS:\n                result.input.map(recurseOp);\n                break;\n            case types.NOP:\n                break;\n            case types.NPS:\n                break;\n            case types.ONE_OR_MORE_PATH:\n                recurseOp(result.path);\n                break;\n            case types.ORDER_BY:\n                recurseOp(result.input);\n                result.expressions.forEach(recurseOp);\n                break;\n            case types.PATH:\n                recurseOp(result.predicate);\n                break;\n            case types.PATTERN:\n                break;\n            case types.PROJECT:\n                recurseOp(result.input);\n                break;\n            case types.REDUCED:\n                recurseOp(result.input);\n                break;\n            case types.SEQ:\n                result.input.map(recurseOp);\n                break;\n            case types.SERVICE:\n                recurseOp(result.input);\n                break;\n            case types.SLICE:\n                recurseOp(result.input);\n                break;\n            case types.UNION:\n                result.input.map(recurseOp);\n                break;\n            case types.VALUES:\n                break;\n            case types.ZERO_OR_MORE_PATH:\n                recurseOp(result.path);\n                break;\n            case types.ZERO_OR_ONE_PATH:\n                recurseOp(result.path);\n                break;\n            // UPDATE operations\n            case types.COMPOSITE_UPDATE:\n                result.updates.forEach(update => recurseOp(update));\n                break;\n            case types.DELETE_INSERT:\n                if (result.delete)\n                    result.delete.forEach(pattern => recurseOp(pattern));\n                if (result.insert)\n                    result.insert.forEach(pattern => recurseOp(pattern));\n                if (result.where)\n                    recurseOp(result.where);\n                break;\n            // all of these only have graph IDs as values\n            case types.LOAD: break;\n            case types.CLEAR: break;\n            case types.CREATE: break;\n            case types.DROP: break;\n            case types.ADD: break;\n            case types.MOVE: break;\n            case types.COPY: break;\n            default: throw new Error(`Unknown Operation type ${(result as any).type}`);\n        }\n    }\n\n    /**\n     * Creates a deep copy of the given Operation.\n     * Creates shallow copies of the non-Operation values.\n     * A map of callback functions can be provided for individual Operation types\n     * to specifically modify the given objects before triggering recursion.\n     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    public static mapOperation(op: A.Operation,\n      callbacks: { [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult }\n        & { [T in A.expressionTypes]?: (expr: TypedExpression<T>, factory: Factory) => ExpressionRecurseResult },\n      factory?: Factory): A.Operation\n    {\n        let result: A.Operation = op;\n        let doRecursion = true;\n        let copyMetadata = true;\n\n        factory = factory || new Factory();\n\n        const callback = callbacks[op.type];\n        if (callback) {\n            // Not sure how to get typing correct for op here\n            const recurseResult = callback(op as any, factory);\n            result = recurseResult.result;\n            doRecursion = recurseResult.recurse;\n            copyMetadata = recurseResult.copyMetadata !== false;\n        }\n\n        let toCopyMetadata;\n        if (copyMetadata && (result.metadata || op.metadata)) {\n            toCopyMetadata = { ...result.metadata, ...op.metadata };\n        }\n\n        if (!doRecursion) {\n            // Inherit metadata\n            if (toCopyMetadata) {\n                result.metadata = toCopyMetadata;\n            }\n\n            return result;\n        }\n\n        let mapOp = (op: A.Operation) => Util.mapOperation(op, callbacks, factory);\n\n        // Several casts here might be wrong though depending on the callbacks output\n        switch (result.type)\n        {\n            case types.ALT:\n                result = factory.createAlt(<A.PropertyPathSymbol[]> result.input.map(mapOp));\n                break;\n            case types.ASK:\n                result = factory.createAsk(mapOp(result.input));\n                break;\n            case types.BGP:\n                result = factory.createBgp(<A.Pattern[]> result.patterns.map(mapOp));\n                break;\n            case types.CONSTRUCT:\n                result = factory.createConstruct(mapOp(result.input), <A.Pattern[]> result.template.map(mapOp));\n                break;\n            case types.DESCRIBE:\n                result = factory.createDescribe(mapOp(result.input), result.terms);\n                break;\n            case types.DISTINCT:\n                result = factory.createDistinct(mapOp(result.input));\n                break;\n            case types.EXPRESSION:\n                result = Util.mapExpression(result, callbacks, factory);\n                break;\n            case types.EXTEND:\n                result = factory.createExtend(mapOp(result.input), result.variable, <A.Expression> mapOp(result.expression));\n                break;\n            case types.FILTER:\n                result = factory.createFilter(mapOp(result.input), <A.Expression> mapOp(result.expression));\n                break;\n            case types.FROM:\n                result = factory.createFrom(mapOp(result.input), [ ...result.default ], [ ...result.named ]);\n                break;\n            case types.GRAPH:\n                result = factory.createGraph(mapOp(result.input), result.name);\n                break;\n            case types.GROUP:\n                result = factory.createGroup(\n                    mapOp(result.input),\n                    (<RDF.Variable[]>[]).concat(result.variables),\n                    <A.BoundAggregate[]> result.aggregates.map(mapOp));\n                break;\n            case types.INV:\n                result = factory.createInv(<A.PropertyPathSymbol> mapOp(result.path));\n                break;\n            case types.JOIN:\n                result = factory.createJoin(result.input.map(mapOp));\n                break;\n            case types.LEFT_JOIN:\n                result = factory.createLeftJoin(\n                    mapOp(result.input[0]),\n                    mapOp(result.input[1]),\n                  result.expression ? <A.Expression> mapOp(result.expression) : undefined);\n                break;\n            case types.LINK:\n                result = factory.createLink(result.iri);\n                break;\n            case types.MINUS:\n                result = factory.createMinus(mapOp(result.input[0]), mapOp(result.input[1]));\n                break;\n            case types.NOP:\n                result = factory.createNop();\n                break;\n            case types.NPS:\n                result = factory.createNps((<RDF.NamedNode[]>[]).concat(result.iris));\n                break;\n            case types.ONE_OR_MORE_PATH:\n                result = factory.createOneOrMorePath(<A.PropertyPathSymbol> mapOp(result.path));\n                break;\n            case types.ORDER_BY:\n                result = factory.createOrderBy(mapOp(result.input), <A.Expression[]> result.expressions.map(mapOp));\n                break;\n            case types.PATH:\n                result = factory.createPath(result.subject, <A.PropertyPathSymbol> mapOp(result.predicate), result.object, result.graph);\n                break;\n            case types.PATTERN:\n                result = factory.createPattern(result.subject, result.predicate, result.object, result.graph);\n                break;\n            case types.PROJECT:\n                result = factory.createProject(mapOp(result.input), [ ...result.variables ]);\n                break;\n            case types.REDUCED:\n                result = factory.createReduced(mapOp(result.input));\n                break;\n            case types.SEQ:\n                result = factory.createSeq(<A.PropertyPathSymbol[]> result.input.map(mapOp));\n                break;\n            case types.SERVICE:\n                result = factory.createService(mapOp(result.input), result.name, result.silent);\n                break;\n            case types.SLICE:\n                result = factory.createSlice(mapOp(result.input), result.start, result.length);\n                break;\n            case types.UNION:\n                result = factory.createUnion(result.input.map(mapOp));\n                break;\n            case types.VALUES:\n                result = factory.createValues((<RDF.Variable[]>[]).concat(result.variables), result.bindings.map(b => Object.assign({}, b)));\n                break;\n            case types.ZERO_OR_MORE_PATH:\n                result = factory.createZeroOrMorePath(<A.PropertyPathSymbol> mapOp(result.path));\n                break;\n            case types.ZERO_OR_ONE_PATH:\n                result = factory.createZeroOrOnePath(<A.PropertyPathSymbol> mapOp(result.path));\n                break;\n          // UPDATE operations\n            case types.COMPOSITE_UPDATE:\n                result = factory.createCompositeUpdate(<A.Update[]> result.updates.map(mapOp));\n                break;\n            case types.DELETE_INSERT:\n                result = factory.createDeleteInsert(\n                  result.delete ? <A.Pattern[]> result.delete.map(mapOp) : undefined,\n                  result.insert ? <A.Pattern[]> result.insert.map(mapOp) : undefined,\n                  result.where ? mapOp(result.where) : undefined,\n                  );\n                break;\n            case types.LOAD:\n                result = factory.createLoad(result.source, result.destination, result.silent);\n                break;\n            case types.CLEAR:\n                result = factory.createClear(result.source, result.silent);\n                break;\n            case types.CREATE:\n                result = factory.createCreate(result.source, result.silent);\n                break;\n            case types.DROP:\n                result = factory.createDrop(result.source, result.silent);\n                break;\n            case types.ADD:\n                result = factory.createAdd(result.source, result.destination);\n                break;\n            case types.MOVE:\n                result = factory.createMove(result.source, result.destination);\n                break;\n            case types.COPY:\n                result = factory.createCopy(result.source, result.destination);\n                break;\n            default: throw new Error(`Unknown Operation type ${(result as any).type}`);\n        }\n\n        // Inherit metadata\n        if (toCopyMetadata) {\n            result.metadata = toCopyMetadata;\n        }\n\n        return result;\n    }\n\n    /**\n     * Similar to the {@link mapOperation} function but specifically for expressions.\n     * Both functions call each other while copying.\n     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.\n     * @param {Expression} expr - The Operation to recurse on.\n     * @param callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    public static mapExpression(expr: A.Expression,\n      callbacks: { [T in A.types]?: (op: TypedOperation<T>, factory: Factory) => RecurseResult }\n        & { [T in A.expressionTypes]?: (expr: TypedExpression<T>, factory: Factory) => ExpressionRecurseResult },\n      factory?: Factory): A.Expression\n    {\n        let result: A.Expression = expr;\n        let doRecursion = true;\n\n        factory = factory || new Factory();\n\n        const callback = callbacks[expr.expressionType];\n        if (callback)\n            ({ result, recurse: doRecursion } = callback(expr as any, factory));\n\n        if (!doRecursion)\n            return result;\n\n        let mapOp = (op: A.Operation) => Util.mapOperation(op, callbacks, factory);\n\n        switch(expr.expressionType)\n        {\n            case expressionTypes.AGGREGATE:\n                if (expr.variable)\n                {\n                    return factory.createBoundAggregate(expr.variable, expr.aggregator, <Expression> mapOp(expr.expression), expr.distinct, expr.separator);\n                }\n                return factory.createAggregateExpression(expr.aggregator, <Expression> mapOp(expr.expression), expr.distinct, expr.separator);\n            case expressionTypes.EXISTENCE:\n                return factory.createExistenceExpression(expr.not, mapOp(expr.input));\n            case expressionTypes.NAMED:\n                return factory.createNamedExpression(expr.name, <A.Expression[]> expr.args.map(mapOp));\n            case expressionTypes.OPERATOR:\n                return factory.createOperatorExpression(expr.operator, <A.Expression[]> expr.args.map(mapOp));\n            case expressionTypes.TERM:\n                return factory.createTermExpression(expr.term);\n            case expressionTypes.WILDCARD:\n                return factory.createWildcardExpression();\n            default: throw new Error(`Unknown Expression type ${(expr as any).expressionType}`);\n        }\n    }\n\n    /**\n     * Creates a deep clone of the operation.\n     * This is syntactic sugar for calling {@link mapOperation} without callbacks.\n     * @param {Operation} op - The operation to copy.\n     * @returns {Operation} - The deep copy.\n     */\n    public static cloneOperation(op: A.Operation) {\n        return Util.mapOperation(op, {});\n    }\n\n    /**\n     * Creates a deep clone of the expression.\n     * This is syntactic sugar for calling {@link mapExpression} without callbacks.\n     * @param {Expression} expr - The operation to copy.\n     * @returns {Expression} - The deep copy.\n     */\n    public static cloneExpression(expr: A.Expression) {\n        return Util.mapExpression(expr, {});\n    }\n\n    public static createUniqueVariable(label: string, variables: {[vLabel: string]: boolean}, dataFactory: RDF.DataFactory<BaseQuad, BaseQuad>): RDF.Variable {\n        let counter: number = 0;\n        let labelLoop = label;\n        while (variables[labelLoop]) {\n            labelLoop = `${label}${counter++}`;\n        }\n        return dataFactory.variable!(labelLoop);\n    }\n\n    // separate terms from wildcard since we handle them differently\n    public static isSimpleTerm(term: any): term is RDF.Term {\n        return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'Wildcard';\n    }\n\n    public static isQuad(term: any): term is RDF.Quad {\n        return term.termType === 'Quad';\n    }\n\n    public static hasQuadVariables(quad: RDF.Quad): boolean {\n        return someTermsNested(quad, term => term.termType === 'Variable');\n    }\n\n    public static isWildcard(term: any): term is Wildcard {\n        return term.termType === 'Wildcard';\n    }\n}\n\n/**\n * @interface RecurseResult\n * @property {Operation} result - The resulting A.Operation.\n * @property {boolean} recurse - Whether to continue with recursion.\n * @property {boolean} copyMetadata - If the metadata object should be copied. Defaults to true.\n */\nexport interface RecurseResult\n{\n    result: A.Operation;\n    recurse: boolean;\n    copyMetadata?: boolean;\n}\n\n/**\n * @interface ExpressionRecurseResult\n * @property {Expression} result - The resulting A.Expression.\n * @property {boolean} recurse - Whether to continue with recursion.\n * @property {boolean} copyMetadata - If the metadata object should be copied. Defaults to true.\n */\nexport interface ExpressionRecurseResult\n{\n    result: A.Expression;\n    recurse: boolean;\n    copyMetadata?: boolean;\n}\n"]}