{"version":3,"file":"ParsingContext.js","sourceRoot":"","sources":["ParsingContext.ts"],"names":[],"mappings":"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","sourcesContent":["import {ContextParser, IExpandOptions, IJsonLdContextNormalizedRaw, JsonLdContext,\n  JsonLdContextNormalized} from \"jsonld-context-parser\";\nimport {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser/lib/ErrorCoded\";\nimport * as RDF from \"@rdfjs/types\";\nimport {ContextTree} from \"./ContextTree\";\nimport {IJsonLdParserOptions, JsonLdParser} from \"./JsonLdParser\";\n\nexport type AnnotationsBufferEntry = { predicate: RDF.Term, object: RDF.Term, reverse: boolean, nestedAnnotations: AnnotationsBufferEntry[], depth: number };\n\n/**\n * Data holder for parsing information.\n */\nexport class ParsingContext {\n\n  public static EXPAND_OPTIONS: {[version: number]: IExpandOptions} = {\n    1.0: {\n      allowPrefixForcing: false,\n      allowPrefixNonGenDelims: false,\n      allowVocabRelativeToBase: false,\n    },\n    1.1: {\n      allowPrefixForcing: true,\n      allowPrefixNonGenDelims: false,\n      allowVocabRelativeToBase: true,\n    },\n  };\n\n  public readonly contextParser: ContextParser;\n  public readonly streamingProfile: boolean;\n  public readonly baseIRI?: string;\n  public readonly produceGeneralizedRdf: boolean;\n  public readonly allowSubjectList: boolean;\n  public readonly processingMode: string;\n  public readonly strictValues: boolean;\n  public readonly validateValueIndexes: boolean;\n  public readonly rootContext: Promise<JsonLdContextNormalized>;\n  public readonly defaultGraph?: RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph;\n  public readonly rdfDirection?: 'i18n-datatype' | 'compound-literal';\n  public readonly normalizeLanguageTags?: boolean;\n  public readonly streamingProfileAllowOutOfOrderPlainType?: boolean;\n  public readonly rdfstar: boolean;\n  public readonly rdfstarReverseInEmbedded?: boolean;\n\n  // Stack of indicating if a depth has been touched.\n  public readonly processingStack: boolean[];\n  // Stack of indicating if a type has been processed.\n  public readonly processingType: boolean[];\n  // Stack of indicating if triples have been emitted (or will be emitted) at each depth.\n  public readonly emittedStack: boolean[];\n  // Stack of identified ids (each entry can have multiple ids), tail can be null if unknown\n  public readonly idStack: RDF.Term[][];\n  // Stack of graph flags (if they point to an @graph in a parent node)\n  public readonly graphStack: boolean[];\n  // Stack of graph overrides when in an @container: @graph\n  public readonly graphContainerTermStack: ({ [index: string]: RDF.NamedNode | RDF.BlankNode })[];\n  // Stack of RDF list pointers (for @list)\n  public readonly listPointerStack: ({ value?: RDF.Term, listRootDepth: number, listId: RDF.Term })[];\n  // Stack of active contexts\n  public readonly contextTree: ContextTree;\n  // Stack of flags indicating if the node is a literal\n  public readonly literalStack: boolean[];\n  // Stack with validation results.\n  public readonly validationStack: { valid: boolean, property: boolean }[];\n  // Stack with cached unaliased keywords.\n  public readonly unaliasedKeywordCacheStack: any[];\n  // Stack of flags indicating if the node is a JSON literal\n  public readonly jsonLiteralStack: boolean[];\n  // Triples that don't know their subject @id yet.\n  // L0: stack depth; L1: values\n  public readonly unidentifiedValuesBuffer: { predicate: RDF.Term, object: RDF.Term, reverse: boolean, isEmbedded: boolean }[][];\n  // Quads that don't know their graph @id yet.\n  // L0: stack depth; L1: values\n  public readonly unidentifiedGraphsBuffer: { subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, isEmbedded: boolean }[][];\n  // Stack of annotation objects on incomplete nodes.\n  public readonly annotationsBuffer: AnnotationsBufferEntry[][];\n\n  // Depths that should be still flushed\n  public pendingContainerFlushBuffers: { depth: number, keys: any[] }[];\n\n  // If there are top-level properties\n  public topLevelProperties: boolean;\n  // The processing mode that was defined in the document's context\n  public activeProcessingMode: number;\n\n  private readonly parser: JsonLdParser;\n\n  constructor(options: IParsingContextOptions) {\n    // Initialize settings\n    this.contextParser = new ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });\n    this.streamingProfile = !!options.streamingProfile;\n    this.baseIRI = options.baseIRI;\n    this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;\n    this.allowSubjectList = !!options.allowSubjectList;\n    this.processingMode = options.processingMode || JsonLdParser.DEFAULT_PROCESSING_MODE;\n    this.strictValues = !!options.strictValues;\n    this.validateValueIndexes = !!options.validateValueIndexes;\n    this.defaultGraph = options.defaultGraph;\n    this.rdfDirection = options.rdfDirection;\n    this.normalizeLanguageTags = options.normalizeLanguageTags;\n    this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;\n    this.rdfstar = options.rdfstar !== false;\n    this.rdfstarReverseInEmbedded = options.rdfstarReverseInEmbedded;\n\n    this.topLevelProperties = false;\n    this.activeProcessingMode = parseFloat(this.processingMode);\n\n    // Initialize stacks\n    this.processingStack = [];\n    this.processingType = [];\n    this.emittedStack = [];\n    this.idStack = [];\n    this.graphStack = [];\n    this.graphContainerTermStack = [];\n    this.listPointerStack = [];\n    this.contextTree = new ContextTree();\n    this.literalStack = [];\n    this.validationStack = [];\n    this.unaliasedKeywordCacheStack = [];\n    this.jsonLiteralStack = [];\n    this.unidentifiedValuesBuffer = [];\n    this.unidentifiedGraphsBuffer = [];\n    this.annotationsBuffer = [];\n\n    this.pendingContainerFlushBuffers = [];\n\n    this.parser = options.parser;\n    if (options.context) {\n      this.rootContext = this.parseContext(options.context);\n      this.rootContext.then((context) => this.validateContext(context));\n    } else {\n      this.rootContext = Promise.resolve(new JsonLdContextNormalized(\n        this.baseIRI ? { '@base': this.baseIRI, '@__baseDocument': true } : {}));\n    }\n  }\n\n  /**\n   * Parse the given context with the configured options.\n   * @param {JsonLdContext} context A context to parse.\n   * @param {JsonLdContextNormalized} parentContext An optional parent context.\n   * @param {boolean} ignoreProtection If @protected term checks should be ignored.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.\n   */\n  public async parseContext(context: JsonLdContext, parentContext?: IJsonLdContextNormalizedRaw,\n                            ignoreProtection?: boolean)\n    : Promise<JsonLdContextNormalized> {\n    return this.contextParser.parse(context, {\n      baseIRI: this.baseIRI,\n      ignoreProtection,\n      normalizeLanguageTags: this.normalizeLanguageTags,\n      parentContext,\n      processingMode: this.activeProcessingMode,\n    });\n  }\n\n  /**\n   * Check if the given context is valid.\n   * If not, an error will be thrown.\n   * @param {JsonLdContextNormalized} context A context.\n   */\n  public validateContext(context: JsonLdContextNormalized) {\n    const activeVersion: number = <number> <any> context.getContextRaw()['@version'];\n    if (activeVersion) {\n      if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {\n        throw new ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${\n          this.activeProcessingMode}.`, ERROR_CODES.PROCESSING_MODE_CONFLICT);\n      } else {\n        if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {\n          throw new ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${\n            this.activeProcessingMode}.`, ERROR_CODES.INVALID_VERSION_VALUE);\n        }\n        this.activeProcessingMode = activeVersion;\n      }\n    }\n  }\n\n  /**\n   * Get the context at the given path.\n   * @param {keys} keys The path of keys to get the context at.\n   * @param {number} offset The path offset, defaults to 1.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.\n   */\n  public async getContext(keys: any[], offset = 1): Promise<JsonLdContextNormalized> {\n    const keysOriginal = keys;\n\n    // Ignore array keys at the end\n    while (typeof keys[keys.length - 1] === 'number') {\n      keys = keys.slice(0, keys.length - 1);\n    }\n\n    // Handle offset on keys\n    if (offset) {\n      keys = keys.slice(0, -offset);\n    }\n\n    // Determine the closest context\n    const contextData = await this.getContextPropagationAware(keys);\n    const context: JsonLdContextNormalized = contextData.context;\n\n    // Process property-scoped contexts (high-to-low)\n    let contextRaw: IJsonLdContextNormalizedRaw = context.getContextRaw();\n    for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {\n      const key = keysOriginal[i];\n      const contextKeyEntry = contextRaw[key];\n      if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n        const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();\n        const propagate = !(key in scopedContext)\n          || scopedContext[key]['@context']['@propagate']; // Propagation is true by default\n\n        if (propagate !== false || i === keysOriginal.length - 1 - offset) {\n          contextRaw = { ...scopedContext };\n\n          // Clean up final context\n          delete contextRaw['@propagate'];\n          contextRaw[key] = { ...contextRaw[key] };\n          if ('@id' in contextKeyEntry) {\n            contextRaw[key]['@id'] = contextKeyEntry['@id'];\n          }\n          delete contextRaw[key]['@context'];\n\n          if (propagate !== false) {\n            this.contextTree.setContext(keysOriginal.slice(0, i + offset),\n              Promise.resolve(new JsonLdContextNormalized(contextRaw)));\n          }\n        }\n      }\n    }\n\n    return new JsonLdContextNormalized(contextRaw);\n  }\n\n  /**\n   * Get the context at the given path.\n   * Non-propagating contexts will be skipped,\n   * unless the context at that exact depth is retrieved.\n   *\n   * This ONLY takes into account context propagation logic,\n   * so this should usually not be called directly,\n   * call {@link #getContext} instead.\n   *\n   * @param keys The path of keys to get the context at.\n   * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.\n   */\n  public async getContextPropagationAware(keys: string[]):\n    Promise<{ context: JsonLdContextNormalized, depth: number }> {\n    const originalDepth = keys.length;\n    let contextData: { context: JsonLdContextNormalized, depth: number } | null = null;\n    let hasApplicablePropertyScopedContext: boolean;\n    do {\n      hasApplicablePropertyScopedContext = false;\n      if (contextData && '@__propagateFallback' in contextData.context.getContextRaw()) {\n        // If a propagation fallback context has been set,\n        // fallback to that context and retry for the same depth.\n        contextData.context = new JsonLdContextNormalized(contextData.context.getContextRaw()['@__propagateFallback']);\n      } else {\n        if (contextData) {\n          // If we had a previous iteration, jump to the parent of context depth.\n          // We must do this because once we get here, last context had propagation disabled,\n          // so we check its first parent instead.\n          keys = keys.slice(0, contextData.depth - 1);\n        }\n\n        contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };\n      }\n\n      // Allow non-propagating contexts to propagate one level deeper\n      // if it defines a property-scoped context that is applicable for the current key.\n      // @see https://w3c.github.io/json-ld-api/tests/toRdf-manifest#tc012\n      const lastKey = keys[keys.length - 1];\n      if (lastKey in contextData.context.getContextRaw()) {\n        const lastKeyValue = contextData.context.getContextRaw()[lastKey];\n        if (lastKeyValue && typeof lastKeyValue === 'object' && '@context' in lastKeyValue) {\n          hasApplicablePropertyScopedContext = true;\n        }\n      }\n    } while (contextData.depth > 0 // Root context has a special case\n    && contextData.context.getContextRaw()['@propagate'] === false // Stop loop if propagation is true\n    && contextData.depth !== originalDepth // Stop loop if requesting exact depth of non-propagating\n    && !hasApplicablePropertyScopedContext);\n\n     // Special case for root context that does not allow propagation.\n    // Fallback to empty context in that case.\n    if (contextData.depth === 0\n      && contextData.context.getContextRaw()['@propagate'] === false\n      && contextData.depth !== originalDepth) {\n      contextData.context = new JsonLdContextNormalized({});\n    }\n\n    return contextData;\n  }\n\n  /**\n   * Start a new job for parsing the given value.\n   * @param {any[]} keys The stack of keys.\n   * @param value The value to parse.\n   * @param {number} depth The depth to parse at.\n   * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n   * @return {Promise<void>} A promise resolving when the job is done.\n   */\n  public async newOnValueJob(keys: any[], value: any, depth: number, lastDepthCheck: boolean) {\n    await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);\n  }\n\n  /**\n   * Flush the pending container flush buffers\n   * @return {boolean} If any pending buffers were flushed.\n   */\n  public async handlePendingContainerFlushBuffers(): Promise<boolean> {\n    if (this.pendingContainerFlushBuffers.length > 0) {\n      for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {\n        await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);\n        this.parser.flushStacks(pendingFlushBuffer.depth);\n      }\n      this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Emit the given quad into the output stream.\n   * @param {number} depth The depth the quad was generated at.\n   * @param {Quad} quad A quad to emit.\n   */\n  public emitQuad(depth: number, quad: RDF.BaseQuad) {\n    if (depth === 1) {\n      this.topLevelProperties = true;\n    }\n    this.parser.push(quad);\n  }\n\n  /**\n   * Emit the given error into the output stream.\n   * @param {Error} error An error to emit.\n   */\n  public emitError(error: Error) {\n    this.parser.emit('error', error);\n  }\n\n  /**\n   * Emit the given context into the output stream under the 'context' event.\n   * @param {JsonLdContext} context A context to emit.\n   */\n  public emitContext(context: JsonLdContext) {\n    this.parser.emit('context', context);\n  }\n\n  /**\n   * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.\n   * @param {number} depth A depth.\n   * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n   *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.\n   */\n  public getUnidentifiedValueBufferSafe(depth: number): { predicate: RDF.Term, object: RDF.Term, reverse: boolean, isEmbedded: boolean }[] {\n    let buffer = this.unidentifiedValuesBuffer[depth];\n    if (!buffer) {\n      buffer = [];\n      this.unidentifiedValuesBuffer[depth] = buffer;\n    }\n    return buffer;\n  }\n\n  /**\n   * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.\n   * @param {number} depth A depth.\n   * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n   *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.\n   */\n  public getUnidentifiedGraphBufferSafe(depth: number): { subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, isEmbedded: boolean }[] {\n    let buffer = this.unidentifiedGraphsBuffer[depth];\n    if (!buffer) {\n      buffer = [];\n      this.unidentifiedGraphsBuffer[depth] = buffer;\n    }\n    return buffer;\n  }\n\n  /**\n   * Safely get or create the depth value of {@link ParsingContext.annotationsBuffer}.\n   * @param {number} depth A depth.\n   * @return {} An element of {@link ParsingContext.annotationsBuffer}.\n   */\n  public getAnnotationsBufferSafe(depth: number): AnnotationsBufferEntry[] {\n    let buffer = this.annotationsBuffer[depth];\n    if (!buffer) {\n      buffer = [];\n      this.annotationsBuffer[depth] = buffer;\n    }\n    return buffer;\n  }\n\n  /**\n   * @return IExpandOptions The expand options for the active processing mode.\n   */\n  public getExpandOptions(): IExpandOptions {\n    return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];\n  }\n\n  /**\n   * Shift the stack at the given offset to the given depth.\n   *\n   * This will override anything in the stack at `depth`,\n   * and this will remove anything at `depth + depthOffset`\n   *\n   * @param depth The target depth.\n   * @param depthOffset The origin depth, relative to `depth`.\n   */\n  public shiftStack(depth: number, depthOffset: number) {\n    // Copy the id stack value up one level so that the next job can access the id.\n    const deeperIdStack = this.idStack[depth + depthOffset];\n    if (deeperIdStack) {\n      this.idStack[depth] = deeperIdStack;\n      this.emittedStack[depth] = true;\n      delete this.idStack[depth + depthOffset];\n    }\n\n    // Shorten key stack\n    if (this.pendingContainerFlushBuffers.length) {\n      for (const buffer of this.pendingContainerFlushBuffers) {\n        if (buffer.depth >= depth + depthOffset) {\n          buffer.depth -= depthOffset;\n          buffer.keys.splice(depth, depthOffset);\n        }\n      }\n    }\n\n    // Splice stacks\n    if (this.unidentifiedValuesBuffer[depth + depthOffset]) {\n      this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];\n      delete this.unidentifiedValuesBuffer[depth + depthOffset];\n    }\n    if (this.annotationsBuffer[depth + depthOffset - 1]) {\n      if (!this.annotationsBuffer[depth - 1]) {\n        this.annotationsBuffer[depth - 1] = [];\n      }\n      this.annotationsBuffer[depth - 1] = [\n        ...this.annotationsBuffer[depth - 1],\n        ...this.annotationsBuffer[depth + depthOffset - 1],\n      ];\n      delete this.annotationsBuffer[depth + depthOffset - 1];\n    }\n\n    // TODO: also do the same for other stacks\n  }\n\n}\n\n/**\n * Constructor arguments for {@link ParsingContext}\n */\nexport interface IParsingContextOptions extends IJsonLdParserOptions {\n  /**\n   * The parser instance.\n   */\n  parser: JsonLdParser;\n}\n"]}