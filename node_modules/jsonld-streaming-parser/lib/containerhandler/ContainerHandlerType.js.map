{"version":3,"file":"ContainerHandlerType.js","sourceRoot":"","sources":["ContainerHandlerType.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntryHandlerPredicate} from \"../entryhandler/EntryHandlerPredicate\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IContainerHandler} from \"./IContainerHandler\";\n\n/**\n * Container handler for @type.\n *\n * This will add this entry to the parent node, and use the current key as an rdf:type value.\n */\nexport class ContainerHandlerType implements IContainerHandler {\n\n  public canCombineWithGraph(): boolean {\n    return false;\n  }\n\n  public async handle(containers: { [typeName: string]: boolean }, parsingContext: ParsingContext, util: Util,\n                      keys: string[], value: any, depth: number)\n    : Promise<void> {\n    if (!Array.isArray(value)) {\n      if (typeof value === 'string') {\n        // Determine the @type of the container\n        const context = await parsingContext.getContext(keys);\n        const containerTypeType = Util.getContextValueType(context, keys[depth - 1]);\n\n        // String values refer to node references\n        const id = containerTypeType === '@vocab'\n          ? await util.createVocabOrBaseTerm(context, value)\n          : await util.resourceToTerm(context, value);\n        if (id) {\n          // Handle the value of this node as @id, which will also cause the predicate from above to be emitted.\n          const subValue = { '@id': id.termType === 'NamedNode' ? id.value : value };\n          await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);\n\n          // Set the id in the stack so it can be used for the rdf:type handling later on\n          parsingContext.idStack[depth + 1] = [ id ];\n        }\n      } else {\n        // Other values are handled by handling them as a proper job\n\n        // Check needed for cases where entries don't have an explicit @id\n        const entryHasIdentifier = !!parsingContext.idStack[depth + 1];\n\n        // Handle the value of this node, which will also cause the predicate from above to be emitted.\n        if (!entryHasIdentifier) {\n          delete parsingContext.idStack[depth]; // Force new (blank node) identifier\n        }\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n        if (!entryHasIdentifier) {\n          parsingContext.idStack[depth + 1] = parsingContext.idStack[depth]; // Copy the id to the child node, for @type\n        }\n      }\n\n      // Identify the type to emit.\n      const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);\n      const type = keyOriginal !== null\n        ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal)\n        : null;\n      if (type) {\n        // Push the type to the stack using the rdf:type predicate\n        await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1,\n          util.rdfType, type, false, false, false);\n      }\n\n      // Flush any pending flush buffers\n      await parsingContext.handlePendingContainerFlushBuffers();\n    }\n\n    parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n  }\n\n}\n"]}