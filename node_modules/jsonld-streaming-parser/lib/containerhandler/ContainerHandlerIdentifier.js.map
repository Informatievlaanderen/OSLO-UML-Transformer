{"version":3,"file":"ContainerHandlerIdentifier.js","sourceRoot":"","sources":["ContainerHandlerIdentifier.ts"],"names":[],"mappings":";;;AAKA;;;;;GAKG;AACH,MAAa,0BAA0B;IAE9B,mBAAmB;QACxB,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,UAA2C,EAAE,cAA8B,EAAE,IAAU,EACvF,IAAc,EAAE,KAAU,EAAE,KAAa;QAE3D,IAAI,EAAY,CAAC;QAEjB,0DAA0D;QAC1D,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE;YAC/E,8BAA8B;YAC9B,EAAE,GAAG,cAAc,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3C;aAAM;YACL,wBAAwB;YACxB,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1E,MAAM,OAAO,GAAG,YAAY,KAAK,IAAI;gBACnC,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC/E,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;YAEjC,kCAAkC;YAClC,IAAI,CAAC,OAAO,EAAE;gBACZ,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,kDAAkD;gBAC9F,OAAO;aACR;YACD,EAAE,GAAG,OAAO,CAAC;YAEb,4EAA4E;YAC5E,cAAc,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;SAE1C;QAED,mEAAmE;QACnE,wEAAwE;QACxE,IAAI,GAAG,GAAe,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACpD,IAAI,CAAC,GAAG,EAAE;YACR,GAAG,GAAG,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;SAC1C;QACD,8DAA8D;QAC9D,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE;YACxC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SACd;QAED,kCAAkC;QAClC,IAAI,CAAC,MAAM,cAAc,CAAC,kCAAkC,EAAE,EAAE;YAC9D,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,kDAAkD;SAC/F;IACH,CAAC;CAEF;AAnDD,gEAmDC","sourcesContent":["import * as RDF from \"@rdfjs/types\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IContainerHandler} from \"./IContainerHandler\";\n\n/**\n * Container handler for @id.\n *\n * It assumes that the current key is the identifier of the current value.\n * This will add this value to the parent node.\n */\nexport class ContainerHandlerIdentifier implements IContainerHandler {\n\n  public canCombineWithGraph(): boolean {\n    return true;\n  }\n\n  public async handle(containers: { [typeName: string]: boolean }, parsingContext: ParsingContext, util: Util,\n                      keys: string[], value: any, depth: number)\n    : Promise<void> {\n    let id: RDF.Term;\n\n    // First check if the child node already has a defined id.\n    if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {\n      // Use the existing identifier\n      id = parsingContext.idStack[depth + 1][0];\n    } else {\n      // Create the identifier\n      const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);\n      const maybeId = keyUnaliased !== null\n        ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth])\n        : util.dataFactory.blankNode();\n\n      // Do nothing if the id is invalid\n      if (!maybeId) {\n        parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n        return;\n      }\n      id = maybeId;\n\n      // Insert the id into the stack so that buffered children can make us of it.\n      parsingContext.idStack[depth + 1] = [id];\n\n    }\n\n    // Insert the id into the stack so that parents can make use of it.\n    // Insert it as an array because multiple id container entries may exist\n    let ids: RDF.Term[] = parsingContext.idStack[depth];\n    if (!ids) {\n      ids = parsingContext.idStack[depth] = [];\n    }\n    // Only insert the term if it does not exist yet in the array.\n    if (!ids.some((term) => term.equals(id))) {\n      ids.push(id);\n    }\n\n    // Flush any pending flush buffers\n    if (!await parsingContext.handlePendingContainerFlushBuffers()) {\n      parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n    }\n  }\n\n}\n"]}