{"version":3,"file":"ContainerHandlerIndex.js","sourceRoot":"","sources":["ContainerHandlerIndex.ts"],"names":[],"mappings":"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","sourcesContent":["import {ERROR_CODES, ErrorCoded, Util as ContextUtil} from \"jsonld-context-parser\";\nimport {EntryHandlerPredicate} from \"../entryhandler/EntryHandlerPredicate\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IContainerHandler} from \"./IContainerHandler\";\n\n/**\n * Container handler for @index.\n *\n * This will ignore the current key and add this entry to the parent node.\n */\nexport class ContainerHandlerIndex implements IContainerHandler {\n\n  public canCombineWithGraph(): boolean {\n    return true;\n  }\n\n  public async handle(containers: { [typeName: string]: boolean }, parsingContext: ParsingContext, util: Util,\n                      keys: string[], value: any, depth: number)\n    : Promise<void> {\n    if (!Array.isArray(value)) {\n      const graphContainer = '@graph' in containers;\n\n      // Check if the container is a property-based container by checking if there is a valid @index.\n      const context = await parsingContext.getContext(keys);\n      const indexKey = keys[depth - 1];\n      const indexPropertyRaw = Util.getContextValueIndex(context, indexKey);\n      if (indexPropertyRaw) {\n        // Validate the @index value\n        if (ContextUtil.isPotentialKeyword(indexPropertyRaw)) {\n          throw new ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`,\n            ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n        if (typeof indexPropertyRaw !== 'string') {\n          throw new ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`,\n            ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n\n        // When @index is used, values must be node values, unless @type: @id is defined in the context\n        if (typeof value !== 'object') {\n          // Error if we don't have @type: @id\n          if (Util.getContextValueType(context, indexKey) !== '@id') {\n            throw new ErrorCoded(\n              `Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`,\n              ERROR_CODES.INVALID_VALUE_OBJECT);\n          }\n\n          // Add an @id to the stack, so our expanded @index value can make use of it\n          const id = util.resourceToTerm(context, value);\n          if (id) {\n            parsingContext.idStack[depth + 1] = [id];\n          }\n        }\n\n        // Expand the @index value\n        const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);\n        if (indexProperty) {\n          const indexValues = await util.valueToTerm(context, indexPropertyRaw,\n            await util.getContainerKey(keys[depth], keys, depth), depth, keys);\n\n          if (graphContainer) {\n            // When we're in a graph container, attach the index to the graph identifier\n            const graphId = await util.getGraphContainerValue(keys, depth + 1);\n            for (const indexValue of indexValues) {\n              parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue,\n                util.getDefaultGraph()));\n            }\n          } else {\n            // Otherwise, attach the index to the node identifier\n            for (const indexValue of indexValues) {\n              await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1,\n                indexProperty, indexValue, false, false, false);\n            }\n          }\n        }\n      }\n\n      const depthOffset = graphContainer ? 2 : 1;\n      await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);\n\n      // Flush any pending flush buffers\n      await parsingContext.handlePendingContainerFlushBuffers();\n    }\n\n    parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n  }\n\n}\n"]}