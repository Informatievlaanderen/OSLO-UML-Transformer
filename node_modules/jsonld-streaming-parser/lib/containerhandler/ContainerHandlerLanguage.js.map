{"version":3,"file":"ContainerHandlerLanguage.js","sourceRoot":"","sources":["ContainerHandlerLanguage.ts"],"names":[],"mappings":";;;AAAA,iEAA8D;AAK9D;;;;;GAKG;AACH,MAAa,wBAAwB;IAE5B,mBAAmB;QACxB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,UAA2C,EAAE,cAA8B,EAAE,IAAU,EACvF,IAAc,EAAE,KAAU,EAAE,KAAa;QAE3D,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAEtE,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxB,kGAAkG;YAClG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;SAClF;aAAM;YACL,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC7B,MAAM,IAAI,kCAAU,CAClB,wCAAwC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,wBAAwB,EACrF,mCAAW,CAAC,0BAA0B,CAAC,CAAC;aAC3C;YACD,KAAK,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,CAAC;SACpD;QACD,MAAM,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;QAE3F,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,iCAAiC;IAC/E,CAAC;CAEF;AA3BD,4DA2BC","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IContainerHandler} from \"./IContainerHandler\";\n\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nexport class ContainerHandlerLanguage implements IContainerHandler {\n\n  public canCombineWithGraph(): boolean {\n    return false;\n  }\n\n  public async handle(containers: { [typeName: string]: boolean }, parsingContext: ParsingContext, util: Util,\n                      keys: string[], value: any, depth: number)\n    : Promise<void> {\n    const language = await util.getContainerKey(keys[depth], keys, depth);\n\n    if (Array.isArray(value)) {\n      // No type-checking needed, will be handled on each value when this handler is called recursively.\n      value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n    } else {\n      if (typeof value !== 'string') {\n        throw new ErrorCoded(\n          `Got invalid language map value, got '${JSON.stringify(value)}', but expected string`,\n          ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n      }\n      value = { '@value': value, '@language': language };\n    }\n    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n\n    parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n  }\n\n}\n"]}