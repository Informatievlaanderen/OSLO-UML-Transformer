{"version":3,"file":"Util.js","sourceRoot":"","sources":["Util.ts"],"names":[],"mappings":"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","sourcesContent":["import {ContextParser, ERROR_CODES, ErrorCoded, JsonLdContextNormalized,\n  Util as ContextUtil} from \"jsonld-context-parser\";\nimport * as RDF from \"@rdfjs/types\";\nimport {DataFactory} from \"rdf-data-factory\";\nimport {EntryHandlerContainer} from \"./entryhandler/EntryHandlerContainer\";\nimport { AnnotationsBufferEntry, ParsingContext } from \"./ParsingContext\";\n\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n\n/**\n * Utility functions and methods.\n */\nexport class Util {\n\n  public static readonly XSD: string = 'http://www.w3.org/2001/XMLSchema#';\n  public static readonly XSD_BOOLEAN: string = Util.XSD + 'boolean';\n  public static readonly XSD_INTEGER: string = Util.XSD + 'integer';\n  public static readonly XSD_DOUBLE: string = Util.XSD + 'double';\n  public static readonly RDF: string = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n\n  public readonly dataFactory: RDF.DataFactory<RDF.BaseQuad>;\n  public readonly rdfFirst: RDF.NamedNode;\n  public readonly rdfRest: RDF.NamedNode;\n  public readonly rdfNil: RDF.NamedNode;\n  public readonly rdfType: RDF.NamedNode;\n  public readonly rdfJson: RDF.NamedNode;\n\n  private readonly parsingContext: ParsingContext;\n\n  constructor(options: { parsingContext: ParsingContext, dataFactory?: RDF.DataFactory<RDF.BaseQuad> }) {\n    this.parsingContext = options.parsingContext;\n    this.dataFactory = options.dataFactory || new DataFactory();\n\n    this.rdfFirst = this.dataFactory.namedNode(Util.RDF + 'first');\n    this.rdfRest = this.dataFactory.namedNode(Util.RDF + 'rest');\n    this.rdfNil = this.dataFactory.namedNode(Util.RDF + 'nil');\n    this.rdfType = this.dataFactory.namedNode(Util.RDF + 'type');\n    this.rdfJson = this.dataFactory.namedNode(Util.RDF + 'JSON');\n  }\n\n  /**\n   * Helper function to get the value of a context entry,\n   * or fallback to a certain value.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} contextKey A pre-defined JSON-LD key in context entries.\n   * @param {string} key A context entry key.\n   * @param {string} fallback A fallback value for when the given contextKey\n   *                          could not be found in the value with the given key.\n   * @return {string} The value of the given contextKey in the entry behind key in the given context,\n   *                  or the given fallback value.\n   */\n  public static getContextValue<FB>(context: JsonLdContextNormalized, contextKey: string,\n                                    key: string, fallback: FB): string | any | FB {\n    const entry = context.getContextRaw()[key];\n    if (!entry) {\n      return fallback;\n    }\n    const type = entry[contextKey];\n    return type === undefined ? fallback : type;\n  }\n\n  /**\n   * Get the container type of the given key in the context.\n   *\n   * Should any context-scoping bugs should occur related to this in the future,\n   * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).\n   * This is because containers act 2 levels deep.\n   *\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The container type.\n   */\n  public static getContextValueContainer(context: JsonLdContextNormalized, key: string):\n    { [typeName: string]: boolean } {\n    return Util.getContextValue(context, '@container', key, { '@set': true });\n  }\n\n  /**\n   * Get the value type of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n  public static getContextValueType(context: JsonLdContextNormalized, key: string): string | null {\n    const valueType = Util.getContextValue(context, '@type', key, null);\n    if (valueType === '@none') {\n      return null;\n    }\n    return valueType;\n  }\n\n  /**\n   * Get the language of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n  public static getContextValueLanguage(context: JsonLdContextNormalized, key: string): string | null {\n    return Util.getContextValue(context, '@language', key, context.getContextRaw()['@language'] || null);\n  }\n\n  /**\n   * Get the direction of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n  public static getContextValueDirection(context: JsonLdContextNormalized, key: string): string {\n    return Util.getContextValue(context, '@direction', key, context.getContextRaw()['@direction'] || null);\n  }\n\n  /**\n   * Check if the given key in the context is a reversed property.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {boolean} If the context value has a @reverse key.\n   */\n  public static isContextValueReverse(context: JsonLdContextNormalized, key: string): boolean {\n    return !!Util.getContextValue(context, '@reverse', key, null);\n  }\n\n  /**\n   * Get the @index of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The index.\n   */\n  public static getContextValueIndex(context: JsonLdContextNormalized, key: string): any | null {\n    return Util.getContextValue(context, '@index', key, context.getContextRaw()['@index'] || null);\n  }\n\n  /**\n   * Check if the given key refers to a reversed property.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The property key.\n   * @param {string} parentKey The parent key.\n   * @return {boolean} If the property must be reversed.\n   */\n  public static isPropertyReverse(context: JsonLdContextNormalized, key: string, parentKey: string): boolean {\n    // '!==' is needed because reversed properties in a @reverse container should cancel each other out.\n    return parentKey === '@reverse' !== Util.isContextValueReverse(context, key);\n  }\n\n  /**\n   * Check if the given key exists inside an embedded node as direct child.\n   * @param {string} parentKey The parent key.\n   * @return {boolean} If the property is embedded.\n   */\n  public static isPropertyInEmbeddedNode(parentKey: string): boolean {\n    return parentKey === '@id';\n  }\n\n  /**\n   * Check if the given key exists inside an annotation object as direct child.\n   * @param {string} parentKey The parent key.\n   * @return {boolean} If the property is an annotation.\n   */\n  public static isPropertyInAnnotationObject(parentKey: string): boolean {\n    return parentKey === '@annotation';\n  }\n\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n  public static isValidIri(iri: string | null): boolean {\n    return iri !== null && ContextUtil.isValidIri(iri);\n  }\n\n  /**\n   * Check if the given first array (needle) is a prefix of the given second array (haystack).\n   * @param needle An array to check if it is a prefix.\n   * @param haystack An array to look in.\n   */\n  public static isPrefixArray(needle: string[], haystack: string[]): boolean {\n    if (needle.length > haystack.length) {\n      return false;\n    }\n    for (let i = 0; i < needle.length; i++) {\n      if (needle[i] !== haystack[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Make sure that @id-@index pairs are equal over all array values.\n   * Reject otherwise.\n   * @param {any[]} value An array value.\n   * @return {Promise<void>} A promise rejecting if conflicts are present.\n   */\n  public async validateValueIndexes(value: any[]): Promise<void> {\n    if (this.parsingContext.validateValueIndexes) {\n      const indexHashes: {[id: string]: any} = {};\n      for (const entry of value) {\n        if (entry && typeof entry === 'object') {\n          const id = entry['@id'];\n          const index = entry['@index'];\n          if (id && index) {\n            const existingIndexValue = indexHashes[id];\n            if (existingIndexValue && existingIndexValue !== index) {\n              throw new ErrorCoded(`Conflicting @index value for ${id}`, ERROR_CODES.CONFLICTING_INDEXES);\n            }\n            indexHashes[id] = index;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert a given JSON value to an RDF term.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The current JSON key.\n   * @param value A JSON value.\n   * @param {number} depth The depth the value is at.\n   * @param {string[]} keys The path of keys.\n   * @return {Promise<RDF.Term[]>} An RDF term array.\n   */\n  public async valueToTerm(context: JsonLdContextNormalized, key: string,\n                           value: any, depth: number, keys: string[]): Promise<RDF.Term[]> {\n    // Skip further processing if we have an @type: @json\n    if (Util.getContextValueType(context, key) === '@json') {\n      return [ this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson) ];\n    }\n\n    const type: string = typeof value;\n    switch (type) {\n    case 'object':\n      // Skip if we have a null or undefined object\n      if (value === null || value === undefined) {\n        return [];\n      }\n\n      // Special case for arrays\n      if (Array.isArray(value)) {\n        // We handle arrays at value level so we can emit earlier, so this is handled already when we get here.\n        // Empty context-based lists are emitted at this place, because our streaming algorithm doesn't detect those.\n        if ('@list' in Util.getContextValueContainer(context, key)) {\n          if (value.length === 0) {\n            return [ this.rdfNil ];\n          } else {\n            return this.parsingContext.idStack[depth + 1] || [];\n          }\n        }\n        await this.validateValueIndexes(value);\n        return [];\n      }\n\n      // Handle property-scoped contexts\n      context = await this.getContextSelfOrPropertyScoped(context, key);\n\n      // Handle local context in the value\n      if ('@context' in value) {\n        context = await this.parsingContext.parseContext(value['@context'],\n          (await this.parsingContext.getContext(keys, 0)).getContextRaw());\n      }\n\n      // In all other cases, we have a hash\n      value = await this.unaliasKeywords(value, keys, depth, context); // Un-alias potential keywords in this hash\n      if ('@value' in value) {\n        let val;\n        let valueLanguage;\n        let valueDirection;\n        let valueType;\n        let valueIndex; // We don't use the index, but we need to check its type for spec-compliance\n        for (key in value) {\n          const subValue = value[key];\n          switch (key) {\n          case '@value':\n            val = subValue;\n            break;\n          case '@language':\n            valueLanguage = subValue;\n            break;\n          case '@direction':\n            valueDirection = subValue;\n            break;\n          case '@type':\n            valueType = subValue;\n            break;\n          case '@index':\n            valueIndex = subValue;\n            break;\n          case '@annotation':\n            // This keyword is allowed, but is processed like normal nodes\n            break;\n          default:\n            throw new ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`,\n              ERROR_CODES.INVALID_VALUE_OBJECT);\n          }\n        }\n\n        // Skip further processing if we have an @type: @json\n        if (await this.unaliasKeyword(valueType, keys, depth, true, context) === '@json') {\n          return [ this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson) ];\n        }\n\n        // Validate @value\n        if (val === null) {\n          return [];\n        }\n        if (typeof val === 'object') {\n          throw new ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`,\n            ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);\n        }\n\n        // Validate @index\n        if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== 'string') {\n          throw new ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`,\n            ERROR_CODES.INVALID_INDEX_VALUE);\n        }\n\n        // Validate @language and @direction\n        if (valueLanguage) {\n          if (typeof val !== 'string') {\n            throw new ErrorCoded(\n              `When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`,\n              ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);\n          }\n\n          if (!ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues,\n            ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {\n            return [];\n          }\n\n          // Language tags are always normalized to lowercase in 1.0.\n          if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1.0) {\n            valueLanguage = valueLanguage.toLowerCase();\n          }\n        }\n        if (valueDirection) {\n          if (typeof val !== 'string') {\n            throw new Error(\n              `When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);\n          }\n\n          if (!ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {\n            return [];\n          }\n        }\n\n        // Check @language and @direction\n        if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {\n          if (valueType) {\n            throw new ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON\n                .stringify(value)}'`,\n              ERROR_CODES.INVALID_VALUE_OBJECT);\n          }\n\n          return this.nullableTermToArray(this\n            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n        } else if (valueLanguage) { // Check @language\n          if (valueType) {\n            throw new ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`,\n              ERROR_CODES.INVALID_VALUE_OBJECT);\n          }\n\n          return [ this.dataFactory.literal(val, valueLanguage) ];\n        } else if (valueDirection && this.parsingContext.rdfDirection) { // Check @direction\n          if (valueType) {\n            throw new ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`,\n              ERROR_CODES.INVALID_VALUE_OBJECT);\n          }\n\n          return this.nullableTermToArray(this\n            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n        } else if (valueType) { // Validate @type\n          if (typeof valueType !== 'string') {\n            throw new ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`,\n              ERROR_CODES.INVALID_TYPED_VALUE);\n          }\n          const typeTerm = this.createVocabOrBaseTerm(context, valueType);\n          if (!typeTerm) {\n            throw new ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`,\n              ERROR_CODES.INVALID_TYPED_VALUE);\n          }\n          if (typeTerm.termType !== 'NamedNode') {\n            throw new ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`,\n              ERROR_CODES.INVALID_TYPED_VALUE);\n          }\n          return [ this.dataFactory.literal(val, typeTerm) ];\n        }\n        // We don't pass the context, because context-based things like @language should be ignored\n        return await this.valueToTerm(new JsonLdContextNormalized({}), key, val, depth, keys);\n      } else if ('@set' in value) {\n        // No other entries are allow in this value\n        if (Object.keys(value).length > 1) {\n          throw new ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`,\n            ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n        }\n\n        // No need to do anything here, this is handled at the deeper level.\n        return [];\n      } else if ('@list' in value) {\n        // No other entries are allowed in this value\n        if (Object.keys(value).length > 1) {\n          throw new ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`,\n            ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n        }\n\n        const listValue = value[\"@list\"];\n        // We handle lists at value level so we can emit earlier, so this is handled already when we get here.\n        // Empty anonymous lists are emitted at this place, because our streaming algorithm doesn't detect those.\n        if (Array.isArray(listValue)) {\n          if (listValue.length === 0) {\n            return [ this.rdfNil ];\n          } else {\n            return this.parsingContext.idStack[depth + 1] || [];\n          }\n        } else {\n          // We only have a single list element here, so emit this directly as single element\n          return await this.valueToTerm(await this.parsingContext.getContext(keys),\n            key, listValue, depth - 1, keys.slice(0, -1));\n        }\n      } else if ('@reverse' in value && typeof value['@reverse'] === 'boolean') {\n        // We handle reverse properties at value level so we can emit earlier,\n        // so this is handled already when we get here.\n        return [];\n      } else if ('@graph' in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {\n        // We are processing a graph container\n        const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];\n        return graphContainerEntries ? Object.values(graphContainerEntries) : [ this.dataFactory.blankNode() ];\n      } else if (\"@id\" in value) {\n        // Use deeper context if the value node contains other properties next to @id.\n        if (Object.keys(value).length > 1) {\n          context = await this.parsingContext.getContext(keys, 0);\n        }\n        // Handle local context in the value\n        if ('@context' in value) {\n          context = await this.parsingContext.parseContext(value['@context'], context.getContextRaw());\n        }\n\n        if (value[\"@type\"] === '@vocab') {\n          return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value[\"@id\"]));\n        } else {\n          const valueId = value[\"@id\"];\n          let valueTerm: RDF.Term | null;\n          if (typeof valueId === 'object') {\n            if (this.parsingContext.rdfstar) {\n              valueTerm = this.parsingContext.idStack[depth + 1][0];\n            } else {\n              throw new ErrorCoded(`Found illegal @id '${value}'`, ERROR_CODES.INVALID_ID_VALUE);\n            }\n          } else {\n            valueTerm = this.resourceToTerm(context, valueId);\n          }\n          return this.nullableTermToArray(valueTerm);\n        }\n      } else {\n        // Only make a blank node if at least one triple was emitted at the value's level.\n        if (this.parsingContext.emittedStack[depth + 1]\n          || (value && typeof value === 'object' && Object.keys(value).length === 0)) {\n          return (this.parsingContext.idStack[depth + 1]\n            || (this.parsingContext.idStack[depth + 1] = [ this.dataFactory.blankNode() ]));\n        } else {\n          return [];\n        }\n      }\n    case 'string':\n      return this.nullableTermToArray(this.stringValueToTerm(depth,\n        await this.getContextSelfOrPropertyScoped(context, key), key, value, null));\n    case 'boolean':\n      return this.nullableTermToArray(this.stringValueToTerm(depth,\n        await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(),\n        this.dataFactory.namedNode(Util.XSD_BOOLEAN)));\n    case 'number':\n      return this.nullableTermToArray(this.stringValueToTerm(depth,\n        await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(\n        value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));\n    default:\n      this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));\n      return [];\n    }\n  }\n\n  /**\n   * If the context defines a property-scoped context for the given key,\n   * that context will be returned.\n   * Otherwise, the given context will be returned as-is.\n   *\n   * This should be used for valueToTerm cases that are not objects.\n   * @param context A context.\n   * @param key A JSON key.\n   */\n  public async getContextSelfOrPropertyScoped(context: JsonLdContextNormalized, key: string)\n    : Promise<JsonLdContextNormalized> {\n    const contextKeyEntry = context.getContextRaw()[key];\n    if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n      context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);\n    }\n    return context;\n  }\n\n  /**\n   * If the given term is null, return an empty array, otherwise return an array with the single given term.\n   * @param term A term.\n   */\n  public nullableTermToArray(term: RDF.Term | null): RDF.Term[] {\n    return term ? [ term ] : [];\n  }\n\n  /**\n   * Convert a given JSON key to an RDF predicate term,\n   * based on @vocab.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node.\n   */\n  public predicateToTerm(context: JsonLdContextNormalized, key: string): RDF.Term | null {\n    const expanded: string | null = context.expandTerm(key, true, this.parsingContext.getExpandOptions());\n\n    // Immediately return if the predicate was disabled in the context\n    if (!expanded) {\n      return null;\n    }\n\n    // Check if the predicate is a blank node\n    if (expanded[0] === '_' && expanded[1] === ':') {\n      if (this.parsingContext.produceGeneralizedRdf) {\n        return this.dataFactory.blankNode(expanded.substr(2));\n      } else {\n        return null;\n      }\n    }\n\n    // Check if the predicate is a valid IRI\n    if (Util.isValidIri(expanded)) {\n      return this.dataFactory.namedNode(expanded);\n    } else {\n      if (expanded && this.parsingContext.strictValues) {\n        this.parsingContext.emitError(new ErrorCoded(`Invalid predicate IRI: ${expanded}`,\n          ERROR_CODES.INVALID_IRI_MAPPING));\n      } else {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Convert a given JSON key to an RDF resource term or blank node,\n   * based on @base.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node or null.\n   */\n  public resourceToTerm(context: JsonLdContextNormalized, key: string): RDF.NamedNode | RDF.BlankNode | null {\n    if (key.startsWith('_:')) {\n      return this.dataFactory.blankNode(key.substr(2));\n    }\n    const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());\n    if (!Util.isValidIri(iri)) {\n      if (iri && this.parsingContext.strictValues) {\n        this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));\n      } else {\n        return null;\n      }\n    }\n    return this.dataFactory.namedNode(<string> iri);\n  }\n\n  /**\n   * Convert a given JSON key to an RDF resource term.\n   * It will do this based on the @vocab,\n   * and fallback to @base.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node or null.\n   */\n  public createVocabOrBaseTerm(context: JsonLdContextNormalized, key: string): RDF.Term | null {\n    if (key.startsWith('_:')) {\n      return this.dataFactory.blankNode(key.substr(2));\n    }\n    const expandOptions = this.parsingContext.getExpandOptions();\n    let expanded = context.expandTerm(key, true, expandOptions);\n    if (expanded === key) {\n      expanded = context.expandTerm(key, false, expandOptions);\n    }\n    if (!Util.isValidIri(expanded)) {\n      if (expanded && this.parsingContext.strictValues && !expanded.startsWith('@')) {\n        this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));\n      } else {\n        return null;\n      }\n    }\n    return this.dataFactory.namedNode(<string> expanded);\n  }\n\n  /**\n   * Ensure that the given value becomes a string.\n   * @param {string | number} value A string or number.\n   * @param {NamedNode} datatype The intended datatype.\n   * @return {string} The returned string.\n   */\n  public intToString(value: string | number, datatype: RDF.NamedNode | null): string {\n    if (typeof value === 'number') {\n      if (Number.isFinite(value)) {\n        const isInteger = value % 1 === 0;\n        if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {\n          return Number(value).toString();\n        } else {\n          return value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n        }\n      } else {\n        return value > 0 ? 'INF' : '-INF';\n      }\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Convert a given JSON string value to an RDF term.\n   * @param {number} depth The current stack depth.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The current JSON key.\n   * @param {string} value A JSON value.\n   * @param {NamedNode} defaultDatatype The default datatype for the given value.\n   * @return {RDF.Term} An RDF term or null.\n   */\n  public stringValueToTerm(depth: number, context: JsonLdContextNormalized, key: string, value: string | number,\n                           defaultDatatype: RDF.NamedNode | null): RDF.Term | null {\n    // Check the datatype from the context\n    const contextType = Util.getContextValueType(context, key);\n    if (contextType) {\n      if (contextType === '@id') {\n        if (!defaultDatatype) {\n          return this.resourceToTerm(context, this.intToString(value, defaultDatatype));\n        }\n      } else if (contextType === '@vocab') {\n        if (!defaultDatatype) {\n          return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));\n        }\n      } else {\n        defaultDatatype = this.dataFactory.namedNode(contextType);\n      }\n    }\n\n    // If we don't find such a datatype, check the language from the context\n    if (!defaultDatatype) {\n      const contextLanguage = Util.getContextValueLanguage(context, key);\n      const contextDirection = Util.getContextValueDirection(context, key);\n      if (contextDirection && this.parsingContext.rdfDirection) {\n        return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype),\n          contextLanguage, contextDirection);\n      } else {\n        return this.dataFactory.literal(this.intToString(value, defaultDatatype),\n          <string | RDF.NamedNode> contextLanguage);\n      }\n    }\n\n    // If all else fails, make a literal based on the default content type\n    return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);\n  }\n\n  /**\n   * Create a literal for the given value with the given language and direction.\n   * Auxiliary quads may be emitted.\n   * @param {number} depth The current stack depth.\n   * @param {string} value A string value.\n   * @param {string} language A language tag.\n   * @param {string} direction A direction.\n   * @return {Term} An RDF term.\n   */\n  public createLanguageDirectionLiteral(depth: number, value: string, language: string | null, direction: string)\n    : RDF.Term {\n    if (this.parsingContext.rdfDirection === 'i18n-datatype') {\n      // Create a datatyped literal, by encoding the language and direction into https://www.w3.org/ns/i18n#.\n      if (!language) {\n        language = '';\n      }\n      return this.dataFactory.literal(value,\n        this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));\n    } else {\n      // Reify the literal.\n      const valueNode = this.dataFactory.blankNode();\n      const graph = this.getDefaultGraph();\n      this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode,\n        this.dataFactory.namedNode(Util.RDF + 'value'), this.dataFactory.literal(value), graph));\n      if (language) {\n        this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode,\n          this.dataFactory.namedNode(Util.RDF + 'language'), this.dataFactory.literal(language), graph));\n      }\n      this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode,\n        this.dataFactory.namedNode(Util.RDF + 'direction'), this.dataFactory.literal(direction), graph));\n      return valueNode;\n    }\n  }\n\n  /**\n   * Stringify the given JSON object to a canonical JSON string.\n   * @param value Any valid JSON value.\n   * @return {string} A canonical JSON string.\n   */\n  public valueToJsonString(value: any): string {\n    return canonicalizeJson(value);\n  }\n\n  /**\n   * If the key is not a keyword, try to check if it is an alias for a keyword,\n   * and if so, un-alias it.\n   * @param {string} key A key, can be falsy.\n   * @param {string[]} keys The path of keys.\n   * @param {number} depth The depth to\n   * @param {boolean} disableCache If the cache should be disabled\n   * @param {JsonLdContextNormalized} context A context to unalias with,\n   *                                           will fallback to retrieving the context for the given keys.\n   * @return {Promise<string>} A promise resolving to the key itself, or another key.\n   */\n  public async unaliasKeyword(key: any, keys: string[], depth: number, disableCache?: boolean,\n                              context?: JsonLdContextNormalized): Promise<any> {\n    // Numbers can not be an alias\n    if (Number.isInteger(key)) {\n      return key;\n    }\n\n    // Try to grab from cache if it was already un-aliased before.\n    if (!disableCache) {\n      const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];\n      if (cachedUnaliasedKeyword) {\n        return cachedUnaliasedKeyword;\n      }\n    }\n\n    if (!ContextUtil.isPotentialKeyword(key)) {\n      context = context || await this.parsingContext.getContext(keys);\n      let unliased = context.getContextRaw()[key];\n      if (unliased && typeof unliased === 'object') {\n        unliased = unliased['@id'];\n      }\n      if (ContextUtil.isValidKeyword(unliased)) {\n        key = unliased;\n      }\n    }\n\n    return disableCache ? key : (this.parsingContext.unaliasedKeywordCacheStack[depth] = key);\n  }\n\n  /**\n   * Unalias the keyword of the parent.\n   * This adds a safety check if no parent exist.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<any>} A promise resolving to the parent key, or another key.\n   */\n  public async unaliasKeywordParent(keys: any[], depth: number): Promise<any> {\n    return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);\n  }\n\n  /**\n   * Un-alias all keywords in the given hash.\n   * @param {{[p: string]: any}} hash A hash object.\n   * @param {string[]} keys The path of keys.\n   * @param {number} depth The depth.\n   * @param {JsonLdContextNormalized} context A context to unalias with,\n   *                                           will fallback to retrieving the context for the given keys.\n   * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.\n   */\n  public async unaliasKeywords(hash: {[id: string]: any}, keys: string[], depth: number,\n                               context?: JsonLdContextNormalized): Promise<{[id: string]: any}> {\n    const newHash: {[id: string]: any} = {};\n    for (const key in hash) {\n      newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];\n    }\n    return newHash;\n  }\n\n  /**\n   * Check if we are processing a literal (including JSON literals) at the given depth.\n   * This will also check higher levels,\n   * because if a parent is a literal,\n   * then the deeper levels are definitely a literal as well.\n   * @param {any[]} keys The keys.\n   * @param {number} depth The depth.\n   * @return {boolean} If we are processing a literal.\n   */\n  public async isLiteral(keys: any[], depth: number): Promise<boolean> {\n    for (let i = depth; i >= 0; i--) {\n      if (await this.unaliasKeyword(keys[i], keys, i) === '@annotation') {\n        // Literals may have annotations, which require processing of inner nodes.\n        return false;\n      }\n      if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check how many parents should be skipped for checking the @graph for the given node.\n   *\n   * @param {number} depth The depth of the node.\n   * @param {any[]} keys An array of keys.\n   * @return {number} The graph depth offset.\n   */\n  public async getDepthOffsetGraph(depth: number, keys: any[]): Promise<number> {\n    for (let i = depth - 1; i > 0; i--) {\n      if (await this.unaliasKeyword(keys[i], keys, i) === '@graph') {\n        // Skip further processing if we are already in an @graph-@id or @graph-@index container\n        const containers = (await EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;\n        if (EntryHandlerContainer.isComplexGraphContainer(containers)) {\n          return -1;\n        }\n\n        return depth - i - 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Check if the given subject is of a valid type.\n   * This should be called when applying @reverse'd properties.\n   * @param {Term} subject A subject.\n   */\n  public validateReverseSubject(subject: RDF.Term) {\n    if (subject.termType === 'Literal') {\n      throw new ErrorCoded(`Found illegal literal in subject position: ${subject.value}`,\n        ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n    }\n  }\n\n  /**\n   * Get the default graph.\n   * @return {Term} An RDF term.\n   */\n  public getDefaultGraph(): RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph {\n    return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();\n  }\n\n  /**\n   * Get the current graph, while taking into account a graph that can be defined via @container: @graph.\n   * If not within a graph container, the default graph will be returned.\n   * @param keys The current keys.\n   * @param depth The current depth.\n   */\n  public async getGraphContainerValue(keys: any[], depth: number)\n    : Promise<RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph> {\n    // Default to default graph\n    let graph: RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph | null = this.getDefaultGraph();\n\n    // Check if we are in an @container: @graph.\n    const { containers, depth: depthContainer } = await EntryHandlerContainer\n      .getContainerHandler(this.parsingContext, keys, depth);\n    if ('@graph' in containers) {\n      // Get the graph from the stack.\n      const graphContainerIndex = EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);\n      const entry = this.parsingContext.graphContainerTermStack[depthContainer];\n      graph = entry ? entry[graphContainerIndex] : null;\n\n      // Set the graph in the stack if none has been set yet.\n      if (!graph) {\n        let graphId: RDF.NamedNode | RDF.BlankNode | null = null;\n        if ('@id' in containers) {\n          const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);\n          if (keyUnaliased !== null) {\n            graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);\n          }\n        }\n        if (!graphId) {\n          graphId = this.dataFactory.blankNode();\n        }\n        if (!this.parsingContext.graphContainerTermStack[depthContainer]) {\n          this.parsingContext.graphContainerTermStack[depthContainer] = {};\n        }\n        graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Get the properties depth for retrieving properties.\n   *\n   * Typically, the properties depth will be identical to the given depth.\n   *\n   * The following exceptions apply:\n   * * When the parent is @reverse, the depth is decremented by one.\n   * * When @nest parents are found, the depth is decremented by the number of @nest parents.\n   * If in combination with the exceptions above an intermediary array is discovered,\n   * the depth is also decremented by this number of arrays.\n   *\n   * @param keys The current key chain.\n   * @param depth The current depth.\n   */\n  public async getPropertiesDepth(keys: any[], depth: number): Promise<number> {\n    let lastValidDepth = depth;\n    for (let i = depth - 1; i > 0; i--) {\n      if (typeof keys[i] !== 'number') { // Skip array keys\n        const parentKey = await this.unaliasKeyword(keys[i], keys, i);\n        if (parentKey === '@reverse') {\n          return i;\n        } else if (parentKey === '@nest') {\n          lastValidDepth = i;\n        } else {\n          return lastValidDepth;\n        }\n      }\n    }\n    return lastValidDepth;\n  }\n\n  /**\n   * Get the key for the current container entry.\n   * @param key A key, can be falsy.\n   * @param keys The key chain.\n   * @param depth The current depth to get the key from.\n   * @return Promise resolving to the key.\n   *         Null will be returned for @none entries, with aliasing taken into account.\n   */\n  public async getContainerKey(key: any, keys: string[], depth: number): Promise<any> {\n    const keyUnaliased = await this.unaliasKeyword(key, keys, depth);\n    return keyUnaliased === '@none' ? null : keyUnaliased;\n  }\n\n  /**\n   * Check if no reverse properties are present in embedded nodes.\n   * @param key The current key.\n   * @param reverse If a reverse property is active.\n   * @param isEmbedded If we're in an embedded node.\n   */\n  public validateReverseInEmbeddedNode(key: string, reverse: boolean, isEmbedded: boolean): void {\n    if (isEmbedded && reverse && !this.parsingContext.rdfstarReverseInEmbedded) {\n      throw new ErrorCoded(`Illegal reverse property in embedded node in ${key}`,\n        ERROR_CODES.INVALID_EMBEDDED_NODE);\n    }\n  }\n\n  /**\n   * Emit a quad, with checks.\n   * @param depth The current depth.\n   * @param subject S\n   * @param predicate P\n   * @param object O\n   * @param graph G\n   * @param reverse If a reverse property is active.\n   * @param isEmbedded If we're in an embedded node.\n   */\n  public emitQuadChecked(\n    depth: number,\n    subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term,\n    reverse: boolean, isEmbedded: boolean,\n  ): void {\n    // Create a quad\n    let quad: RDF.BaseQuad;\n    if (reverse) {\n      this.validateReverseSubject(object);\n      quad = this.dataFactory.quad(object, predicate, subject, graph);\n    } else {\n      quad = this.dataFactory.quad(subject, predicate, object, graph);\n    }\n\n    // Emit the quad, unless it was created in an embedded node\n    if (isEmbedded) {\n      // Embedded nodes don't inherit the active graph\n      if (quad.graph.termType !== 'DefaultGraph') {\n        quad = this.dataFactory.quad(quad.subject, quad.predicate, quad.object);\n      }\n\n      // Multiple embedded nodes are not allowed\n      if (this.parsingContext.idStack[depth - 1]) {\n        throw new ErrorCoded(`Illegal multiple properties in an embedded node`,\n          ERROR_CODES.INVALID_EMBEDDED_NODE)\n      }\n\n      this.parsingContext.idStack[depth - 1] = [ quad ];\n    } else {\n      this.parsingContext.emitQuad(depth, quad);\n    }\n\n    // Flush annotations\n    const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];\n    if (annotationsBuffer) {\n      for (const annotation of annotationsBuffer) {\n        this.emitAnnotation(depth, quad, annotation);\n      }\n      delete this.parsingContext.annotationsBuffer[depth];\n    }\n  }\n\n  // This is a separate function to enable recursion\n  protected emitAnnotation(depth: number, quad: RDF.BaseQuad, annotation: AnnotationsBufferEntry) {\n    // Construct annotation quad\n    let annotationQuad;\n    if (annotation.reverse) {\n      this.validateReverseSubject(annotation.object);\n      annotationQuad = this.dataFactory.quad(annotation.object, annotation.predicate, quad);\n    } else {\n      annotationQuad = this.dataFactory.quad(quad, annotation.predicate, annotation.object);\n    }\n\n    // Emit annotated quad\n    this.parsingContext.emitQuad(depth, annotationQuad);\n\n    // Also emit nested annotations\n    for (const nestedAnnotation of annotation.nestedAnnotations) {\n      this.emitAnnotation(depth, annotationQuad, nestedAnnotation);\n    }\n  }\n\n}\n"]}