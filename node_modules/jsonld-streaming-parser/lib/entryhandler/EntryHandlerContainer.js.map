{"version":3,"file":"EntryHandlerContainer.js","sourceRoot":"","sources":["EntryHandlerContainer.ts"],"names":[],"mappings":"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","sourcesContent":["import {ContainerHandlerIdentifier} from \"../containerhandler/ContainerHandlerIdentifier\";\nimport {ContainerHandlerIndex} from \"../containerhandler/ContainerHandlerIndex\";\nimport {ContainerHandlerLanguage} from \"../containerhandler/ContainerHandlerLanguage\";\nimport {ContainerHandlerType} from \"../containerhandler/ContainerHandlerType\";\nimport {IContainerHandler} from \"../containerhandler/IContainerHandler\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IEntryHandler} from \"./IEntryHandler\";\n\n/**\n * Handles values that are part of a container type (like @index),\n * as specified by {@link IContainerHandler}.\n */\nexport class EntryHandlerContainer implements IEntryHandler<{\n  containers: { [typeName: string]: boolean },\n  handler: IContainerHandler,\n}> {\n\n  public static readonly CONTAINER_HANDLERS: {[id: string]: IContainerHandler} = {\n    '@id': new ContainerHandlerIdentifier(),\n    '@index': new ContainerHandlerIndex(),\n    '@language': new ContainerHandlerLanguage(),\n    '@type': new ContainerHandlerType(),\n  };\n\n  /**\n   * Check fit the given container is a simple @graph container.\n   * Concretely, it will check if no @index or @id is active as well.\n   * @param containers A container hash.\n   */\n  public static isSimpleGraphContainer(containers: {[typeName: string]: boolean}): boolean {\n    return '@graph' in containers\n      && (('@set' in containers && Object.keys(containers).length === 2) || Object.keys(containers).length === 1);\n  }\n\n  /**\n   * Check fit the given container is a complex @graph container.\n   * Concretely, it will check if @index or @id is active as well next to @graph.\n   * @param containers A container hash.\n   */\n  public static isComplexGraphContainer(containers: {[typeName: string]: boolean}): boolean {\n    return '@graph' in containers\n      && (('@set' in containers && Object.keys(containers).length > 2)\n        || (!('@set' in containers) && Object.keys(containers).length > 1));\n  }\n\n  /**\n   * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.\n   * @param containers The applicable containers.\n   * @param depth The container depth.\n   * @param keys The array of keys.\n   * @return The graph index.\n   */\n  public static getContainerGraphIndex(containers: {[typeName: string]: boolean}, depth: number, keys: any[]): string {\n    let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);\n    let index = '';\n    for (let i = depth; i < keys.length; i++) {\n      if (!isSimpleGraphContainer || typeof keys[i] === 'number') {\n        index += ':' + keys[i];\n      }\n      // Only allow a second 'real' key if in a non-simple graph container.\n      if (!isSimpleGraphContainer && typeof keys[i] !== 'number') {\n        isSimpleGraphContainer = true;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Return the applicable container type at the given depth.\n   *\n   * This will ignore any arrays in the key chain.\n   *\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {any[]} keys The array of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}\n   *          All applicable containers for the given depth,\n   *          the `depth` of the container root (can change when arrays are in the key chain),\n   *          and the `fallback` flag that indicates if the default container type was returned\n   *            (i.e., no dedicated container type is defined).\n   */\n  public static async getContainerHandler(parsingContext: ParsingContext, keys: any[], depth: number)\n    : Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }> {\n    const fallback = {\n      containers: { '@set': true },\n      depth,\n      fallback: true,\n    };\n\n    // A flag that is enabled when @graph container should be tested in next iteration\n    let checkGraphContainer = false;\n\n    // Iterate from deeper to higher\n    const context = await parsingContext.getContext(keys, 2);\n    for (let i = depth - 1; i >= 0; i--) {\n      if (typeof keys[i] !== 'number') { // Skip array keys\n        // @graph containers without any other types are one level less deep, and require special handling\n        const containersSelf = Util.getContextValue(context, '@container', keys[i], false);\n        if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {\n          return {\n            containers: containersSelf,\n            depth: i + 1,\n            fallback: false,\n          };\n        }\n\n        const containersParent = Util.getContextValue(context, '@container', keys[i - 1], false);\n        if (!containersParent) { // If we have the fallback container value\n          if (checkGraphContainer) {\n            // Return false if we were already expecting a @graph-@id of @graph-@index container\n            return fallback;\n          }\n\n          // Check parent-parent, we may be in a @graph-@id of @graph-@index container, which have two levels\n          checkGraphContainer = true;\n        } else {\n          // We had an invalid container next iteration, so we now have to check if we were in an @graph container\n          const graphContainer = '@graph' in containersParent;\n\n          // We're in a regular container\n          for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n            if (containersParent[containerHandleName]) {\n              if (graphContainer) {\n                // Only accept graph containers if their combined handlers can handle them.\n                if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {\n                  return {\n                    containers: containersParent,\n                    depth: i,\n                    fallback: false,\n                  };\n                } else {\n                  return fallback;\n                }\n              } else {\n                // Only accept if we were not expecting a @graph-@id of @graph-@index container\n                if (checkGraphContainer) {\n                  return fallback;\n                } else {\n                  return {\n                    containers: containersParent,\n                    depth: i,\n                    fallback: false,\n                  };\n                }\n              }\n            }\n          }\n\n          // Fail if no valid container handlers were found\n          return fallback;\n        }\n      }\n    }\n    return fallback;\n  }\n\n  /**\n   * Check if we are handling a value at the given depth\n   * that is part of something that should be handled as a container,\n   * AND if this container should be buffered, so that it can be handled by a dedicated container handler.\n   *\n   * For instance, any container with @graph will NOT be buffered.\n   *\n   * This will ignore any arrays in the key chain.\n   *\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {any[]} keys The array of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<boolean>} If we are in the scope of a container handler.\n   */\n  public static async isBufferableContainerHandler(parsingContext: ParsingContext, keys: any[], depth: number):\n    Promise<boolean> {\n    const handler = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);\n    return !handler.fallback && !('@graph' in handler.containers);\n  }\n\n  public isPropertyHandler(): boolean {\n    return false;\n  }\n\n  public isStackProcessor(): boolean {\n    return true;\n  }\n\n  public async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean)\n    : Promise<boolean> {\n    return !!await this.test(parsingContext, util, null, keys, depth);\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<{ containers: { [typeName: string]: boolean }, handler: IContainerHandler } | null> {\n    const containers = Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);\n    for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n      if (containers[containerName]) {\n        return {\n          containers,\n          handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName],\n        };\n      }\n    }\n    return null;\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number,\n                      testResult: { containers: { [typeName: string]: boolean }, handler: IContainerHandler })\n    : Promise<any> {\n    return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);\n  }\n\n}\n"]}