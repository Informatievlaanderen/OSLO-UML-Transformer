{"version":3,"file":"EntryHandlerArrayValue.js","sourceRoot":"","sources":["EntryHandlerArrayValue.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from \"@rdfjs/types\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IEntryHandler} from \"./IEntryHandler\";\nimport { ERROR_CODES, ErrorCoded } from 'jsonld-context-parser';\n\n/**\n * Handles values that are part of an array.\n */\nexport class EntryHandlerArrayValue implements IEntryHandler<boolean> {\n\n  public isPropertyHandler(): boolean {\n    return false;\n  }\n\n  public isStackProcessor(): boolean {\n    return true;\n  }\n\n  public async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean)\n    : Promise<boolean> {\n    return this.test(parsingContext, util, null, keys, depth);\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<boolean> {\n    return typeof keys[depth] === 'number';\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    let parentKey = await util.unaliasKeywordParent(keys, depth);\n\n    // Check if we have an anonymous list\n    if (parentKey === '@list') {\n      // Our value is part of an array\n\n      // Determine the list root key\n      let listRootKey: string | number | null = null;\n      let listRootDepth = 0;\n      for (let i = depth - 2; i > 0; i--) {\n        const keyOption = keys[i];\n        if (typeof keyOption === 'string' || typeof keyOption === 'number') {\n          listRootDepth = i;\n          listRootKey = keyOption;\n          break;\n        }\n      }\n\n      if (listRootKey !== null) {\n        // Emit the given objects as list elements\n        const values = await util.valueToTerm(await parsingContext.getContext(keys),\n          <string> listRootKey, value, depth, keys);\n        for (const object of values) {\n          await this.handleListElement(parsingContext, util, object, value, depth,\n            keys.slice(0, listRootDepth), listRootDepth);\n        }\n\n        // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n        if (values.length === 0) {\n          await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n        }\n      }\n    } else if (parentKey === '@set') {\n      // Our value is part of a set, so we just add it to the parent-parent\n      await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);\n    } else if (parentKey !== undefined && parentKey !== '@type') {\n      // Buffer our value using the parent key as predicate\n\n      // Determine the first parent key that is *not* an array key\n      // This is needed in case we have an @list container with nested arrays,\n      // where each of them should produce nested RDF lists.\n      for (let i = depth - 1; i > 0; i--) {\n        if (typeof keys[i] !== 'number') {\n          parentKey = await util.unaliasKeyword(keys[i], keys, i);\n          break;\n        }\n      }\n\n      // Check if the predicate is marked as an @list in the context\n      const parentContext = await parsingContext.getContext(keys.slice(0, -1));\n      if ('@list' in Util.getContextValueContainer(parentContext, parentKey)) {\n        // Our value is part of an array\n        // Emit the given objects as list elements\n        parsingContext.emittedStack[depth + 1] = true; // Ensure the creation of bnodes for empty nodes\n        const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);\n\n        for (const object of values) {\n          await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);\n        }\n\n        // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n        if (values.length === 0) {\n          await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);\n        }\n      } else {\n        // Copy the stack values up one level so that the next job can access them.\n        parsingContext.shiftStack(depth, 1);\n\n        // Execute the job one level higher\n        await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);\n\n        // Remove any defined contexts at this level to avoid it to propagate to the next array element.\n        parsingContext.contextTree.removeContext(keys.slice(0, -1));\n      }\n    }\n  }\n\n  protected async handleListElement(parsingContext: ParsingContext, util: Util, value: RDF.Term | null,\n                                    valueOriginal: any, depth: number, listRootKeys: string[], listRootDepth: number) {\n    // Buffer our value as an RDF list using the listRootKey as predicate\n    let listPointer = parsingContext.listPointerStack[depth];\n\n    if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))['@value'] !== null) {\n      if (!listPointer || !listPointer.value) {\n        const linkTerm: RDF.BlankNode = util.dataFactory.blankNode();\n        listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };\n      } else {\n        // rdf:rest links are always emitted before the next element,\n        // as the blank node identifier is only created at that point.\n        // Because of this reason, the final rdf:nil is emitted when the stack depth is decreased.\n        const newLinkTerm: RDF.Term = util.dataFactory.blankNode();\n        parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm,\n          util.getDefaultGraph()));\n\n        // Update the list pointer for the next element\n        listPointer.value = newLinkTerm;\n      }\n\n      // Emit a list element for the current value\n      // Omit rdf:first if the value is invalid\n      if (value) {\n        parsingContext.emitQuad(depth, util.dataFactory.quad(<RDF.Term>listPointer.value, util.rdfFirst, value,\n          util.getDefaultGraph()));\n      }\n    } else {\n      // A falsy list element if found.\n      // Mark it as an rdf:nil list until another valid list element comes in\n      if (!listPointer) {\n        listPointer = { listRootDepth, listId: util.rdfNil };\n      }\n    }\n\n    parsingContext.listPointerStack[depth] = listPointer;\n\n    // Error if an annotation was defined\n    if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {\n      parsingContext.emitError(new ErrorCoded(`Found an illegal annotation inside a list`,\n        ERROR_CODES.INVALID_ANNOTATION));\n    }\n  }\n\n}\n"]}