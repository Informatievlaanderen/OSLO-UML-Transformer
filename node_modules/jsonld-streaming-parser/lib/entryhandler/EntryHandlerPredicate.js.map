{"version":3,"file":"EntryHandlerPredicate.js","sourceRoot":"","sources":["EntryHandlerPredicate.ts"],"names":[],"mappings":";;;AAAA,iEAA8D;AAG9D,kCAA6B;AAG7B;;;GAGG;AACH,MAAa,qBAAqB;IAEhC;;;;;;;;;;;;;OAaG;IACI,MAAM,CAAC,KAAK,CAAC,qBAAqB,CAAC,cAA8B,EAAE,IAAU,EAAE,IAAW,EAAE,KAAa,EACtE,SAAmB,EAAE,MAAgB,EACrC,OAAgB,EAAE,UAAmB,EAAE,YAAqB;QACpG,MAAM,eAAe,GAAW,MAAM,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC3E,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACrE,MAAM,oBAAoB,GAAW,KAAK,GAAG,gBAAgB,CAAC;QAE9D,MAAM,QAAQ,GAAG,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QACzD,IAAI,QAAQ,IAAI,CAAC,YAAY,EAAE;YAC7B,+CAA+C;YAC/C,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,qCAAqC;gBACrC,MAAM,OAAO,GAAG,gBAAgB,IAAI,CAAC,CAAC;gBACtC,IAAI,OAAO,EAAE;oBACX,MAAM,MAAM,GAAG,cAAc,CAAC,OAAO,CAAC,oBAAoB,GAAG,CAAC,CAAC,CAAC;oBAChE,IAAI,MAAM,EAAE;wBACV,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;4BAC1B,sCAAsC;4BACtC,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;yBACrF;qBACF;yBAAM;wBACL,mDAAmD;wBACnD,IAAI,OAAO,EAAE;4BACX,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;4BACpC,cAAc,CAAC,8BAA8B,CAAC,oBAAoB,GAAG,CAAC,CAAC,CAAC,IAAI,CAC1E,EAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC;yBAC/D;6BAAM;4BACL,cAAc,CAAC,8BAA8B,CAAC,oBAAoB,GAAG,CAAC,CAAC;iCACpE,IAAI,CAAC,EAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,EAAC,CAAC,CAAC;yBACnD;qBACF;iBACF;qBAAM;oBACL,mCAAmC;oBACnC,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;oBACvE,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;iBACrF;aACF;SACF;aAAM;YACL,4DAA4D;YAC5D,IAAI,OAAO,EAAE;gBACX,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;aACrC;YAED,4DAA4D;YAC5D,IAAI,YAAY,EAAE;gBAChB,2CAA2C;gBAC3C,IAAI,cAAc,CAAC,OAAO,EAAE;oBAC1B,8BAA8B;oBAC9B,IAAI,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;wBACjC,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,8CAA8C,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,EAC5H,mCAAW,CAAC,kBAAkB,CAAC,CAAC,CAAC;qBACpC;oBAED,qCAAqC;oBACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;wBAC9B,IAAI,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;4BACzD,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,qDAAqD,EAC3F,mCAAW,CAAC,kBAAkB,CAAC,CAAC,CAAC;yBACpC;qBACF;oBAED,qCAAqC;oBACrC,MAAM,iBAAiB,GAAG,cAAc,CAAC,wBAAwB,CAAC,eAAe,CAAC,CAAC;oBACnF,MAAM,aAAa,GAA2B,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,iBAAiB,EAAE,EAAE,EAAE,KAAK,EAAE,eAAe,EAAE,CAAC;oBAC5H,iBAAiB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;oBAEtC,yEAAyE;oBACzE,iDAAiD;oBACjD,KAAK,IAAI,CAAC,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;wBACtD,0EAA0E;wBAC1E,MAAM,kBAAkB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;wBAChD,IAAI,kBAAkB,CAAC,KAAK,GAAG,eAAe,EAAE;4BAC9C,aAAa,CAAC,iBAAiB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;4BACzD,iBAAiB,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;yBAChC;qBACF;iBACF;aACF;iBAAM;gBACL,cAAc,CAAC,8BAA8B,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC;aACjH;SACF;IACH,CAAC;IAEM,iBAAiB;QACtB,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,gBAAgB;QACrB,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,QAAQ,CAAC,cAA8B,EAAE,IAAU,EAAE,IAAW,EAAE,KAAa,EAAE,UAAmB;QAE/G,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;QACxB,IAAI,GAAG,EAAE;YACP,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC/F,gHAAgH;gBAChH,IAAI,WAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,GAAG,CAAC,KAAK,OAAO,EAAE;oBACtD,cAAc,CAAC,gBAAgB,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;iBACnD;gBACD,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAa;QAEhG,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAU,EAAE,KAAa,EAC5F,UAAmB;QACrC,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;QAChC,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEtD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;QAC3D,IAAI,SAAS,EAAE;YACb,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YACzE,IAAI,OAAO,CAAC,MAAM,EAAE;gBAClB,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;oBAC1B,mEAAmE;oBACnE,IAAI,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBAC7D,MAAM,OAAO,GAAG,WAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;oBACxE,IAAI,iBAAiB,GAAG,CAAC,CAAC;oBAC1B,OAAO,SAAS,KAAK,UAAU,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;wBAChE,8EAA8E;wBAC9E,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;4BACjC,iBAAiB,EAAE,CAAC;yBACrB;6BAAM;4BACL,KAAK,EAAE,CAAC;yBACT;wBACD,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,GAAG,iBAAiB,CAAC,CAAC;qBAC9E;oBACD,MAAM,UAAU,GAAG,WAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;oBAC5D,IAAI,CAAC,6BAA6B,CAAC,GAAG,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;oBAC7D,MAAM,YAAY,GAAG,WAAI,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC;oBAElE,IAAI,KAAK,EAAE;wBACT,oFAAoF;wBACpF,qEAAqE;wBACrE,MAAM,kBAAkB,GAAG,OAAO,IAAI,WAAI,CAAC,wBAAwB,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;wBAClF,IAAI,kBAAkB,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE;4BACxC,IAAI,CAAC,CAAC,kBAAkB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;mCAChE,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;mCACnD,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;gCAC3B,MAAM,WAAW,GAAa,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;gCAC3D,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EACzF,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;gCAC3B,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,EACrF,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;gCAC3B,MAAM,GAAG,WAAW,CAAC;6BACtB;4BAED,iDAAiD;4BACjD,IAAI,OAAO,IAAI,CAAC,cAAc,CAAC,gBAAgB,EAAE;gCAC/C,MAAM,IAAI,kCAAU,CAAC,mDAAmD,GAAG,EAAE,EAC3E,mCAAW,CAAC,8BAA8B,CAAC,CAAC;6BAC/C;yBACF;qBACF;oBAED,MAAM,qBAAqB,CAAC,qBAAqB,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EACjF,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;iBACzD;aACF;SACF;IACH,CAAC;CAEF;AA1LD,sDA0LC","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport * as RDF from \"@rdfjs/types\";\nimport { AnnotationsBufferEntry, ParsingContext } from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IEntryHandler} from \"./IEntryHandler\";\n\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\nexport class EntryHandlerPredicate implements IEntryHandler<boolean> {\n\n  /**\n   * Handle the given predicate-object by either emitting it,\n   * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {Util} util A utility instance.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth The current depth.\n   * @param {Term} predicate The predicate.\n   * @param {Term} object The object.\n   * @param {boolean} reverse If the property is reversed.\n   * @param {boolean} isEmbedded If the property exists in an embedded node as direct child.\n   * @param {boolean} isAnnotation If the property exists in an annotation object.\n   * @return {Promise<void>} A promise resolving when handling is done.\n   */\n  public static async handlePredicateObject(parsingContext: ParsingContext, util: Util, keys: any[], depth: number,\n                                            predicate: RDF.Term, object: RDF.Term,\n                                            reverse: boolean, isEmbedded: boolean, isAnnotation: boolean) {\n    const depthProperties: number = await util.getPropertiesDepth(keys, depth);\n    const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n    const depthPropertiesGraph: number = depth - depthOffsetGraph;\n\n    const subjects = parsingContext.idStack[depthProperties];\n    if (subjects && !isAnnotation) {\n      // Emit directly if the @id was already defined\n      for (const subject of subjects) {\n        // Check if we're in a @graph context\n        const atGraph = depthOffsetGraph >= 0;\n        if (atGraph) {\n          const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n          if (graphs) {\n            for (const graph of graphs) {\n              // Emit our quad if graph @id is known\n              util.emitQuadChecked(depth, subject, predicate, object, graph, reverse, isEmbedded);\n            }\n          } else {\n            // Buffer our triple if graph @id is not known yet.\n            if (reverse) {\n              util.validateReverseSubject(object);\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push(\n                {subject: object, predicate, object: subject, isEmbedded });\n            } else {\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1)\n                .push({subject, predicate, object, isEmbedded});\n            }\n          }\n        } else {\n          // Emit if no @graph was applicable\n          const graph = await util.getGraphContainerValue(keys, depthProperties);\n          util.emitQuadChecked(depth, subject, predicate, object, graph, reverse, isEmbedded);\n        }\n      }\n    } else {\n      // Buffer until our @id becomes known, or we go up the stack\n      if (reverse) {\n        util.validateReverseSubject(object);\n      }\n\n      // Either push to the annotations or the actual value buffer\n      if (isAnnotation) {\n        // Only add to buffer if rdfstar is enabled\n        if (parsingContext.rdfstar) {\n          // Error if an @id was defined\n          if (parsingContext.idStack[depth]) {\n            parsingContext.emitError(new ErrorCoded(`Found an illegal @id inside an annotation: ${parsingContext.idStack[depth][0].value}`,\n              ERROR_CODES.INVALID_ANNOTATION));\n          }\n\n          // Error if we're in an embedded node\n          for (let i = 0; i < depth; i++) {\n            if (await util.unaliasKeyword(keys[i], keys, i) === '@id') {\n              parsingContext.emitError(new ErrorCoded(`Found an illegal annotation inside an embedded node`,\n                ERROR_CODES.INVALID_ANNOTATION));\n            }\n          }\n\n          // Store new annotation in the buffer\n          const annotationsBuffer = parsingContext.getAnnotationsBufferSafe(depthProperties);\n          const newAnnotation: AnnotationsBufferEntry = { predicate, object, reverse, nestedAnnotations: [], depth: depthProperties };\n          annotationsBuffer.push(newAnnotation);\n\n          // Check in the buffer if any annotations were defined at a deeper depth,\n          // if so, they are considered nested annotations.\n          for (let i = annotationsBuffer.length - 2; i >= 0; i--) {\n            // We iterate in reverse order, to enable easy item removal from the back.\n            const existingAnnotation = annotationsBuffer[i];\n            if (existingAnnotation.depth > depthProperties) {\n              newAnnotation.nestedAnnotations.push(existingAnnotation);\n              annotationsBuffer.splice(i, 1);\n            }\n          }\n        }\n      } else {\n        parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object, reverse, isEmbedded });\n      }\n    }\n  }\n\n  public isPropertyHandler(): boolean {\n    return true;\n  }\n\n  public isStackProcessor(): boolean {\n    return true;\n  }\n\n  public async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean)\n    : Promise<boolean> {\n    const key = keys[depth];\n    if (key) {\n      const context = await parsingContext.getContext(keys);\n      if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {\n        // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n        if (Util.getContextValueType(context, key) === '@json') {\n          parsingContext.jsonLiteralStack[depth + 1] = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<boolean> {\n    return keys[depth];\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number,\n                      testResult: boolean): Promise<any> {\n    const keyOriginal = keys[depth];\n    const context = await parsingContext.getContext(keys);\n\n    const predicate = await util.predicateToTerm(context, key);\n    if (predicate) {\n      const objects = await util.valueToTerm(context, key, value, depth, keys);\n      if (objects.length) {\n        for (let object of objects) {\n          // Based on parent key, check if reverse, embedded, and annotation.\n          let parentKey = await util.unaliasKeywordParent(keys, depth);\n          const reverse = Util.isPropertyReverse(context, keyOriginal, parentKey);\n          let parentDepthOffset = 0;\n          while (parentKey === '@reverse' || typeof parentKey === 'number') {\n            // Check parent of parent when checking while we're in an array or in @reverse\n            if (typeof parentKey === 'number') {\n              parentDepthOffset++;\n            } else {\n              depth--;\n            }\n            parentKey = await util.unaliasKeywordParent(keys, depth - parentDepthOffset);\n          }\n          const isEmbedded = Util.isPropertyInEmbeddedNode(parentKey);\n          util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);\n          const isAnnotation = Util.isPropertyInAnnotationObject(parentKey);\n\n          if (value) {\n            // Special case if our term was defined as an @list, but does not occur in an array,\n            // In that case we just emit it as an RDF list with a single element.\n            const listValueContainer = '@list' in Util.getContextValueContainer(context, key);\n            if (listValueContainer || value['@list']) {\n              if (((listValueContainer && !Array.isArray(value) && !value['@list'])\n                || (value['@list'] && !Array.isArray(value['@list'])))\n                && object !== util.rdfNil) {\n                const listPointer: RDF.Term = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil,\n                  util.getDefaultGraph()));\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object,\n                  util.getDefaultGraph()));\n                object = listPointer;\n              }\n\n              // Lists are not allowed in @reverse'd properties\n              if (reverse && !parsingContext.allowSubjectList) {\n                throw new ErrorCoded(`Found illegal list value in subject position at ${key}`,\n                  ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n              }\n            }\n          }\n\n          await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth,\n            predicate, object, reverse, isEmbedded, isAnnotation);\n        }\n      }\n    }\n  }\n\n}\n"]}