{"version":3,"file":"EntryHandlerKeywordValue.js","sourceRoot":"","sources":["EntryHandlerKeywordValue.ts"],"names":[],"mappings":";;;AAEA,+DAA0D;AAE1D;;GAEG;AACH,MAAa,wBAAyB,SAAQ,yCAAmB;IAE/D;QACE,KAAK,CAAC,QAAQ,CAAC,CAAC;IAClB,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,cAA8B,EAAE,IAAU,EAAE,IAAW,EAAE,KAAa,EAAE,UAAmB;QACxG,yFAAyF;QACzF,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;QACxB,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE;YACzG,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;SAC3C;QAED,OAAO,KAAK,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;IACvE,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAa;QAEhG,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,QAAQ,CAAC;IAC9G,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAU,EAAE,KAAa;QAE9G,oEAAoE;QACpE,gGAAgG;QAChG,iFAAiF;QACjF,+BAA+B;QAE/B,0GAA0G;QAC1G,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;QAE1C,6DAA6D;QAC7D,OAAO,cAAc,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;QACtD,OAAO,cAAc,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;QAEtD,kDAAkD;QAClD,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;IAC7C,CAAC;CAEF;AAvCD,4DAuCC","sourcesContent":["import {ParsingContext} from \"../../ParsingContext\";\nimport {Util} from \"../../Util\";\nimport {EntryHandlerKeyword} from \"./EntryHandlerKeyword\";\n\n/**\n * Handles @value entries.\n */\nexport class EntryHandlerKeywordValue extends EntryHandlerKeyword {\n\n  constructor() {\n    super('@value');\n  }\n\n  async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean): Promise<boolean> {\n    // If this is @value, mark it so in the stack so that no deeper handling of nodes occurs.\n    const key = keys[depth];\n    if (key && !parsingContext.literalStack[depth] && await this.test(parsingContext, util, key, keys, depth)) {\n      parsingContext.literalStack[depth] = true;\n    }\n\n    return super.validate(parsingContext, util, keys, depth, inProperty);\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<boolean> {\n    return await util.unaliasKeyword(keys[depth], keys.slice(0, keys.length - 1), depth - 1, true) === '@value';\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    // If the value is valid, indicate that we are processing a literal.\n    // The actual value will be determined at the parent level when the @value is part of an object,\n    // because we may want to take into account additional entries such as @language.\n    // See {@link Util.valueToTerm}\n\n    // Indicate that we are processing a literal, and that no later predicates should be parsed at this depth.\n    parsingContext.literalStack[depth] = true;\n\n    // Void any buffers that we may have accumulated up until now\n    delete parsingContext.unidentifiedValuesBuffer[depth];\n    delete parsingContext.unidentifiedGraphsBuffer[depth];\n\n    // Indicate that we have not emitted at this depth\n    parsingContext.emittedStack[depth] = false;\n  }\n\n}\n"]}