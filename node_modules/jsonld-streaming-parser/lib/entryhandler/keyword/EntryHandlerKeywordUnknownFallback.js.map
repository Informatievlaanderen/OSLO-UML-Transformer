{"version":3,"file":"EntryHandlerKeywordUnknownFallback.js","sourceRoot":"","sources":["EntryHandlerKeywordUnknownFallback.ts"],"names":[],"mappings":";;;AAAA,iEAAmF;AAKnF;;;GAGG;AACH,MAAa,kCAAkC;IAUtC,iBAAiB;QACtB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,gBAAgB;QACrB,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,QAAQ,CAAC,cAA8B,EAAE,IAAU,EAAE,IAAW,EAAE,KAAa,EAAE,UAAmB;QAE/G,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAChE,IAAI,4BAAW,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE;YACvC,iDAAiD;YACjD,IAAI,CAAC,UAAU,EAAE;gBACf,IAAI,GAAG,KAAK,OAAO,EAAE;oBACnB,OAAO,KAAK,CAAC;iBACd;aACF;YAED,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAa;QAEhG,OAAO,4BAAW,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;IAC7C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAU,EAAE,KAAa;QAE9G,MAAM,WAAW,GAAG,kCAAkC,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;QACjF,IAAI,WAAW,KAAK,SAAS,EAAE;YAC7B,IAAI,WAAW,IAAI,OAAO,KAAK,KAAK,WAAW,CAAC,IAAI,EAAE;gBACpD,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,2BAA2B,GAAG,iBAAiB,KAAK,GAAG,EAC7F,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC;aAC3B;SACF;aAAM,IAAI,cAAc,CAAC,YAAY,EAAE;YACtC,cAAc,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,oBAAoB,GAAG,iBAAiB,KAAK,GAAG,CAAC,CAAC,CAAC;SACvF;QACD,cAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;IAC7C,CAAC;;AAjDuB,uDAAoB,GAA+D;IACzG,QAAQ,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,mCAAW,CAAC,mBAAmB,EAAE;IACxE,OAAO,EAAE,IAAI;IACb,UAAU,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,mCAAW,CAAC,qBAAqB,EAAE;IAC5E,MAAM,EAAE,IAAI;IACZ,QAAQ,EAAE,IAAI;CACf,CAAC;AARS,gFAAkC","sourcesContent":["import {ERROR_CODES, ErrorCoded, Util as ContextUtil} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../../ParsingContext\";\nimport {Util} from \"../../Util\";\nimport {IEntryHandler} from \"../IEntryHandler\";\n\n/**\n * A catch-all for keywords, that will either emit an error or ignore,\n * depending on whether or not the `strictValues` property is set.\n */\nexport class EntryHandlerKeywordUnknownFallback implements IEntryHandler<boolean> {\n\n  private static readonly VALID_KEYWORDS_TYPES: {[id: string]: { type: string, errorCode: string } | null} = {\n    '@index': { type: 'string', errorCode: ERROR_CODES.INVALID_INDEX_VALUE },\n    '@list': null,\n    '@reverse': { type: 'object', errorCode: ERROR_CODES.INVALID_REVERSE_VALUE },\n    '@set': null,\n    '@value': null,\n  };\n\n  public isPropertyHandler(): boolean {\n    return false;\n  }\n\n  public isStackProcessor(): boolean {\n    return true;\n  }\n\n  public async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean)\n    : Promise<boolean> {\n    const key = await util.unaliasKeyword(keys[depth], keys, depth);\n    if (ContextUtil.isPotentialKeyword(key)) {\n      // Don't emit anything inside free-floating lists\n      if (!inProperty) {\n        if (key === '@list') {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<boolean> {\n    return ContextUtil.isPotentialKeyword(key);\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    const keywordType = EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES[key];\n    if (keywordType !== undefined) {\n      if (keywordType && typeof value !== keywordType.type) {\n        parsingContext.emitError(new ErrorCoded(`Invalid value type for '${key}' with value '${value}'`,\n          keywordType.errorCode));\n      }\n    } else if (parsingContext.strictValues) {\n      parsingContext.emitError(new Error(`Unknown keyword '${key}' with value '${value}'`));\n    }\n    parsingContext.emittedStack[depth] = false;\n  }\n\n}\n"]}