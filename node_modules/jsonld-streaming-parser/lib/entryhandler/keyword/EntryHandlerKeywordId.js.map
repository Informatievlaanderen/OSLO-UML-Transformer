{"version":3,"file":"EntryHandlerKeywordId.js","sourceRoot":"","sources":["EntryHandlerKeywordId.ts"],"names":[],"mappings":";;;AAAA,iEAA8D;AAG9D,+DAA0D;AAE1D;;GAEG;AACH,MAAa,qBAAsB,SAAQ,yCAAmB;IAE5D;QACE,KAAK,CAAC,KAAK,CAAC,CAAC;IACf,CAAC;IAEM,gBAAgB;QACrB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAU,EAAE,KAAa;QAE9G,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,wCAAwC;YACxC,IAAI,cAAc,CAAC,OAAO,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBACvD,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;oBACpD,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,mDAAmD,KAAK,CAAC,KAAK,CAAC,EAAE,EACvG,mCAAW,CAAC,qBAAqB,CAAC,CAAC,CAAC;iBACvC;aACF;iBAAM;gBACL,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,sBAAsB,KAAK,GAAG,EAAE,mCAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC;aACxG;YACD,OAAO;SACR;QAED,6CAA6C;QAC7C,gDAAgD;QAChD,MAAM,eAAe,GAAW,MAAM,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE3E,iDAAiD;QACjD,IAAI,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,SAAS,EAAE;YACzD,IAAW,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAE,CAAC,QAAQ,EAAE;gBAC/D,sDAAsD;gBACtD,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CACrC,8DAA8D,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,EAChF,mCAAW,CAAC,0BAA0B,CAAC,CAAC,CAAC;aAC5C;iBAAM;gBACL,+DAA+D;gBAC/D,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,yBAAyB,cAAc;qBAC5E,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,KAAK,GAAG,EAAE,mCAAW,CAAC,kBAAkB,CAAC,CAAC,CAAC;aAC1F;SACF;QAED,qCAAqC;QACrC,IAAI,cAAc,CAAC,OAAO,IAAI,cAAc,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;YACrE,KAAK,MAAM,UAAU,IAAI,cAAc,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;gBAChE,IAAI,UAAU,CAAC,KAAK,KAAK,KAAK,EAAE;oBAC9B,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,8CAA8C,KAAK,EAAE,EAC3F,mCAAW,CAAC,kBAAkB,CAAC,CAAC,CAAC;iBACpC;aACF;SACF;QAED,4BAA4B;QAC5B,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,IAAI,CAAC,cAAc,CAC1F,MAAM,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IACnD,CAAC;CAEF;AA3DD,sDA2DC","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../../ParsingContext\";\nimport {Util} from \"../../Util\";\nimport {EntryHandlerKeyword} from \"./EntryHandlerKeyword\";\n\n/**\n * Handles @id entries.\n */\nexport class EntryHandlerKeywordId extends EntryHandlerKeyword {\n\n  constructor() {\n    super('@id');\n  }\n\n  public isStackProcessor(): boolean {\n    return false;\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    if (typeof value !== 'string') {\n      // JSON-LD-star allows @id object values\n      if (parsingContext.rdfstar && typeof value === 'object') {\n        const valueKeys = Object.keys(value);\n        if (valueKeys.length === 1 && valueKeys[0] === '@id') {\n          parsingContext.emitError(new ErrorCoded(`Invalid embedded node without property with @id ${value['@id']}`,\n            ERROR_CODES.INVALID_EMBEDDED_NODE));\n        }\n      } else {\n        parsingContext.emitError(new ErrorCoded(`Found illegal @id '${value}'`, ERROR_CODES.INVALID_ID_VALUE));\n      }\n      return;\n    }\n\n    // Determine the canonical place for this id.\n    // For example, @nest parents should be ignored.\n    const depthProperties: number = await util.getPropertiesDepth(keys, depth);\n\n    // Error if an @id for this node already existed.\n    if (parsingContext.idStack[depthProperties] !== undefined) {\n      if ((<any> parsingContext.idStack[depthProperties][0]).listHead) {\n        // Error if an @list was already defined for this node\n        parsingContext.emitError(new ErrorCoded(\n          `Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`,\n          ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));\n      } else {\n        // Otherwise, the previous id was just because of an @id entry.\n        parsingContext.emitError(new ErrorCoded(`Found duplicate @ids '${parsingContext\n          .idStack[depthProperties][0].value}' and '${value}'`, ERROR_CODES.COLLIDING_KEYWORDS));\n      }\n    }\n\n    // Error if an annotation was defined\n    if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {\n      for (const annotation of parsingContext.annotationsBuffer[depth]) {\n        if (annotation.depth === depth) {\n          parsingContext.emitError(new ErrorCoded(`Found an illegal @id inside an annotation: ${value}`,\n            ERROR_CODES.INVALID_ANNOTATION));\n        }\n      }\n    }\n\n    // Save our @id on the stack\n    parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(\n      await parsingContext.getContext(keys), value));\n  }\n\n}\n"]}