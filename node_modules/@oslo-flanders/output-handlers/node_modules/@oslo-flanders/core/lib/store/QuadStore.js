"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadStore = void 0;
const inversify_1 = require("inversify");
const N3 = __importStar(require("n3"));
const rdf_parse_1 = __importDefault(require("rdf-parse"));
const fetchFileOrUrl_1 = require("../utils/fetchFileOrUrl");
const namespaces_1 = require("../utils/namespaces");
let QuadStore = class QuadStore {
    constructor() {
        this.store = new N3.Store();
    }
    addQuads(quads) {
        this.store.addQuads(quads);
    }
    addQuad(quad) {
        this.store.addQuad(quad);
    }
    async addQuadsFromFile(file) {
        const buffer = await (0, fetchFileOrUrl_1.fetchFileOrUrl)(file);
        const textStream = require('streamify-string')(buffer.toString());
        return new Promise((resolve, reject) => {
            rdf_parse_1.default.parse(textStream, { path: file })
                .on('data', (quad) => this.store.addQuad(quad))
                .on('error', (error) => reject(error))
                .on('end', () => resolve());
        });
    }
    findQuads(subject, predicate, object) {
        return this.store.getQuads(subject, predicate, object, null);
    }
    findQuad(subject, predicate, object) {
        return this.findQuads(subject, predicate, object).shift();
    }
    findSubjects(predicate, object) {
        return this.store.getSubjects(predicate, object, null);
    }
    findSubject(predicate, object) {
        return this.findSubjects(predicate, object).shift();
    }
    findObjects(subject, predicate) {
        return this.store.getObjects(subject, predicate, null);
    }
    findObject(subject, predicate) {
        return this.findObjects(subject, predicate).shift();
    }
    /**
     * Finds the subject where predicate is 'rdf:type' and object 'example:Package'
     * @returns a RDF.NamedNode or undefined
     */
    getPackageId() {
        return this.store.getSubjects(namespaces_1.ns.rdf('type'), namespaces_1.ns.example('Package'), null).shift();
    }
    /**
     * Finds all subjects where predicate is 'rdf:type' and object 'owl:Class'
     * @returns an array of RDF.NamedNodes
     */
    getClassIds() {
        return this.store.getSubjects(namespaces_1.ns.rdf('type'), namespaces_1.ns.owl('Class'), null);
    }
    /**
   * Finds all subjects where predicate is 'rdf:type' and object 'owl:DatatypeProperty'
   * @returns an array of RDF.NamedNodes
   */
    getDatatypePropertyIds() {
        return this.store.getSubjects(namespaces_1.ns.rdf('type'), namespaces_1.ns.owl('DatatypeProperty'), null);
    }
    /**
   * Finds all subjects where predicate is 'rdf:type' and object 'owl:ObjectProperty'
   * @returns an array of RDF.NamedNodes
   */
    getObjectPropertyIds() {
        return this.store.getSubjects(namespaces_1.ns.rdf('type'), namespaces_1.ns.owl('ObjectProperty'), null);
    }
    /**
     * For a given subject, the quad store is queried to find the assigned URI
     * @param subject The subject for which the assigned URI is to be retrieved
     * @param store The quad store
     * @returns An RDF.NamedNode or undefined if not found
     */
    getAssignedUri(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.example('assignedUri'), null).shift();
    }
    /**
     * Find all rdfs:labels for a given subject
     * @param subject The RDF.Term to find the rdfs:labels for
     * @param store A N3 quad store
     * @returns An array of RDF.Literals
     */
    getLabels(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('label'), null);
    }
    /**
     * Finds the rdfs:label whose language tag matches the given language
     * @param subject The RDF.Term to find the rdfs:label for
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getLabel(subject, language) {
        return this.getLabels(subject).find(x => x.language === (language || ''));
    }
    /**
     * Find all rdfs:comments for a given subject
     * @param subject The RDF.Term to find the rdfs:comments for
     * @param store A N3 quad store
     * @returns An array of RDF.Literals
     */
    getDefinitions(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('comment'), null);
    }
    /**
     * Finds the rdfs:comment whose language tag matches the given language
     * @param subject The RDF.Term to find the rdfs:comment for
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getDefinition(subject, language) {
        return this.getDefinitions(subject).find(x => x.language === (language || ''));
    }
    /**
     * Finds the rdfs:range of a given RDF.Term
     * @param subject The RDF.Term to find the range of
     * @param store A N3 quad store
     * @returns An RDF.Term or undefined if not found
     */
    getRange(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('range'), null).shift();
    }
    /**
     * Finds the rdfs:domain of a given RDF.Term
     * @param subject The RDF.Term to find the domain of
     * @param store A N3 quad store
     * @returns An RDF.Term or undefined if not found
     */
    getDomain(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('domain'), null).shift();
    }
    /**
     * Finds all the vann:usageNotes of a given RDF.Term
     * @param subject The RDF.Term to find the usage notes for
     * @param store A N3 quad store
     * @returns An array of RDF.Literals
     */
    getUsageNotes(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.vann('usageNote'), null);
    }
    /**
     * Finds the vann:usageNote of which the language tag matches the given language
     * @param subject The RDF.Term to find the usage note for
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getUsageNote(subject, language) {
        return this.getUsageNotes(subject).find(x => x.language === (language || ''));
    }
    /**
     * Finds the example:scope of a given subject
     * @param subject The RDF.Term to find the scope for
     * @returns An RDF.NamedNode or undefined if not found
     */
    getScope(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.example('scope'), null).shift();
    }
    /**
     * Finds the shacl:minCardinality for a given subject
     * @param subject The RDF.Term to find the shacl:minCardinaly for
     * @returns An RDF.Literal or undefined if not found
     */
    getMinCardinality(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.shacl('minCount'), null).shift();
    }
    /**
   * Finds the shacl:maxCardinality for a given subject
   * @param subject The RDF.Term to find the shacl:maxCardinaly for
   * @returns An RDF.Literal or undefined if not found
   */
    getMaxCardinality(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.shacl('maxCount'), null).shift();
    }
    /**
     * Finds all the rdfs:subClassOf of a given RDF.Term
     * @param subject the RDF.Term to find the parents of
     * @param store A N3 quad store
     * @returns An array of RDF.Terms
     */
    getParentsOfClass(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('subClassOf'), null);
    }
    /**
     * Finds the rdfs:subPropertyOf of a given RDF.Term
     * @param subject The RDF.Term to find the parent of
     * @param store A N3 quad store
     * @returns An RDF.Term or undefined if not found
     */
    getParentOfProperty(subject) {
        return this.store.getObjects(subject, namespaces_1.ns.rdfs('subPropertyOf'), null).shift();
    }
    /**
     * Find the subject of the statement that matches the given subject, predicate and object
     * @param statementSubject The subject to match the statement subject
     * @param statementPredicate The predicate to match the statement predicate
     * @param statementObject The object to match the statement object
     * @param store An N3 quad store
     * @returns an RDF.Term or undefined if none found
     */
    getTargetStatementId(statementSubject, statementPredicate, statementObject) {
        const statementIds = this.store.getSubjects(namespaces_1.ns.rdf('type'), namespaces_1.ns.rdf('Statement'), null);
        const statementSubjectPredicateSubjects = this.store.getSubjects(namespaces_1.ns.rdf('subject'), statementSubject, null);
        const statementPredicatePredicateSubjects = this.store.getSubjects(namespaces_1.ns.rdf('predicate'), statementPredicate, null);
        const statementObjectPredicateSubjects = this.store.getSubjects(namespaces_1.ns.rdf('object'), statementObject, null);
        const targetIds = statementIds
            .filter(x => statementSubjectPredicateSubjects.some(y => y.value === x.value))
            .filter(x => statementPredicatePredicateSubjects.some(y => y.value === x.value))
            .filter(x => statementObjectPredicateSubjects.some(y => y.value === x.value));
        if (targetIds.length > 1) {
            throw new Error(`Found multiple statements with subject "${statementSubject.value}", predicate "${statementPredicate.value}" and object "${statementObject.value}".`);
        }
        return targetIds.shift();
    }
    /**
     * Finds the assigned URI in rdf:Statements
     * @param subject The statement subject
     * @param predicate The statement predicate
     * @param object The statement object for which the assigned URI must be found
     * @param store A N3 quad store
     * @returns An RDF.Term or undefined if not found
     */
    getAssignedUriViaStatements(subject, predicate, object) {
        const statementId = this.getTargetStatementId(subject, predicate, object);
        if (!statementId) {
            return undefined;
        }
        return this.getAssignedUri(statementId);
    }
    /**
     * Finds the rdfs:label for an RDF.Term in rdf:Statements
     * @param subject The statement subject
     * @param predicate The statement predicate
     * @param object The statement object for which the label must be found
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getLabelViaStatements(subject, predicate, object, language) {
        const statementId = this.getTargetStatementId(subject, predicate, object);
        if (!statementId) {
            return undefined;
        }
        const label = this.getLabel(statementId, language);
        return label || this.getLabel(statementId);
    }
    /**
     * Finds the rdfs:comment for an RDF.Term in rdf:Statements
     * @param subject The statement subject
     * @param predicate The statement predicate
     * @param object The statement object for which the definition must be found
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getDefinitionViaStatements(subject, predicate, object, language) {
        const statementId = this.getTargetStatementId(subject, predicate, object);
        if (!statementId) {
            return undefined;
        }
        const definition = this.getDefinition(statementId, language);
        return definition || this.getDefinition(statementId);
    }
    /**
     * Finds the vann:usageNote for an RDF.Term in rdf:Statements
     * @param subject The statement subject
     * @param predicate The statement predicate
     * @param object The statement object for which the usage note must be found
     * @param store A N3 quad store
     * @param language A language tag
     * @returns An RDF.Literal or undefined if not found
     */
    getUsageNoteViaStatements(subject, predicate, object, language) {
        const statementId = this.getTargetStatementId(subject, predicate, object);
        if (!statementId) {
            return undefined;
        }
        const usageNote = this.getUsageNote(statementId, language);
        return usageNote || this.getUsageNote(statementId);
    }
};
QuadStore = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], QuadStore);
exports.QuadStore = QuadStore;
//# sourceMappingURL=QuadStore.js.map