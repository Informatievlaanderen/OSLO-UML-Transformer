"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonLdOutputHandler = void 0;
const core_1 = require("@oslo-flanders/core");
const osloContext_1 = require("./utils/osloContext");
class JsonLdOutputHandler {
    async write(store, writeStream) {
        const [packages, classes, attributes, dataTypes, statements] = await Promise.all([
            this.getPackages(store),
            this.getClasses(store),
            this.getAttributes(store),
            this.getDataTypes(store),
            this.getRdfStatements(store),
        ]);
        const document = {};
        document['@context'] = (0, osloContext_1.getOsloContext)();
        this.addDocumentInformation(document, store);
        document.packages = packages;
        document.classes = classes;
        document.attributes = attributes;
        document.dataTypes = dataTypes;
        document.statements = statements;
        writeStream.write(JSON.stringify(document, null, 2));
    }
    addDocumentInformation(document, store) {
        const versionIdQuad = store.findQuad(null, core_1.ns.prov('generatedAtTime'), null);
        if (!versionIdQuad) {
            throw new Error(`Unnable to find version id for the document.`);
        }
        document['@id'] = versionIdQuad.subject.value;
        document.generatedAtTime = versionIdQuad.object.value;
    }
    async getPackages(store) {
        const packageIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.example('Package'));
        return packageIds.map(id => {
            const packageQuads = store.findQuads(id, null, null);
            const baseUriValue = packageQuads.find(x => x.predicate.equals(core_1.ns.example('baseUri')));
            if (!baseUriValue) {
                throw new Error(`Unnable to find base URI for package with .well-known id ${id.value}`);
            }
            const assignedUri = packageQuads.find(x => x.predicate.equals(core_1.ns.example('assignedUri')));
            return {
                '@id': id.value,
                '@type': 'Package',
                ...assignedUri && {
                    assignedUri: assignedUri.object.value,
                },
                baseUri: baseUriValue.object.value,
            };
        });
    }
    async getClasses(store) {
        const classIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.owl('Class'));
        return classIds.reduce((jsonLdClasses, subject) => {
            // Classes with skos:Concept URI are not being published separately, but only
            // as part of an attribute's range
            if (subject.equals(core_1.ns.skos('Concept'))) {
                return jsonLdClasses;
            }
            const classQuads = store.findQuads(subject, null, null);
            const assignedUri = classQuads.find(x => x.predicate.equals(core_1.ns.example('assignedUri')));
            const definitionQuads = classQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('comment')));
            const labelQuads = classQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('label')));
            const scopeQuad = classQuads.find(x => x.predicate.equals(core_1.ns.example('scope')));
            const parentQuads = classQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('subClassOf')));
            jsonLdClasses.push({
                '@id': subject.value,
                '@type': 'Class',
                ...assignedUri && {
                    assignedUri: assignedUri.object.value,
                },
                definition: definitionQuads
                    .map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                label: labelQuads.map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                scope: scopeQuad === null || scopeQuad === void 0 ? void 0 : scopeQuad.object.value,
                ...parentQuads.length > 0 && {
                    parent: parentQuads.map(x => ({ '@id': x.object.value })),
                },
            });
            return jsonLdClasses;
        }, []);
    }
    async getAttributes(store) {
        const dataTypeAttributeIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.owl('DatatypeProperty'));
        const objectPropertyAttributeIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.owl('ObjectProperty'));
        const propertyAttributeIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.rdf('Property'));
        return [
            ...dataTypeAttributeIds,
            ...objectPropertyAttributeIds,
            ...propertyAttributeIds,
        ].map(subject => {
            const attributeQuads = store.findQuads(subject, null, null);
            const assignedUri = attributeQuads.find(x => x.predicate.equals(core_1.ns.example('assignedUri')));
            const definitionQuads = attributeQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('comment')));
            const attributeTypeQuad = attributeQuads
                .find(x => x.subject.equals(subject) && x.predicate.equals(core_1.ns.rdf('type')));
            if (!attributeTypeQuad) {
                throw new Error(`Attribute ${subject.value} has no type.`);
            }
            const labelQuads = attributeQuads
                .filter(x => x.subject.equals(subject) && x.predicate.equals(core_1.ns.rdfs('label')));
            const usageNoteQuads = attributeQuads.filter(x => x.predicate.equals(core_1.ns.vann('usageNote')));
            const domainQuads = attributeQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('domain')));
            const rangeQuad = attributeQuads.find(x => x.predicate.equals(core_1.ns.rdfs('range')));
            const scopeQuad = attributeQuads.find(x => x.predicate.equals(core_1.ns.example('scope')));
            const parentQuad = attributeQuads.find(x => x.predicate.equals(core_1.ns.rdfs('subPropertyOf')));
            const minCardinalityQuad = attributeQuads.find(x => x.predicate.equals(core_1.ns.shacl('minCount')));
            const maxCardinalityQuad = attributeQuads.find(x => x.predicate.equals(core_1.ns.shacl('maxCount')));
            return {
                '@id': subject.value,
                '@type': attributeTypeQuad.object.value,
                ...assignedUri && {
                    assignedUri: assignedUri.object.value,
                },
                ...labelQuads.length > 0 && {
                    label: labelQuads.map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...definitionQuads.length > 0 && {
                    definition: definitionQuads
                        .map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...usageNoteQuads.length > 0 && {
                    usageNote: usageNoteQuads
                        .map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...domainQuads.length > 0 && {
                    domain: domainQuads.map(x => ({ '@id': x.object.value })),
                },
                ...rangeQuad && {
                    range: {
                        '@id': rangeQuad.object.value,
                    },
                },
                ...parentQuad && {
                    parent: parentQuad.object.value,
                },
                minCount: minCardinalityQuad === null || minCardinalityQuad === void 0 ? void 0 : minCardinalityQuad.object.value,
                maxCount: maxCardinalityQuad === null || maxCardinalityQuad === void 0 ? void 0 : maxCardinalityQuad.object.value,
                scope: scopeQuad === null || scopeQuad === void 0 ? void 0 : scopeQuad.object.value,
            };
        });
    }
    async getDataTypes(store) {
        const datatypeIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.example('DataType'));
        return datatypeIds.map(subject => {
            const dataTypeQuads = store.findQuads(subject, null, null);
            const assignedUri = dataTypeQuads.find(x => x.predicate.equals(core_1.ns.example('assignedUri')));
            const definitionQuads = dataTypeQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('comment')));
            const labelQuads = dataTypeQuads.filter(x => x.predicate.equals(core_1.ns.rdfs('label')));
            const usageNoteQuads = dataTypeQuads.filter(x => x.predicate.equals(core_1.ns.vann('usageNote')));
            const scopeQuad = dataTypeQuads.find(x => x.predicate.equals(core_1.ns.example('scope')));
            return {
                '@id': subject.value,
                '@type': 'DataType',
                ...assignedUri && {
                    assignedUri: assignedUri.object.value,
                },
                ...labelQuads.length > 0 && {
                    label: labelQuads.map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...definitionQuads.length > 0 && {
                    definition: definitionQuads
                        .map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...usageNoteQuads.length > 0 && {
                    usageNote: usageNoteQuads
                        .map(x => ({ '@language': x.object.language, '@value': x.object.value })),
                },
                ...scopeQuad && {
                    scope: scopeQuad.object.value,
                },
            };
        });
    }
    async getRdfStatements(store) {
        const statementIds = store.findSubjects(core_1.ns.rdf('type'), core_1.ns.rdf('Statement'));
        return statementIds.map(subject => {
            const statementSubject = store.findObject(subject, core_1.ns.rdf('subject'));
            const statementPredicate = store.findObject(subject, core_1.ns.rdf('predicate'));
            const statementObject = store.findObject(subject, core_1.ns.rdf('object'));
            const statementLabels = store.findObjects(subject, core_1.ns.rdfs('label'));
            const statementDefinitions = store.findObjects(subject, core_1.ns.rdfs('comment'));
            const statementUsageNotes = store.findObjects(subject, core_1.ns.vann('usageNote'));
            const statementConceptScheme = store.findObject(subject, core_1.ns.example('usesConceptScheme'));
            return {
                '@type': core_1.ns.rdf('Statement').value,
                subject: {
                    '@id': statementSubject === null || statementSubject === void 0 ? void 0 : statementSubject.value,
                },
                predicate: {
                    '@id': statementPredicate === null || statementPredicate === void 0 ? void 0 : statementPredicate.value,
                },
                object: {
                    '@id': statementObject === null || statementObject === void 0 ? void 0 : statementObject.value,
                },
                ...statementLabels.length > 0 && {
                    label: statementLabels
                        .map(x => ({ '@language': x.language, '@value': x.value })),
                },
                ...statementDefinitions.length > 0 && {
                    definition: statementDefinitions
                        .map(x => ({ '@language': x.language, '@value': x.value })),
                },
                ...statementUsageNotes.length > 0 && {
                    usageNote: statementUsageNotes
                        .map(x => ({ '@language': x.language, '@value': x.value })),
                },
                ...statementConceptScheme && {
                    usesConceptScheme: statementConceptScheme.value,
                },
            };
        });
    }
}
exports.JsonLdOutputHandler = JsonLdOutputHandler;
//# sourceMappingURL=JsonLdOutputHandler.js.map