"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = void 0;
/* eslint-disable node/no-sync */
const fs = require("fs");
const path = require("path");
const pkgparts_1 = require("../pkgparts");
const cjsresolve_1 = require("../cjsresolve");
const outcome = {
    notFound: () => ({ found: false, path: null }),
    found: (location) => ({ found: true, path: location }),
};
function jsonfile(source) {
    const contents = fs.readFileSync(source, 'utf-8').trim();
    const json = JSON.parse(contents);
    return json;
}
/**
 * Resolve a given import path into a Lerna package
 *
 * @param identifier  - A potential package name or path to be resolved into absolute path
 * @param importer    - The absolute path to the module making the import
 * @param config      - Configuration options for the resolver, as provided via ESLint config file
 * @returns             The outcome of the module resolution attempt, including the module's path
 */
function resolve(identifier, importer, config) {
    var _a;
    const { basename, relpath } = pkgparts_1.pkgparts(identifier);
    const packages = (_a = config === null || config === void 0 ? void 0 : config.packages) !== null && _a !== void 0 ? _a : [];
    const roots = Array.isArray(packages)
        ? packages
        : [packages];
    for (const root of roots) {
        const filenames = fs
            .readdirSync(root)
            .map(filename => path.resolve(root, filename))
            .filter(filename => fs.statSync(filename).isDirectory())
            .filter(filename => fs.existsSync(path.resolve(filename, 'package.json')));
        for (const filename of filenames) {
            const pkg = jsonfile(path.resolve(filename, 'package.json'));
            if (pkg.name === basename) {
                const resolved = cjsresolve_1.cjsresolve(path.resolve(filename, relpath !== null && relpath !== void 0 ? relpath : ''));
                return resolved
                    ? outcome.found(resolved)
                    : outcome.notFound();
            }
        }
    }
    return outcome.notFound();
}
exports.resolve = resolve;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb2x2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlc29sdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBQ2pDLHlCQUF3QjtBQUN4Qiw2QkFBNEI7QUFDNUIsMENBQXNDO0FBQ3RDLDhDQUEwQztBQUkxQyxNQUFNLE9BQU8sR0FBRztJQUNkLFFBQVEsRUFBRSxHQUFZLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDdkQsS0FBSyxFQUFFLENBQUMsUUFBZ0IsRUFBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDO0NBQ3hFLENBQUE7QUFFRCxTQUFTLFFBQVEsQ0FBQyxNQUFjO0lBQzlCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFBO0lBQ3hELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUE0QixDQUFBO0lBRTVELE9BQU8sSUFBSSxDQUFBO0FBQ2IsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLE9BQU8sQ0FBQyxVQUFrQixFQUFFLFFBQWdCLEVBQUUsTUFBZTs7SUFDcEUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsR0FBRyxtQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ2xELE1BQU0sUUFBUSxTQUFHLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxRQUFRLG1DQUFJLEVBQUUsQ0FBQTtJQUN2QyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztRQUNuQyxDQUFDLENBQUMsUUFBUTtRQUNWLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBRWQsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7UUFDeEIsTUFBTSxTQUFTLEdBQUcsRUFBRTthQUNqQixXQUFXLENBQUMsSUFBSSxDQUFDO2FBQ2pCLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQzdDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDdkQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFFNUUsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUU7WUFDaEMsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUE7WUFFNUQsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDekIsTUFBTSxRQUFRLEdBQUcsdUJBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLGFBQVAsT0FBTyxjQUFQLE9BQU8sR0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFBO2dCQUVsRSxPQUFPLFFBQVE7b0JBQ2IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO29CQUN6QixDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFBO2FBQ3ZCO1NBQ0Y7S0FDRjtJQUVELE9BQU8sT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFBO0FBQzNCLENBQUM7QUFHQywwQkFBTyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tc3luYyAqL1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBwa2dwYXJ0cyB9IGZyb20gJy4uL3BrZ3BhcnRzJ1xuaW1wb3J0IHsgY2pzcmVzb2x2ZSB9IGZyb20gJy4uL2Nqc3Jlc29sdmUnXG5pbXBvcnQgdHlwZSB7IENvbmZpZyB9IGZyb20gJy4vQ29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBPdXRjb21lIH0gZnJvbSAnLi9PdXRjb21lJ1xuXG5jb25zdCBvdXRjb21lID0ge1xuICBub3RGb3VuZDogKCk6IE91dGNvbWUgPT4gKHsgZm91bmQ6IGZhbHNlLCBwYXRoOiBudWxsIH0pLFxuICBmb3VuZDogKGxvY2F0aW9uOiBzdHJpbmcpOiBPdXRjb21lID0+ICh7IGZvdW5kOiB0cnVlLCBwYXRoOiBsb2NhdGlvbiB9KSxcbn1cblxuZnVuY3Rpb24ganNvbmZpbGUoc291cmNlOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIGNvbnN0IGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0Zi04JykudHJpbSgpXG4gIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnRzKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuXG4gIHJldHVybiBqc29uXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIGdpdmVuIGltcG9ydCBwYXRoIGludG8gYSBMZXJuYSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGlkZW50aWZpZXIgIC0gQSBwb3RlbnRpYWwgcGFja2FnZSBuYW1lIG9yIHBhdGggdG8gYmUgcmVzb2x2ZWQgaW50byBhYnNvbHV0ZSBwYXRoXG4gKiBAcGFyYW0gaW1wb3J0ZXIgICAgLSBUaGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgbW9kdWxlIG1ha2luZyB0aGUgaW1wb3J0XG4gKiBAcGFyYW0gY29uZmlnICAgICAgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSByZXNvbHZlciwgYXMgcHJvdmlkZWQgdmlhIEVTTGludCBjb25maWcgZmlsZVxuICogQHJldHVybnMgICAgICAgICAgICAgVGhlIG91dGNvbWUgb2YgdGhlIG1vZHVsZSByZXNvbHV0aW9uIGF0dGVtcHQsIGluY2x1ZGluZyB0aGUgbW9kdWxlJ3MgcGF0aFxuICovXG5mdW5jdGlvbiByZXNvbHZlKGlkZW50aWZpZXI6IHN0cmluZywgaW1wb3J0ZXI6IHN0cmluZywgY29uZmlnPzogQ29uZmlnKTogT3V0Y29tZSB7XG4gIGNvbnN0IHsgYmFzZW5hbWUsIHJlbHBhdGggfSA9IHBrZ3BhcnRzKGlkZW50aWZpZXIpXG4gIGNvbnN0IHBhY2thZ2VzID0gY29uZmlnPy5wYWNrYWdlcyA/PyBbXVxuICBjb25zdCByb290cyA9IEFycmF5LmlzQXJyYXkocGFja2FnZXMpXG4gICAgPyBwYWNrYWdlc1xuICAgIDogW3BhY2thZ2VzXVxuXG4gIGZvciAoY29uc3Qgcm9vdCBvZiByb290cykge1xuICAgIGNvbnN0IGZpbGVuYW1lcyA9IGZzXG4gICAgICAucmVhZGRpclN5bmMocm9vdClcbiAgICAgIC5tYXAoZmlsZW5hbWUgPT4gcGF0aC5yZXNvbHZlKHJvb3QsIGZpbGVuYW1lKSlcbiAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gZnMuc3RhdFN5bmMoZmlsZW5hbWUpLmlzRGlyZWN0b3J5KCkpXG4gICAgICAuZmlsdGVyKGZpbGVuYW1lID0+IGZzLmV4aXN0c1N5bmMocGF0aC5yZXNvbHZlKGZpbGVuYW1lLCAncGFja2FnZS5qc29uJykpKVxuXG4gICAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBmaWxlbmFtZXMpIHtcbiAgICAgIGNvbnN0IHBrZyA9IGpzb25maWxlKHBhdGgucmVzb2x2ZShmaWxlbmFtZSwgJ3BhY2thZ2UuanNvbicpKVxuXG4gICAgICBpZiAocGtnLm5hbWUgPT09IGJhc2VuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2pzcmVzb2x2ZShwYXRoLnJlc29sdmUoZmlsZW5hbWUsIHJlbHBhdGggPz8gJycpKVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZFxuICAgICAgICAgID8gb3V0Y29tZS5mb3VuZChyZXNvbHZlZClcbiAgICAgICAgICA6IG91dGNvbWUubm90Rm91bmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRjb21lLm5vdEZvdW5kKClcbn1cblxuZXhwb3J0IHtcbiAgcmVzb2x2ZSxcbn1cbiJdfQ==