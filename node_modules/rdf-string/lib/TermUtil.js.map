{"version":3,"file":"TermUtil.js","sourceRoot":"","sources":["TermUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataFactory } from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\n\nconst FACTORY = new DataFactory();\n\n/**\n * Utility methods for converting between string-based RDF representations and RDFJS objects.\n *\n * RDF Terms are represented as follows:\n * * Blank nodes: '_:myBlankNode'\n * * Variables:   '?myVariable'\n * * Literals:    '\"myString\"', '\"myLanguageString\"@en-us', '\"3\"^^xsd:number'\n * * URIs:        'http://example.org'\n *\n * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)\n * as keys, and string-based RDF terms as values.\n */\n\n/**\n * Convert an RDFJS term to a string-based representation.\n * @param {RDF.Term} term An RDFJS term.\n * @return {string} A string-based term representation.\n */\nexport function termToString<T extends RDF.Term | undefined | null>(term: T): T extends RDF.Term ? string : undefined {\n  // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933\n  if (!term) {\n    return <any> undefined;\n  }\n  switch (term.termType) {\n  case 'NamedNode': return <any> term.value;\n  case 'BlankNode': return <any> ('_:' + term.value);\n  case 'Literal':\n    const literalValue: RDF.Literal = <RDF.Literal> term;\n    return <any> ('\"' + literalValue.value + '\"' +\n      (literalValue.datatype &&\n      literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' &&\n      literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' ?\n        '^^' + literalValue.datatype.value : '') +\n      (literalValue.language ? '@' + literalValue.language : ''));\n  case 'Quad': return <any> `<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ' ' + termToString(term.graph)}>>`;\n  case 'Variable': return <any> ('?' + term.value);\n  case 'DefaultGraph': return <any> term.value;\n  }\n}\n\n/**\n * Get the string value of a literal.\n * @param {string} literalValue An RDF literal enclosed by '\"'.\n * @return {string} The literal value inside the '\"'.\n */\nexport function getLiteralValue(literalValue: string): string {\n  const match = /^\"([^]*)\"/.exec(literalValue);\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n  return match[1];\n}\n\n/**\n * Get the datatype of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The datatype of the literal.\n */\nexport function getLiteralType(literalValue: string): string {\n  const match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^@\"]+)?$/.exec(literalValue);\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n  return match[1] || (match[2]\n    ? 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' : 'http://www.w3.org/2001/XMLSchema#string');\n}\n\n/**\n * Get the language of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The language of the literal.\n */\nexport function getLiteralLanguage(literalValue: string): string {\n  const match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literalValue);\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n  return match[1] ? match[1].toLowerCase() : '';\n}\n\n/**\n * Transform a string-based RDF term to an RDFJS term.\n * @param {string} value A string-based RDF-term.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {RDF.Term} An RDF-JS term.\n */\nexport function stringToTerm(value: string | undefined, dataFactory?: RDF.DataFactory<RDF.BaseQuad>): RDF.Term {\n  dataFactory = dataFactory || FACTORY;\n  if (!value || !value.length) {\n    return dataFactory.defaultGraph();\n  }\n  switch (value[0]) {\n  case '_': return dataFactory.blankNode(value.substr(2));\n  case '?':\n    if (!dataFactory.variable) {\n      throw new Error(`Missing 'variable()' method on the given DataFactory`);\n    }\n    return dataFactory.variable(value.substr(1));\n  case '\"':\n    const language: string = getLiteralLanguage(value);\n    const type: RDF.NamedNode = dataFactory.namedNode(getLiteralType(value));\n    return dataFactory.literal(getLiteralValue(value), language || type);\n  case '<':\n  default:\n    if (value[0] === '<' && value.length > 4 && value[1] === '<' && value[value.length - 1] === '>' && value[value.length - 2] === '>') {\n      // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>\n      const terms = value.slice(2, -2).trim();\n      let stringTerms: string[] = [];\n      let ignoreTags: number = 0;\n      let lastIndex = 0;\n      let inQuote = false;\n      for (let i = 0; i < terms.length; i++) {\n        const char = terms[i];\n        if (char === '<') ignoreTags++;\n        if (char === '>') {\n          if (ignoreTags === 0) {\n            throw new Error('Found closing tag without opening tag in ' + value);\n          } else {\n            ignoreTags--\n          }\n        }\n        if (char === '\"') {\n          let escaped = false\n          let j = i;\n          while (j-- > 0 && terms[j] === '\\\\') {\n            escaped = !escaped;\n          }\n          if (!escaped) {\n            // We have reached an unescaped quote\n            inQuote = !inQuote;\n          }\n        }\n        if (char === ' ' && !inQuote && ignoreTags === 0) {\n          stringTerms.push(terms.slice(lastIndex, i));\n\n          while (terms[i + 1] === ' ') {\n            i += 1;\n          }\n\n          lastIndex = i + 1;\n        }\n      }\n      if (ignoreTags !== 0) {\n        throw new Error('Found opening tag without closing tag in ' + value);\n      }\n      stringTerms.push(terms.slice(lastIndex, terms.length));\n\n      // We require 3 or 4 components\n      if (stringTerms.length !== 3 && stringTerms.length !== 4) {\n        throw new Error('Nested quad syntax error ' + value);\n      }\n\n      stringTerms = stringTerms.map(term => term.startsWith('<') && !term.includes(' ') ? term.slice(1, -1) : term)\n\n      return dataFactory.quad(\n        stringToTerm(stringTerms[0]),\n        stringToTerm(stringTerms[1]),\n        stringToTerm(stringTerms[2]),\n        stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined,\n      );\n    }\n    return dataFactory.namedNode(value);\n  }\n}\n\n/**\n * Convert an RDFJS quad to a string-based quad representation.\n * @param {Quad} q An RDFJS quad.\n * @return {IStringQuad} A hash with string-based quad terms.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function quadToStringQuad<Q extends RDF.BaseQuad = RDF.Quad>(q: Q): IStringQuad {\n  // tslint:disable:object-literal-sort-keys\n  return {\n    subject: termToString(q.subject),\n    predicate: termToString(q.predicate),\n    object: termToString(q.object),\n    graph: termToString(q.graph),\n  };\n  // tslint:enable:object-literal-sort-keys\n}\n\n/**\n * Convert a string-based quad representation to an RDFJS quad.\n * @param {IStringQuad} stringQuad A hash with string-based quad terms.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {Q} An RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function stringQuadToQuad<Q extends RDF.BaseQuad = RDF.Quad>(stringQuad: IStringQuad,\n                                                                    dataFactory?: RDF.DataFactory<Q>): Q {\n  dataFactory = <RDF.DataFactory<Q>> dataFactory || FACTORY;\n  return dataFactory.quad(\n    stringToTerm(stringQuad.subject, dataFactory),\n    stringToTerm(stringQuad.predicate, dataFactory),\n    stringToTerm(stringQuad.object, dataFactory),\n    stringToTerm(stringQuad.graph, dataFactory),\n  );\n}\n\nexport interface IStringQuad {\n  subject: string;\n  predicate: string;\n  object: string;\n  graph?: string;\n}\n"]}