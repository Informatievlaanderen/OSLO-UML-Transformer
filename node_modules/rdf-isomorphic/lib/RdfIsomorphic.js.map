{"version":3,"file":"RdfIsomorphic.js","sourceRoot":"","sources":["RdfIsomorphic.ts"],"names":[],"mappings":"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","sourcesContent":["import {sha1} from \"hash.js\";\nimport * as RDF from \"@rdfjs/types\";\nimport {quadToStringQuad, stringQuadToQuad, termToString} from \"rdf-string\";\nimport {everyTerms, getBlankNodes, getTerms, someTerms, uniqTerms, getTermsNested} from \"rdf-terms\";\n\n/**\n * Determines if the two given graphs are isomorphic.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {boolean} If the two given graphs are isomorphic.\n */\nexport function isomorphic<Q extends RDF.BaseQuad = RDF.Quad>(graphA: Q[], graphB: Q[]): boolean {\n  return !!getBijection(graphA, graphB);\n}\n\n/**\n * Calculate a hash of graphA blank nodes to graphB blank nodes.\n * This represents a bijection from graphA's blank nodes to graphB's blank nodes.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {IBijection} A hash representing a bijection, or null if none could be found.\n */\nexport function getBijection<Q extends RDF.BaseQuad = RDF.Quad>(graphA: Q[], graphB: Q[]): IBijection {\n  // Check if all (non-blanknode-containing) quads in the two graphs are equal.\n  // We do this by creating a hash-based index for both graphs.\n  const nonBlankIndexA: {[quad: string]: boolean} = indexGraph(getQuadsWithoutBlankNodes(graphA));\n  const nonBlankIndexB: {[quad: string]: boolean} = indexGraph(getQuadsWithoutBlankNodes(graphB));\n  if (Object.keys(nonBlankIndexA).length !== Object.keys(nonBlankIndexB).length) {\n    return null;\n  }\n  for (const key in nonBlankIndexA) {\n    if (nonBlankIndexA[key] !== nonBlankIndexB[key]) {\n      return null;\n    }\n  }\n\n  // Pre-process data that needs to be present in each iteration of getBijectionInner.\n  const blankQuadsA: Q[] = uniqGraph(getQuadsWithBlankNodes(graphA));\n  const blankQuadsB: Q[] = uniqGraph(getQuadsWithBlankNodes(graphB));\n  const blankNodesA: RDF.BlankNode[] = getGraphBlankNodes(graphA);\n  const blankNodesB: RDF.BlankNode[] = getGraphBlankNodes(graphB);\n\n  return getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB);\n}\n\nexport function getBijectionInner<Q extends RDF.BaseQuad = RDF.Quad>(\n  blankQuadsA: Q[], blankQuadsB: Q[], blankNodesA: RDF.BlankNode[], blankNodesB: RDF.BlankNode[],\n  groundedHashesA?: ITermHash, groundedHashesB?: ITermHash): IBijection {\n  if (!groundedHashesA) {\n    groundedHashesA = {};\n  }\n  if (!groundedHashesB) {\n    groundedHashesB = {};\n  }\n\n  // Hash every term based on the signature of the quads if appears in.\n  const [hashesA, ungroundedHashesA] = hashTerms(blankQuadsA, blankNodesA, groundedHashesA);\n  const [hashesB, ungroundedHashesB] = hashTerms(blankQuadsB, blankNodesB, groundedHashesB);\n\n  // Break quickly if a graph contains a grounded node that is not contained in the other graph.\n  if (Object.keys(hashesA).length !== Object.keys(hashesB).length) {\n    return null;\n  }\n  for (const hashKeyA in hashesA) {\n    if (!hasValue(hashesB, hashesA[hashKeyA])) {\n      return null;\n    }\n  }\n\n  // Map the blank nodes from graph A to the blank nodes of graph B using the created hashes.\n  // Grounded hashes will also be equal, but not needed here, we will need them in the next recursion\n  // (as we only recurse on grounded nodes).\n  let bijection: IBijection = {};\n  for (const blankNodeA of blankNodesA) {\n    const blankNodeAString: string = termToString(blankNodeA);\n    const blankNodeAHash: string = ungroundedHashesA[blankNodeAString];\n    for (const blankNodeBString in ungroundedHashesB) {\n      if (ungroundedHashesB[blankNodeBString] === blankNodeAHash) {\n        bijection[blankNodeAString] = blankNodeBString;\n        delete ungroundedHashesB[blankNodeBString];\n        break;\n      }\n    }\n  }\n\n  // Check if all nodes from graph A and B are present in the bijection,\n  // if not, speculatively mark pairs with matching ungrounded hashes as bijected, and recurse.\n  if (!arraysEqual(Object.keys(bijection).sort(), blankNodesA.map(termToString).sort())\n    || !arraysEqual(hashValues(bijection).sort(), blankNodesB.map(termToString).sort())) {\n    // I have not yet been able to find any pathological cases where this code is reached.\n    // This may be removable, but let's wait until someone proves that.\n    bijection = null;\n\n    for (const blankNodeA of blankNodesA) {\n      // Only replace ungrounded node hashes\n      const blankNodeAString: string = termToString(blankNodeA);\n      if (!hashesA[blankNodeAString]) {\n        for (const blankNodeB of blankNodesB) {\n          // Only replace ungrounded node hashes\n          const blankNodeBString: string = termToString(blankNodeB);\n          if (!hashesB[blankNodeBString]) {\n            if (ungroundedHashesA[blankNodeAString] === ungroundedHashesB[blankNodeBString]) {\n              const hash: string = sha1hex(blankNodeAString);\n              bijection = getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB,\n                { ...hashesA, [blankNodeAString]: hash }, { ...hashesB, [blankNodeBString]: hash });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return bijection;\n\n}\n\nfunction arraysEqual(array1: any[], array2: any[]) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = array1.length; i--;) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Get all values from the given hash\n * @param hash A hash.\n * @return {any[]} The array of values.\n */\nexport function hashValues(hash: any) {\n  const arr: any[] = [];\n  for (const e in hash) {\n    arr.push(hash[e]);\n  }\n  return arr;\n}\n\n/**\n * Check if the given hash contains the given value.\n * @param hash A hash.\n * @param {string} value A value.\n * @return {boolean} If it contains the value.\n */\nexport function hasValue(hash: any, value: any) {\n  for (const hashValue in hash) {\n    if (hash[hashValue] === value) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get all quads with blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads with blank nodes\n */\nexport function getQuadsWithBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[] {\n  return graph.filter((quad: Q) => someTerms(quad, (value: RDF.Term) => {\n    return value.termType === 'BlankNode'\n      || (value.termType === 'Quad' && getTermsNested(value).some(term => term.termType === 'BlankNode'));\n  }));\n}\n\n/**\n * Get all quads without blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads without blank nodes\n */\nexport function getQuadsWithoutBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[] {\n  return graph.filter((quad: Q) => everyTerms(quad, (value: RDF.Term) => {\n    return value.termType !== 'BlankNode'\n      && !(value.termType === 'Quad' && getTermsNested(value).some(term => term.termType === 'BlankNode'));\n  }));\n}\n\n/**\n * Create a hash-based index of the given graph.\n * @param {Quad[]} graph An array of quads, the order does not matter.\n * @return {{[p: string]: boolean}} A hash-based datastructure representing the graph.\n */\nexport function indexGraph<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): {[quad: string]: boolean} {\n  const index: {[quad: string]: boolean} = {};\n  for (const quad of graph) {\n    index[JSON.stringify(quadToStringQuad(quad))] = true;\n  }\n  return index;\n}\n\n/**\n * Create a graph from the given hash-based index.\n * @param {{[p: string]: boolean}} indexedGraph A hash-based datastructure representing the graph.\n * @return {Quad[]} An array of quads, the order does not matter.\n */\nexport function deindexGraph<Q extends RDF.BaseQuad = RDF.Quad>(indexedGraph: {[quad: string]: boolean}): Q[] {\n  return Object.keys(indexedGraph).map((str) => stringQuadToQuad(JSON.parse(str)));\n}\n\n/**\n * Unique-ify the given RDF graph based on strict equality.\n * The output graph will consist of new quad and term instances.\n * @param {Quad[]} graph An input graph.\n * @return {Quad[]} The input graph without duplicates.\n */\nexport function uniqGraph<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[] {\n  return deindexGraph(indexGraph(graph));\n}\n\n/**\n * Find all blank nodes in the given graph.\n * @param {Quad[]} graph An array of quads.\n * @return {BlankNode[]} A list of (unique) blank nodes.\n */\nexport function getGraphBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): RDF.BlankNode[] {\n  return uniqTerms(graph.map((quad: Q) => getBlankNodes(getTermsNested(quad)))\n    .reduce((acc: RDF.BlankNode[], val: RDF.BlankNode[]) => acc.concat(val), []));\n}\n\n/**\n * Create term hashes for the given set of quads and blank node terms.\n *\n * @param {Quad[]} quads A set of quads.\n * @param {Term[]} terms Blank node terms.\n * @param {ITermHash} groundedHashes Grounded term hashes that are used to create more specific signatures\n *                                   of other terms, because they are based on non-blank nodes and grounded blank nodes.\n * @return {[ITermHash]} A tuple of grounded and ungrounded hashes.\n */\nexport function hashTerms<Q extends RDF.BaseQuad = RDF.Quad>(quads: Q[], terms: RDF.Term[], groundedHashes: ITermHash):\n  [ITermHash, ITermHash] {\n  const hashes: ITermHash = {...groundedHashes};\n  const ungroundedHashes: ITermHash = {};\n  let hashNeeded: boolean = true;\n\n  // Iteratively mark nodes as grounded.\n  // If a node is marked as grounded, then the next iteration can lead to new grounded states\n  while (hashNeeded) {\n    const initialGroundedNodesCount: number = Object.keys(hashes).length;\n    for (const term of terms) {\n      const termString: string = termToString(term);\n      if (!hashes[termString]) {\n        const [grounded, hash] = hashTerm(term, quads, hashes);\n        if (grounded) {\n          hashes[termString] = hash;\n        }\n        ungroundedHashes[termString] = hash;\n      }\n    }\n\n    // All terms that have a unique hash at this point can be marked as grounded\n    const uniques: {[term: string]: string | boolean} = {};\n    for (const termKey in ungroundedHashes) {\n      const hash = ungroundedHashes[termKey];\n      if (uniques[hash] === undefined) {\n        uniques[hash] = termKey;\n      } else {\n        uniques[hash] = false;\n      }\n    }\n    for (const hash in uniques) {\n      const value = uniques[hash];\n      if (value) {\n        hashes[<string> value] = hash;\n      }\n    }\n\n    // Check if the loop needs to terminate\n    hashNeeded = initialGroundedNodesCount !== Object.keys(hashes).length;\n  }\n\n  return [ hashes, ungroundedHashes ];\n}\n\n/**\n * Generate a hash for the given term based on the signature of the quads it appears in.\n *\n * Signatures are made up of grounded terms in quads that are associated with a term,\n * i.e., everything except for ungrounded blank nodes.\n * The hash is created by hashing a sorted list of each quad's signature,\n * where each quad signature is a concatenation of the signature of all grounded terms.\n *\n * Terms are considered grounded if they are a member in the given hash AND if they are not the given term.\n *\n * @param {Term} term The term to get the hash around.\n * @param {Quad[]} quads The quads to include in the hashing.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {[boolean , string]} A tuple indicating if the given term is grounded in all the given quads, and the hash.\n */\nexport function hashTerm<Q extends RDF.BaseQuad = RDF.Quad>(term: RDF.Term, quads: Q[], hashes: ITermHash):\n  [boolean, string] {\n  const quadSignatures = [];\n  let grounded: boolean = true;\n  for (const quad of quads) {\n    const terms = getTermsNested(quad);\n    if (terms.some((quadTerm: RDF.Term) => quadTerm.equals(term))) {\n      quadSignatures.push(quadToSignature(quad, hashes, term));\n      for (const quadTerm of terms) {\n        if (!isTermGrounded(quadTerm, hashes) && !quadTerm.equals(term)) {\n          grounded = false;\n        }\n      }\n    }\n  }\n  const hash: string = sha1hex(quadSignatures.sort().join(''));\n  return [ grounded, hash ];\n}\n\n/**\n * Create a hash using sha1 as a hex digest.\n * @param {string | Buffer | NodeJS.TypedArray | DataView} data Something to hash.\n * @return {string} A hash string.\n */\nexport function sha1hex(data: string | Buffer | NodeJS.TypedArray | DataView): string {\n  return sha1().update(data).digest('hex');\n}\n\n/**\n * Convert the given quad to a string signature so that it can be used in the hash structure.\n * @param {Quad} quad A quad.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} term A target term to compare with.\n * @return {string} A string signature.\n */\nexport function quadToSignature<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, hashes: ITermHash, term: RDF.Term) {\n  return getTerms(quad).map((quadTerm: RDF.Term) => termToSignature(quadTerm, hashes, term)).join('|');\n}\n\n/**\n * Convert the given term to a string signature so that it can be used in the hash structure.\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} target A target term to compare with.\n * @return {string} A string signature.\n */\nexport function termToSignature(term: RDF.Term, hashes: ITermHash, target: RDF.Term): string {\n  if (term.equals(target)) {\n    return '@self';\n  } else if (term.termType === 'BlankNode') {\n    return hashes[termToString(term)] || '@blank';\n  } else if (term.termType === 'Quad') {\n    return `<${quadToSignature(term, hashes, target)}>`;\n  } else {\n    return termToString(term);\n  }\n}\n\n/**\n * Check if a term is grounded.\n *\n * A term is grounded if it is not a blank node\n * or if it included in the given hash of grounded nodes.\n *\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {boolean} If the given term is grounded.\n */\nexport function isTermGrounded(term: RDF.Term, hashes: ITermHash): boolean {\n  return (\n    term.termType !== 'BlankNode'\n    && !(term.termType === 'Quad' && getTermsNested(term).some(subTerm => !isTermGrounded(subTerm, hashes)))\n  ) || !!hashes[termToString(term)];\n}\n\nexport interface ITermHash {\n  [term: string]: string;\n}\n\nexport interface IBijection {\n  [nodeA: string]: string;\n}\n"]}