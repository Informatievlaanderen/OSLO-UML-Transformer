/// <reference types="node" />
import * as RDF from "@rdfjs/types";
/**
 * Determines if the two given graphs are isomorphic.
 *
 * @param {Quad[]} graphA An array of quads, order is not important.
 * @param {Quad[]} graphB An array of quads, order is not important.
 * @return {boolean} If the two given graphs are isomorphic.
 */
export declare function isomorphic<Q extends RDF.BaseQuad = RDF.Quad>(graphA: Q[], graphB: Q[]): boolean;
/**
 * Calculate a hash of graphA blank nodes to graphB blank nodes.
 * This represents a bijection from graphA's blank nodes to graphB's blank nodes.
 *
 * @param {Quad[]} graphA An array of quads, order is not important.
 * @param {Quad[]} graphB An array of quads, order is not important.
 * @return {IBijection} A hash representing a bijection, or null if none could be found.
 */
export declare function getBijection<Q extends RDF.BaseQuad = RDF.Quad>(graphA: Q[], graphB: Q[]): IBijection;
export declare function getBijectionInner<Q extends RDF.BaseQuad = RDF.Quad>(blankQuadsA: Q[], blankQuadsB: Q[], blankNodesA: RDF.BlankNode[], blankNodesB: RDF.BlankNode[], groundedHashesA?: ITermHash, groundedHashesB?: ITermHash): IBijection;
/**
 * Get all values from the given hash
 * @param hash A hash.
 * @return {any[]} The array of values.
 */
export declare function hashValues(hash: any): any[];
/**
 * Check if the given hash contains the given value.
 * @param hash A hash.
 * @param {string} value A value.
 * @return {boolean} If it contains the value.
 */
export declare function hasValue(hash: any, value: any): boolean;
/**
 * Get all quads with blank nodes.
 * @param {Quad[]} graph An array of quads.
 * @return {Quad[]} An array of quads with blank nodes
 */
export declare function getQuadsWithBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[];
/**
 * Get all quads without blank nodes.
 * @param {Quad[]} graph An array of quads.
 * @return {Quad[]} An array of quads without blank nodes
 */
export declare function getQuadsWithoutBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[];
/**
 * Create a hash-based index of the given graph.
 * @param {Quad[]} graph An array of quads, the order does not matter.
 * @return {{[p: string]: boolean}} A hash-based datastructure representing the graph.
 */
export declare function indexGraph<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): {
    [quad: string]: boolean;
};
/**
 * Create a graph from the given hash-based index.
 * @param {{[p: string]: boolean}} indexedGraph A hash-based datastructure representing the graph.
 * @return {Quad[]} An array of quads, the order does not matter.
 */
export declare function deindexGraph<Q extends RDF.BaseQuad = RDF.Quad>(indexedGraph: {
    [quad: string]: boolean;
}): Q[];
/**
 * Unique-ify the given RDF graph based on strict equality.
 * The output graph will consist of new quad and term instances.
 * @param {Quad[]} graph An input graph.
 * @return {Quad[]} The input graph without duplicates.
 */
export declare function uniqGraph<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): Q[];
/**
 * Find all blank nodes in the given graph.
 * @param {Quad[]} graph An array of quads.
 * @return {BlankNode[]} A list of (unique) blank nodes.
 */
export declare function getGraphBlankNodes<Q extends RDF.BaseQuad = RDF.Quad>(graph: Q[]): RDF.BlankNode[];
/**
 * Create term hashes for the given set of quads and blank node terms.
 *
 * @param {Quad[]} quads A set of quads.
 * @param {Term[]} terms Blank node terms.
 * @param {ITermHash} groundedHashes Grounded term hashes that are used to create more specific signatures
 *                                   of other terms, because they are based on non-blank nodes and grounded blank nodes.
 * @return {[ITermHash]} A tuple of grounded and ungrounded hashes.
 */
export declare function hashTerms<Q extends RDF.BaseQuad = RDF.Quad>(quads: Q[], terms: RDF.Term[], groundedHashes: ITermHash): [
    ITermHash,
    ITermHash
];
/**
 * Generate a hash for the given term based on the signature of the quads it appears in.
 *
 * Signatures are made up of grounded terms in quads that are associated with a term,
 * i.e., everything except for ungrounded blank nodes.
 * The hash is created by hashing a sorted list of each quad's signature,
 * where each quad signature is a concatenation of the signature of all grounded terms.
 *
 * Terms are considered grounded if they are a member in the given hash AND if they are not the given term.
 *
 * @param {Term} term The term to get the hash around.
 * @param {Quad[]} quads The quads to include in the hashing.
 * @param {ITermHash} hashes A grounded term hash object.
 * @return {[boolean , string]} A tuple indicating if the given term is grounded in all the given quads, and the hash.
 */
export declare function hashTerm<Q extends RDF.BaseQuad = RDF.Quad>(term: RDF.Term, quads: Q[], hashes: ITermHash): [
    boolean,
    string
];
/**
 * Create a hash using sha1 as a hex digest.
 * @param {string | Buffer | NodeJS.TypedArray | DataView} data Something to hash.
 * @return {string} A hash string.
 */
export declare function sha1hex(data: string | Buffer | NodeJS.TypedArray | DataView): string;
/**
 * Convert the given quad to a string signature so that it can be used in the hash structure.
 * @param {Quad} quad A quad.
 * @param {ITermHash} hashes A grounded term hash object.
 * @param {Term} term A target term to compare with.
 * @return {string} A string signature.
 */
export declare function quadToSignature<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, hashes: ITermHash, term: RDF.Term): string;
/**
 * Convert the given term to a string signature so that it can be used in the hash structure.
 * @param {Term} term A term.
 * @param {ITermHash} hashes A grounded term hash object.
 * @param {Term} target A target term to compare with.
 * @return {string} A string signature.
 */
export declare function termToSignature(term: RDF.Term, hashes: ITermHash, target: RDF.Term): string;
/**
 * Check if a term is grounded.
 *
 * A term is grounded if it is not a blank node
 * or if it included in the given hash of grounded nodes.
 *
 * @param {Term} term A term.
 * @param {ITermHash} hashes A grounded term hash object.
 * @return {boolean} If the given term is grounded.
 */
export declare function isTermGrounded(term: RDF.Term, hashes: ITermHash): boolean;
export interface ITermHash {
    [term: string]: string;
}
export interface IBijection {
    [nodeA: string]: string;
}
