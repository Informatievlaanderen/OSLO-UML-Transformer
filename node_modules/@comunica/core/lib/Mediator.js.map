{"version":3,"file":"Mediator.js","sourceRoot":"","sources":["Mediator.ts"],"names":[],"mappings":";;;AAGA;;;;;;;;;;;;;;;;GAgBG;AACH,MAAsB,QAAQ;IAK5B;;;;;;;;;OASG;IACH,YAAsB,IAA+B;QACnD,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC5B,CAAC;IAED;;;;;;;;;OASG;IACI,OAAO,CAAC,MAAS;QACtB,6BAA6B;QAC7B,MAAM,MAAM,GAA8B,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACnE,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,uDAAuD,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;SACzF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;;OAQG;IACI,KAAK,CAAC,YAAY,CAAC,MAAS;QACjC,2CAA2C;QAC3C,OAAO,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IAC9D,CAAC;IAED;;;;;;;;;OASG;IACI,KAAK,CAAC,OAAO,CAAC,MAAS;QAC5B,gDAAgD;QAChD,MAAM,KAAK,GAAM,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QACjD,OAAO,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IACrC,CAAC;CAcF;AAhFD,4BAgFC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorTest } from './Actor';\nimport type { Bus, IActorReply } from './Bus';\n\n/**\n * A mediator can mediate an action over a bus of actors.\n *\n * It does the following:\n * 1. Accepts an action in {@link Mediator#mediate}.\n * 2. Sends the action to the bus to test its applicability on all actors.\n * 3. It _mediates_ over these test results.\n * 4. It selects the _best_ actor.\n * 5. The action is run by the _best_ actor, and the result if returned.\n *\n * The _mediates_ and _best_ parts are filled in by subclasses of this abstract Mediator class.\n *\n * @template A The type of actor to mediator over.\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\nexport abstract class Mediator<A extends Actor<I, T, O>,\n  I extends IAction, T extends IActorTest, O extends IActorOutput> implements IMediatorArgs<A, I, T, O> {\n  public readonly name: string;\n  public readonly bus: Bus<A, I, T, O>;\n\n  /**\n   * All enumerable properties from the `args` object are inherited to this mediator.\n   *\n   * @param {IMediatorArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n   * O extends IActorOutput>} args Arguments object\n   * @param {string} args.name The name for this mediator.\n   * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus\n   *        The bus this mediator will mediate over.\n   * @throws When required arguments are missing.\n   */\n  protected constructor(args: IMediatorArgs<A, I, T, O>) {\n    Object.assign(this, args);\n  }\n\n  /**\n   * Publish the given action in the bus.\n   *\n   * This will send the test action on all actors in the bus.\n   * All actor replies will be returned.\n   *\n   * @param {I} action The action to mediate for.\n   * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>[]}\n   * The list of actor replies.\n   */\n  public publish(action: I): IActorReply<A, I, T, O>[] {\n    // Test all actors in the bus\n    const actors: IActorReply<A, I, T, O>[] = this.bus.publish(action);\n    if (actors.length === 0) {\n      throw new Error(`No actors are able to reply to a message in the bus ${this.bus.name}`);\n    }\n    return actors;\n  }\n\n  /**\n   * Mediate for the given action to get an actor.\n   *\n   * This will send the test action on all actors in the bus.\n   * The actor that tests _best_ will be returned.\n   *\n   * @param {I} action The action to mediate for.\n   * @return {Promise<O extends IActorOutput>} A promise that resolves to the _best_ actor.\n   */\n  public async mediateActor(action: I): Promise<A> {\n    // Mediate to one actor and run that actor.\n    return await this.mediateWith(action, this.publish(action));\n  }\n\n  /**\n   * Mediate for the given action.\n   *\n   * This will send the test action on all actors in the bus.\n   * The action will be run on the actor that tests _best_,\n   * of which the result will be returned.\n   *\n   * @param {I} action The action to mediate for.\n   * @return {Promise<O extends IActorOutput>} A promise that resolves to the mediation result.\n   */\n  public async mediate(action: I): Promise<O> {\n    // Mediate to one actor and run the action on it\n    const actor: A = await this.mediateActor(action);\n    return actor.runObservable(action);\n  }\n\n  /**\n   * Mediate for the given action with the given actor test results for the action.\n   *\n   * One actor must be returned that provided the _best_ test result.\n   * How '_best_' is interpreted, depends on the implementation of the Mediator.\n   *\n   * @param {I} action The action to mediate for.\n   * @param {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n   * O extends IActorOutput>[]} testResults The actor test results for the action.\n   * @return {Promise<A extends Actor<I, T, O>>} A promise that resolves to the _best_ actor.\n   */\n  protected abstract mediateWith(action: I, testResults: IActorReply<A, I, T, O>[]): Promise<A>;\n}\n\nexport interface IMediatorArgs<A extends Actor<I, T, O>,\n  I extends IAction, T extends IActorTest, O extends IActorOutput> {\n  /**\n   * The name for this mediator.\n   * @default {<rdf:subject>}\n   */\n  name: string;\n  /**\n   * The bus this mediator will mediate over.\n   */\n  bus: Bus<A, I, T, O>;\n}\n\nexport type Mediate<I extends IAction, O extends IActorOutput, T extends IActorTest = IActorTest> =\nMediator<Actor<I, T, O>, I, T, O>;\n"]}