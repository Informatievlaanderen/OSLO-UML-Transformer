"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchInitPreprocessor = void 0;
/* eslint-disable import/no-nodejs-modules */
const http_1 = require("http");
const https_1 = require("https");
const bus_http_1 = require("@comunica/bus-http");
/**
 * Overrides the HTTP agent to perform better in Node.js.
 */
class FetchInitPreprocessor {
    constructor(agentOptions) {
        const httpAgent = new http_1.Agent(agentOptions);
        const httpsAgent = new https_1.Agent(agentOptions);
        this.agent = (_parsedURL) => _parsedURL.protocol === 'http:' ? httpAgent : httpsAgent;
    }
    async handle(init) {
        // Convert body Web stream to Node stream, as node-fetch does not support Web streams
        let halfDuplex = false;
        if (init.body && typeof init.body !== 'string' && 'getReader' in init.body) {
            init.body = bus_http_1.ActorHttp.toNodeReadable(init.body);
            // The Fetch API requires specific options to be set when sending body streams:
            // - 'keepalive' can not be true
            // - 'duplex' must be set to 'half'
            halfDuplex = true;
        }
        return {
            ...init,
            agent: this.agent,
            keepalive: !halfDuplex ? true : undefined,
            duplex: halfDuplex ? 'half' : undefined,
        };
    }
    async createAbortController() {
        // Fallback to abort-controller for Node 14 backward compatibility
        /* istanbul ignore next */
        const AbortController = globalThis.AbortController || await Promise.resolve().then(() => require('abort-controller'));
        return new AbortController();
    }
}
exports.FetchInitPreprocessor = FetchInitPreprocessor;
/* eslint-enable import/no-nodejs-modules */
//# sourceMappingURL=FetchInitPreprocessor.js.map