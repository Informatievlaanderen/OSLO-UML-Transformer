{"version":3,"file":"ActorHttpFetch.js","sourceRoot":"","sources":["ActorHttpFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionHttp, IActorHttpOutput, IActorHttpArgs } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport { KeysHttp } from '@comunica/context-entries';\nimport type { IMediatorTypeTime } from '@comunica/mediatortype-time';\nimport type { Readable } from 'readable-stream';\nimport 'cross-fetch/polyfill';\nimport { FetchInitPreprocessor } from './FetchInitPreprocessor';\nimport type { IFetchInitPreprocessor } from './IFetchInitPreprocessor';\n\n/**\n * A node-fetch actor that listens on the 'init' bus.\n *\n * It will call `fetch` with either action.input or action.url.\n */\nexport class ActorHttpFetch extends ActorHttp {\n  private readonly userAgent: string;\n  private readonly fetchInitPreprocessor: IFetchInitPreprocessor;\n\n  public constructor(args: IActorHttpFetchArgs) {\n    super(args);\n    this.userAgent = ActorHttpFetch.createUserAgent();\n    this.fetchInitPreprocessor = new FetchInitPreprocessor(args.agentOptions);\n  }\n\n  public static createUserAgent(): string {\n    return `Comunica/actor-http-fetch (${typeof globalThis.navigator === 'undefined' ?\n      `Node.js ${process.version}; ${process.platform}` :\n      `Browser-${globalThis.navigator.userAgent}`})`;\n  }\n\n  public async test(action: IActionHttp): Promise<IMediatorTypeTime> {\n    return { time: Number.POSITIVE_INFINITY };\n  }\n\n  /**\n   * Perform a fetch request, taking care of retries\n   * @param fetchFn\n   * @param requestInput Url or RequestInfo to pass to fetchFn\n   * @param requestInit RequestInit to pass to fetch function\n   * @param retryCount Maximum retries after which to abort\n   * @param retryDelay Time in milliseconds to wait between retries\n   * @returns a fetch `Response` object\n   */\n  private static async getResponse(\n    fetchFn: (input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>,\n    requestInput: RequestInfo | URL,\n    requestInit: RequestInit,\n    retryCount: number,\n    retryDelay: number,\n    throwOnServerError: boolean,\n  ): Promise<Response> {\n    let lastError: unknown;\n    // The retryCount is 0-based. Therefore, add 1 to triesLeft.\n    let triesLeft = retryCount + 1;\n\n    // When retry count is greater than 0, repeat fetch.\n    while (triesLeft-- > 0) {\n      try {\n        const response = await fetchFn(requestInput, requestInit);\n        // Check, if server sent a 5xx error response.\n        if (throwOnServerError && response.status >= 500 && response.status < 600) {\n          throw new Error(`Server replied with response code ${response.status}: ${response.statusText}`);\n        }\n        return response;\n      } catch (error: unknown) {\n        lastError = error;\n        // If the fetch was aborted by timeout, we won't retry.\n        if (requestInit.signal?.aborted) {\n          throw error;\n        }\n\n        if (triesLeft > 0) {\n          // Wait for specified delay, before retrying.\n          await new Promise((resolve, reject) => {\n            setTimeout(resolve, retryDelay);\n            // Cancel waiting, if timeout is reached.\n            requestInit.signal?.addEventListener('abort', () => {\n              reject(new Error('Fetch aborted by timeout.'));\n            });\n          });\n        }\n      }\n    }\n    // The fetch was not successful. We throw.\n    if (retryCount > 0) {\n      // Feedback the last error, if there were retry attempts.\n      throw new Error(`Number of fetch retries (${retryCount}) exceeded. Last error: ${String(lastError)}`);\n    } else {\n      throw lastError;\n    }\n  }\n\n  public async run(action: IActionHttp): Promise<IActorHttpOutput> {\n    // Prepare headers\n    const initHeaders = action.init?.headers ?? {};\n    action.init = action.init ?? {};\n    action.init.headers = new Headers(initHeaders);\n    if (!action.init.headers.has('user-agent')) {\n      action.init.headers.append('user-agent', this.userAgent);\n    }\n    const authString: string | undefined = action.context.get(KeysHttp.auth);\n    if (authString) {\n      action.init.headers.append('Authorization', `Basic ${Buffer.from(authString).toString('base64')}`);\n    }\n\n    // Log request\n    this.logInfo(action.context, `Requesting ${typeof action.input === 'string' ?\n      action.input :\n      action.input.url}`, () => ({\n      headers: ActorHttp.headersToHash(new Headers(action.init!.headers)),\n      method: action.init!.method || 'GET',\n    }));\n\n    // TODO: remove this workaround once this has a fix: https://github.com/inrupt/solid-client-authn-js/issues/1708\n    if (action.init?.headers && 'append' in action.init.headers && action.context.has(KeysHttp.fetch)) {\n      action.init.headers = ActorHttp.headersToHash(action.init.headers);\n    }\n\n    let requestInit = { ...action.init };\n\n    if (action.context.get(KeysHttp.includeCredentials)) {\n      requestInit.credentials = 'include';\n    }\n\n    const httpTimeout: number | undefined = action.context?.get(KeysHttp.httpTimeout);\n    let requestTimeout: NodeJS.Timeout | undefined;\n    let onTimeout: (() => void) | undefined;\n    if (httpTimeout !== undefined) {\n      const controller = await this.fetchInitPreprocessor.createAbortController();\n      requestInit.signal = controller.signal;\n      onTimeout = () => controller.abort();\n      requestTimeout = setTimeout(() => onTimeout!(), httpTimeout);\n    }\n\n    try {\n      requestInit = await this.fetchInitPreprocessor.handle(requestInit);\n      // Number of retries to perform after a failed fetch.\n      const retryCount: number = action.context?.get(KeysHttp.httpRetryCount) ?? 0;\n      const retryDelay: number = action.context?.get(KeysHttp.httpRetryDelay) ?? 0;\n      const retryOnSeverError: boolean = action.context?.get(KeysHttp.httpRetryOnServerError) ?? false;\n      const customFetch: ((input: RequestInfo, init?: RequestInit) => Promise<Response>) | undefined = action\n        .context?.get(KeysHttp.fetch);\n\n      // Execute the fetch (with retries and timeouts, if applicable).\n      const response = await ActorHttpFetch.getResponse(\n        customFetch || fetch, action.input, requestInit, retryCount, retryDelay, retryOnSeverError,\n      );\n\n      // We remove or update the timeout\n      if (requestTimeout !== undefined) {\n        const httpBodyTimeout = action.context?.get(KeysHttp.httpBodyTimeout) || false;\n        if (httpBodyTimeout && response.body) {\n          onTimeout = () => response.body?.cancel(new Error(`HTTP timeout when reading the body of ${response.url}.\nThis error can be disabled by modifying the 'httpBodyTimeout' and/or 'httpTimeout' options.`));\n          (<Readable><any>response.body).on('close', () => {\n            clearTimeout(requestTimeout);\n          });\n        } else {\n          clearTimeout(requestTimeout);\n        }\n      }\n\n      // Node-fetch does not support body.cancel, while it is mandatory according to the fetch and readablestream api.\n      // If it doesn't exist, we monkey-patch it.\n      if (response.body && !response.body.cancel) {\n        response.body.cancel = async(error?: Error) => {\n          (<Readable><any>response.body).destroy(error);\n          if (requestTimeout !== undefined) {\n            // We make sure to remove the timeout if it is still enabled\n            clearTimeout(requestTimeout);\n          }\n        };\n      }\n\n      return response;\n    } catch (error: unknown) {\n      if (requestTimeout !== undefined) {\n        clearTimeout(requestTimeout);\n      }\n      throw error;\n    }\n  }\n}\n\nexport interface IActorHttpFetchArgs extends IActorHttpArgs {\n  /**\n   * The agent options for the HTTP agent\n   * @range {json}\n   * @default {{ \"keepAlive\": true, \"maxSockets\": 5 }}\n   */\n  agentOptions?: Record<string, any>;\n}\n"]}