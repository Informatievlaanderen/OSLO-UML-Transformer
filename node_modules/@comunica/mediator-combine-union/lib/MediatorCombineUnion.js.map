{"version":3,"file":"MediatorCombineUnion.js","sourceRoot":"","sources":["MediatorCombineUnion.ts"],"names":[],"mappings":";;;AACA,yCAA0C;AAE1C;;;;GAIG;AACH,MAAa,oBACa,SAAQ,eAAoB;IAIpD,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;IACxC,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,MAAS;QAC5B,IAAI,WAAsC,CAAC;QAC3C,IAAI;YACF,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SACpC;QAAC,MAAM;YACN,WAAW,GAAG,EAAE,CAAC;SAClB;QAED,wBAAwB;QACxB,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;QAEzD,4BAA4B;QAC5B,MAAM,OAAO,GAAQ,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAEtG,+BAA+B;QAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAES,WAAW;QACnB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3C,CAAC;IAES,cAAc;QACtB,OAAO,CAAC,OAAY,EAAE,EAAE;YACtB,MAAM,IAAI,GAAQ,EAAE,CAAC;YACrB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YACtB,iDAAiD;YACjD,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAW,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC1D,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE;gBAC7B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YACvD,CAAC,CAAC,CAAC;YACL,OAAO,IAAI,CAAC;QACd,CAAC,CAAC;IACJ,CAAC;CACF;AA5CD,oDA4CC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\n\n/**\n * A comunica mediator that takes the union of all actor results.\n *\n * The actors that are registered first will have priority on setting overlapping fields.\n */\nexport class MediatorCombineUnion<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n  O extends IActorOutput> extends Mediator<A, I, T, O> implements IMediatorCombineUnionArgs<A, I, T, O> {\n  public readonly field: string;\n  public readonly combiner: (results: O[]) => O;\n\n  public constructor(args: IMediatorCombineUnionArgs<A, I, T, O>) {\n    super(args);\n    this.combiner = this.createCombiner();\n  }\n\n  public async mediate(action: I): Promise<O> {\n    let testResults: IActorReply<A, I, T, O>[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      testResults = [];\n    }\n\n    // Delegate test errors.\n    await Promise.all(testResults.map(({ reply }) => reply));\n\n    // Run action on all actors.\n    const results: O[] = await Promise.all(testResults.map(result => result.actor.runObservable(action)));\n\n    // Return the combined results.\n    return this.combiner(results);\n  }\n\n  protected mediateWith(): Promise<A> {\n    throw new Error('Method not supported.');\n  }\n\n  protected createCombiner(): (results: O[]) => O {\n    return (results: O[]) => {\n      const data: any = {};\n      data[this.field] = {};\n      // eslint-disable-next-line unicorn/prefer-spread\n      [{}].concat(results.map((result: any) => result[this.field]))\n        .forEach((value, index, arr) => {\n          data[this.field] = { ...value, ...data[this.field] };\n        });\n      return data;\n    };\n  }\n}\n\nexport interface IMediatorCombineUnionArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n  O extends IActorOutput> extends IMediatorArgs<A, I, T, O> {\n  /**\n   * The field name of the test result field over which must be mediated.\n   */\n  field: string;\n}\n"]}