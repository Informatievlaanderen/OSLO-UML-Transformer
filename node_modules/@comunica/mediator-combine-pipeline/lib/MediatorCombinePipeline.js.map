{"version":3,"file":"MediatorCombinePipeline.js","sourceRoot":"","sources":["MediatorCombinePipeline.ts"],"names":[],"mappings":";;;AACA,yCAA0C;AAG1C;;;GAGG;AACH,MAAa,uBAEX,SAAQ,eAAoB;IAK5B,YAAmB,IAA8C;QAC/D,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,MAAS;QAC5B,IAAI,WAAiE,CAAC;QACtE,IAAI;YACF,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SACpC;QAAC,MAAM;YACN,8DAA8D;YAC9D,OAAO,MAAM,CAAC;SACf;QAED,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,MAAM,YAAY,GAA8B,EAAE,CAAC;YACnD,KAAK,MAAM,MAAM,IAAI,WAAW,EAAE;gBAChC,IAAI;oBACF,MAAM,MAAM,CAAC,KAAK,CAAC;oBACnB,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBAC3B;gBAAC,MAAM;oBACN,gBAAgB;iBACjB;aACF;YACD,WAAW,GAAG,YAAY,CAAC;SAC5B;QAED,wBAAwB;QACxB,WAAW,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAC,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;QAE7G,gDAAgD;QAChD,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,kEAAkE;YAClE,MAAM,QAAQ,GAAG,CAAC,IAAO,EAAU,EAAE;gBACnC,0DAA0D;gBAC1D,uBAAuB;gBACvB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAQ,IAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBAE3D,uCAAuC;gBACvC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;oBAC7B,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;iBAChE;gBACD,OAAO,KAAK,CAAC;YACf,CAAC,CAAC;YAEF,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,CAChD,CAAC,IAAI,CAAC,KAAK,KAAK,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtC,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACtD;QAED,8BAA8B;QAC9B,yDAAyD;QACzD,IAAI,MAAM,GAAM,MAAM,CAAC;QACvB,KAAK,MAAM,EAAE,KAAK,EAAE,IAAI,WAAW,EAAE;YACnC,MAAM,GAAG,EAAE,GAAG,MAAM,EAAE,GAAG,MAAM,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;SAC9D;QAED,gCAAgC;QAChC,OAAO,MAAM,CAAC;IAChB,CAAC;IAES,WAAW;QACnB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3C,CAAC;CACF;AAtED,0DAsEC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\n\n/**\n * A comunica mediator that goes over all actors in sequence and forwards I/O.\n * This required the action input and the actor output to be of the same type.\n */\nexport class MediatorCombinePipeline\n<A extends Actor<H, T, H>, H extends IAction | (IActorOutput & { context: IActionContext }), T extends IActorTest>\n  extends Mediator<A, H, T, H> {\n  public readonly filterErrors: boolean | undefined;\n  public readonly order: 'increasing' | 'decreasing' | undefined;\n  public readonly field: string | undefined;\n\n  public constructor(args: IMediatorCombinePipelineArgs<A, H, T, H>) {\n    super(args);\n  }\n\n  public async mediate(action: H): Promise<H> {\n    let testResults: IActorReply<A, H, T, H>[] | { actor: A; reply: T }[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      // If no actors are available, just return the input as output\n      return action;\n    }\n\n    if (this.filterErrors) {\n      const _testResults: IActorReply<A, H, T, H>[] = [];\n      for (const result of testResults) {\n        try {\n          await result.reply;\n          _testResults.push(result);\n        } catch {\n          // Ignore errors\n        }\n      }\n      testResults = _testResults;\n    }\n\n    // Delegate test errors.\n    testResults = await Promise.all(testResults.map(async({ actor, reply }) => ({ actor, reply: await reply })));\n\n    // Order the test results if ordering is enabled\n    if (this.order) {\n      // A function used to extract an ordering value from a test result\n      const getOrder = (elem: T): number => {\n        // If there is a field key use it, otherwise use the input\n        // element for ordering\n        const value = this.field ? (<any> elem)[this.field] : elem;\n\n        // Check the ordering value is a number\n        if (typeof value !== 'number') {\n          throw new Error('Cannot order elements that are not numbers.');\n        }\n        return value;\n      };\n\n      testResults = testResults.sort((actor1, actor2) =>\n        (this.order === 'increasing' ? 1 : -1) *\n        (getOrder(actor1.reply) - getOrder(actor2.reply)));\n    }\n\n    // Pass action to first actor,\n    // and each actor output as input to the following actor.\n    let handle: H = action;\n    for (const { actor } of testResults) {\n      handle = { ...handle, ...await actor.runObservable(handle) };\n    }\n\n    // Return the final actor output\n    return handle;\n  }\n\n  protected mediateWith(): Promise<A> {\n    throw new Error('Method not supported.');\n  }\n}\n\nexport interface IMediatorCombinePipelineArgs<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n  O extends IActorOutput> extends IMediatorArgs<A, I, T, O> {\n  /**\n   * If actors that throw test errors should be ignored\n   */\n  filterErrors?: boolean;\n  /**\n   * The field to use for ordering (if the ordering strategy is chosen).\n   * Leave undefined if the test output is a number rather than an object.\n   */\n  field?: string;\n  /**\n   * The strategy of ordering the pipeline (increasing or decreasing).\n   * For choosing to leave the order of the pipeline unchanged, leave this undefined.\n   * For choosing to order by increasing values: 'increasing'.\n   * For choosing to order by decreasing values: 'decreasing'.\n   */\n  order?: 'increasing' | 'decreasing' | undefined;\n}\n"]}