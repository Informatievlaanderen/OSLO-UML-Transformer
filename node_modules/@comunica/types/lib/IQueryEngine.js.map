{"version":3,"file":"IQueryEngine.js","sourceRoot":"","sources":["IQueryEngine.ts"],"names":[],"mappings":"","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { BindingsStream } from './Bindings';\nimport type { IActionContext } from './IActionContext';\nimport type { IDataSource } from './IDataSource';\nimport type { IQueryContextCommon, QueryAlgebraContext, QueryStringContext } from './IQueryContext';\nimport type { IQueryExplained, QueryEnhanced, QueryExplainMode } from './IQueryOperationResult';\n\nexport type QueryFormatType = string | Algebra.Operation;\nexport type SourceType = IDataSource;\nexport type QueryType = QueryEnhanced & { context?: IActionContext };\n\n/**\n * Base interface for a Comunica query engine.\n */\nexport interface IQueryEngine<\n  // TODO: In the next major update, remove QueryContext arg, as we have enough with the other args.\n  QueryContext extends IQueryContextCommon = IQueryContextCommon,\n  QueryStringContextInner extends RDF.QueryStringContext = QueryStringContext,\n  QueryAlgebraContextInner extends RDF.QueryAlgebraContext = QueryAlgebraContext> extends\n  RDF.StringQueryable<RDF.AllMetadataSupport, QueryStringContextInner>,\n  RDF.AlgebraQueryable<Algebra.Operation, RDF.AllMetadataSupport, QueryAlgebraContextInner>,\n  RDF.StringSparqlQueryable<RDF.SparqlResultSupport, QueryStringContextInner>,\n  RDF.AlgebraSparqlQueryable<Algebra.Operation, RDF.SparqlResultSupport, QueryAlgebraContextInner> {\n\n  /**\n   * Query the bindings results of a SELECT query.\n   * @param query A query string or algebra object.\n   * @param context A context.\n   */\n  queryBindings: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n  ) => Promise<BindingsStream>;\n\n  /**\n   * Query the quad results of a CONSTRUCT or DESCRIBE query.\n   * @param query A query string or algebra object.\n   * @param context A context.\n   */\n  queryQuads: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n  ) => Promise<AsyncIterator<RDF.Quad> & RDF.ResultStream<RDF.Quad>>;\n\n  /**\n   * Query the boolean result of an ASK query.\n   * @param query A query string or algebra object.\n   * @param context A context.\n   */\n  queryBoolean: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n  ) => Promise<boolean>;\n\n  /**\n   * Execute an UPDATE query.\n   * @param query A query string or algebra object.\n   * @param context A context.\n   */\n  queryVoid: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n  ) => Promise<void>;\n\n  /**\n   * Initiate a given query.\n   * This will produce a future to a query result, which has to be executed to obtain the query results.\n   * This can reject given an unsupported or invalid query.\n   *\n   * This method is prefered in case you don't know beforehand what type of query will be executed,\n   * or if you require access to the metadata of the results.\n   *\n   * @param query A query string or algebra object.\n   * @param context A context.\n   */\n  query: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n  ) => Promise<QueryType>;\n\n  /**\n   * Explain the given query\n   * @param {string | Algebra.Operation} query A query string or algebra.\n   * @param context A query context.\n   * @param explainMode The explain mode.\n   * @return {Promise<IQueryExplained>}\n   *  A promise that resolves to the query output.\n   */\n  explain: <QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context: QueryFormatTypeInner extends string ? QueryStringContextInner : QueryAlgebraContextInner,\n    explainMode: QueryExplainMode,\n  ) => Promise<IQueryExplained>;\n  /**\n   * @param context An optional context.\n   * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.\n   */\n  getResultMediaTypes: (context?: IActionContext) => Promise<Record<string, number>>;\n  /**\n   * @param context An optional context.\n   * @return {Promise<{[p: string]: number}>} All available SPARQL result media type formats.\n   */\n  getResultMediaTypeFormats: (context?: IActionContext) => Promise<Record<string, string>>;\n  /**\n   * Convert a query result to a string stream based on a certain media type.\n   * @param {QueryType} queryResult A query result.\n   * @param {string} mediaType A media type.\n   * @param {IActionContext} context An optional context.\n   * @return {Promise<IActorQueryResultSerializeOutput>} A text stream.\n   */\n  resultToString: (queryResult: QueryType, mediaType?: string, context?: any) => any;\n  /**\n   * Invalidate all internal caches related to the given page URL.\n   * If no page URL is given, then all pages will be invalidated.\n   * @param {string} url The page URL to invalidate.\n   * @return {Promise<any>} A promise resolving when the caches have been invalidated.\n   */\n  invalidateHttpCache: (url?: string) => Promise<any>;\n}\n"]}