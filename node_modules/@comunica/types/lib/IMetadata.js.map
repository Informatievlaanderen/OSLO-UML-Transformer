{"version":3,"file":"IMetadata.js","sourceRoot":"","sources":["IMetadata.ts"],"names":[],"mappings":"","sourcesContent":["import type * as RDF from '@rdfjs/types';\n\n/**\n * A type-safe metadata object.\n * This interface still allows other non-standard metadata entries to be added.\n */\nexport interface IMetadata<OrderItemsType extends RDF.Variable | RDF.QuadTermName> extends Record<string, any> {\n  /**\n   * The validity state of this metadata object.\n   */\n  state: IMetadataValidationState;\n\n  /**\n   * An estimate of the number of bindings in the source.\n   */\n  cardinality: QueryResultCardinality;\n  /**\n   * If any of the bindings could contain an undefined variable binding.\n   * If this is false, then all variables are guaranteed to have a defined bound value in the bindingsStream.\n   */\n  canContainUndefs: boolean;\n\n  /* Entries below are optional */\n\n  /**\n   * The number of bindings per page in the source.\n   * This may be undefined for sources that don't do paging.\n   */\n  pageSize?: number;\n  /**\n   * The time it takes to request a page in milliseconds.\n   * This is the time until the first byte arrives.\n   */\n  requestTime?: number;\n  /**\n   * The order of the bindings in the stream.\n   *\n   * For example, [{ variable: 'keyA', order: 'asc' }, { variable: 'keyB', order: 'desc' }] indicates that bindings are\n   * first sorted first by values of 'keyA' in ascending order, and then by 'keyB' in descending order.\n   *\n   * Order is defined according to the SPARQL order semantics.\n   * For ascending order, this corresponds to https./www.w3.org/TR/sparql11-query/#op_lt,\n   * otherwise the inverse.\n   * For those cases where SPARQL does not define order, the (ascending) order is defined as a lexicographical\n   * comparison on the string values of terms, which is defined by `termToString` from the `\"rdf-string\"` package.\n   *\n   * If order is undefined, then the order is unknown.\n   */\n  order?: TermsOrder<OrderItemsType>;\n\n  /**\n   * All available alternative orders.\n   */\n  availableOrders?: RDF.QueryOperationOrder<OrderItemsType>[];\n}\n\nexport type TermsOrder<OrderItemsType> = { term: OrderItemsType; direction: 'asc' | 'desc' }[];\nexport type MetadataBindings = IMetadata<RDF.Variable> & {\n  /**\n   * The list of variables for which bindings are provided in the bindings stream.\n   */\n  variables: RDF.Variable[];\n};\nexport type MetadataQuads = IMetadata<RDF.QuadTermName>;\n\nexport type QueryResultCardinality = RDF.QueryResultCardinality & {\n  /**\n   * If this field is set, this means that the cardinality is defined across this whole dataset.\n   * If this field is not set, then the cardinality is only defined for the current stream.\n   */\n  dataset?: string;\n};\n\n/**\n * Represents the validity of a metadata object.\n */\nexport interface IMetadataValidationState {\n  /**\n   * If the metadata object is valid.\n   *\n   * If it is invalid, the metadata values should be considered outdated, and a new version should be requested.\n   */\n  valid: boolean;\n  /**\n   * Mark the metadta object as invalid.\n   *\n   * This will set the `valid` field to false, and invoke the invalidation listeners.\n   */\n  invalidate: () => void;\n  /**\n   * Add an listener that will be invoked when the metadata object becomes invalid.\n   *\n   * No expensive operations should be done in these listeners, only other invalidations.\n   * If other operations should be done, those should be scheduled in next ticks.\n   *\n   * @param listener An invalidation listener.\n   */\n  addInvalidateListener: (listener: () => void) => void;\n}\n"]}