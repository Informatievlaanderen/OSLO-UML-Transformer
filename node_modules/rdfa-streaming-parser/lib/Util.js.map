{"version":3,"file":"Util.js","sourceRoot":"","sources":["Util.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from \"@rdfjs/types\";\nimport {resolve} from \"relative-to-absolute-iri\";\nimport {IActiveTag} from \"./IActiveTag\";\nimport {RDFA_CONTENTTYPES, RdfaProfile} from \"./RdfaProfile\";\nimport {DataFactory} from \"rdf-data-factory\";\n\n/**\n * A collection of utility functions.\n */\nexport class Util {\n\n  public static readonly RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  public static readonly XSD = 'http://www.w3.org/2001/XMLSchema#';\n  public static readonly RDFA = 'http://www.w3.org/ns/rdfa#';\n\n  private static readonly PREFIX_REGEX: RegExp = /\\s*([^:\\s]*)*:\\s*([^\\s]*)*\\s*/g;\n  private static readonly TIME_REGEXES: { regex: RegExp, type: string }[] = [\n    {\n      regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\\.[0-9])?S)?)?$/,\n      type: 'duration',\n    },\n    {\n      regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/,\n      type: 'dateTime',\n    },\n    { regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/, type: 'date' },\n    { regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/, type: 'time' },\n    { regex: /^[0-9]+-[0-9][0-9]$/, type: 'gYearMonth' },\n    { regex: /^[0-9]+$/, type: 'gYear' },\n  ];\n  private static readonly IRI_REGEX: RegExp = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`]*$/;\n\n  public readonly dataFactory: RDF.DataFactory;\n  public baseIRI: RDF.NamedNode;\n  public blankNodeFactory: () => RDF.BlankNode;\n  private readonly baseIRIDocument: RDF.NamedNode;\n\n  constructor(dataFactory: RDF.DataFactory, baseIRI: string) {\n    this.dataFactory = dataFactory || new DataFactory();\n    this.baseIRI = this.dataFactory.namedNode(baseIRI || '');\n    this.baseIRIDocument = this.baseIRI;\n  }\n\n  /**\n   * Retrieve the prefixes of the current tag's attributes.\n   * @param {{[p: string]: string}} attributes A tag's attributes.\n   * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.\n   * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.\n   * @return {{[p: string]: string}} The new prefixes.\n   */\n  public static parsePrefixes(attributes: {[s: string]: string},\n                              parentPrefixes: {[prefix: string]: string},\n                              xmlnsPrefixMappings: boolean): {[prefix: string]: string} {\n    const additionalPrefixes: {[prefix: string]: string} = {};\n    if (xmlnsPrefixMappings) {\n      for (const attribute in attributes) {\n        if (attribute.startsWith('xmlns')) {\n          additionalPrefixes[attribute.substr(6)] = attributes[attribute];\n        }\n      }\n    }\n\n    if (attributes.prefix || Object.keys(additionalPrefixes).length > 0) {\n      const prefixes: {[prefix: string]: string} = { ...parentPrefixes, ...additionalPrefixes };\n\n      if (attributes.prefix) {\n        let prefixMatch;\n        // tslint:disable-next-line:no-conditional-assignment\n        while (prefixMatch = Util.PREFIX_REGEX.exec(attributes.prefix)) {\n          prefixes[prefixMatch[1]] = prefixMatch[2];\n        }\n      }\n\n      return prefixes;\n    } else {\n      return parentPrefixes;\n    }\n  }\n\n  /**\n   * Expand the given term value based on the given prefixes.\n   * @param {string} term A term value.\n   * @param {{[p: string]: string}[]} prefixes The available prefixes.\n   * @return {string} An expanded URL, or the term as-is.\n   */\n  public static expandPrefixedTerm(term: string, activeTag: IActiveTag): string {\n    // Check if the term is prefixed\n    const colonIndex: number = term.indexOf(':');\n    let prefix: string;\n    let local: string;\n    if (colonIndex >= 0) {\n      prefix = term.substr(0, colonIndex);\n      local = term.substr(colonIndex + 1);\n    }\n\n    // Expand default namespace\n    if (prefix === '') {\n      return 'http://www.w3.org/1999/xhtml/vocab#' + local;\n    }\n\n    // Try to expand the prefix\n    if (prefix) {\n      const prefixElement = activeTag.prefixesAll[prefix];\n      if (prefixElement) {\n        return prefixElement + local;\n      }\n    }\n\n    // Try to expand the term\n    if (term) {\n      const expandedTerm = activeTag.prefixesAll[term.toLocaleLowerCase()];\n      if (expandedTerm) {\n        return expandedTerm;\n      }\n    }\n\n    return term;\n  }\n\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n  public static isValidIri(iri: string): boolean {\n    return Util.IRI_REGEX.test(iri);\n  }\n\n  /**\n   * Determine the RDFa profile from the given content type.\n   * Defaults to the default RDFa profile (all features enabled) for unknown content types.\n   * @param {string} contentType A content type.\n   * @returns {RdfaProfile} An RDFa profile.\n   */\n  public static contentTypeToProfile(contentType: string): RdfaProfile {\n    return RDFA_CONTENTTYPES[contentType] || '';\n  }\n\n  /**\n   * Get the base IRI.\n   * @param {string} baseIriValue A base IRI value.\n   * @return A base IRI named node.\n   */\n  public getBaseIRI(baseIriValue: string): RDF.NamedNode {\n    let href: string = baseIriValue;\n    const fragmentIndex = href.indexOf('#');\n    if (fragmentIndex >= 0) {\n      href = href.substr(0, fragmentIndex);\n    }\n    return this.dataFactory.namedNode(resolve(href, this.baseIRI.value));\n  }\n\n  /**\n   * If the term is a boolean, return the baseIRI, otherwise return the term as-is.\n   * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.\n   * @param {IActiveTag} activeTag An active tag.\n   * @returns {Term} A term.\n   */\n  public getResourceOrBaseIri(term: RDF.Term | boolean, activeTag: IActiveTag): RDF.NamedNode {\n    return term === true ? this.getBaseIriTerm(activeTag) : <RDF.NamedNode> term;\n  }\n\n  /**\n   * Get the active base IRI as an RDF term.\n   * @param {IActiveTag} activeTag The active tag.\n   * @return {NamedNode} The base IRI term.\n   */\n  public getBaseIriTerm(activeTag: IActiveTag): RDF.NamedNode {\n    return activeTag.localBaseIRI || this.baseIRI;\n  }\n\n  /**\n   * Create vocab terms for the given terms attribute.\n   * @param {string} terms An attribute value.\n   * @param {IActiveTag} activeTag The current active tag.\n   * @param {boolean} allowTerms If terms are allowed (strings without ':')\n   * @param {boolean} allowBlankNode If blank nodes are allowed.\n   * @return {Term[]} The IRI terms.\n   */\n  public createVocabIris<B extends boolean>(terms: string, activeTag: IActiveTag, allowTerms: boolean,\n                                            allowBlankNode: B): B extends true\n    ? (RDF.BlankNode | RDF.NamedNode)[] : RDF.NamedNode[];\n  public createVocabIris(terms: string, activeTag: IActiveTag, allowTerms: boolean,\n                         allowBlankNode: boolean): (RDF.NamedNode | RDF.BlankNode)[] {\n    return terms.split(/\\s+/)\n      .filter((term) => term && (allowTerms || term.indexOf(':') >= 0))\n      .map((property) => this.createIri(property, activeTag, true, true, allowBlankNode))\n      .filter((term) => term != null);\n  }\n\n  /**\n   * Create a new literal node.\n   * @param {string} literal The literal value.\n   * @param {IActiveTag} activeTag The current active tag.\n   * @return {Literal} A new literal node.\n   */\n  public createLiteral(literal: string, activeTag: IActiveTag): RDF.Literal {\n    if (activeTag.interpretObjectAsTime && !activeTag.datatype) {\n      for (const entry of Util.TIME_REGEXES) {\n        if (literal.match(entry.regex)) {\n          activeTag.datatype = this.dataFactory.namedNode(Util.XSD + entry.type);\n          break;\n        }\n      }\n    }\n    return this.dataFactory.literal(literal, activeTag.datatype || activeTag.language);\n  }\n\n  /**\n   * Create a blank node.\n   * @returns {BlankNode} A new blank node.\n   */\n  public createBlankNode(): RDF.BlankNode {\n    if (this.blankNodeFactory) {\n      return this.blankNodeFactory();\n    }\n    return this.dataFactory.blankNode();\n  }\n\n  /**\n   * Create a named node for the given term.\n   * This will take care of prefix detection.\n   * @param {string} term A term string (CURIE or IRI, aka safe-CURIE in RDFa spec).\n   * @param {IActiveTag} activeTag The current active tag.\n   * @param {boolean} vocab If creating an IRI in vocab-mode (based on vocab IRI),\n   *                        or in base-mode (based on base IRI).\n   * @param {boolean} allowSafeCurie If safe CURIEs are allowed\n   *                                 (invalid CURIEs between square brackets will return null)\n   *                                 Otherwise, only IRIs are allowed.\n   * @param {boolean} allowBlankNode If blank nodes are allowed. Otherwise null will be returned.\n   * @return {Term} An RDF term or null.\n   */\n  public createIri<B extends boolean>(term: string, activeTag: IActiveTag, vocab: boolean, allowSafeCurie: boolean,\n                                      allowBlankNode: B): B extends true\n    ? (RDF.NamedNode | RDF.BlankNode) : RDF.NamedNode;\n  public createIri<B extends boolean>(term: string, activeTag: IActiveTag, vocab: boolean, allowSafeCurie: boolean,\n                                      allowBlankNode: B): RDF.NamedNode | RDF.BlankNode {\n    term = term || '';\n\n    if (!allowSafeCurie) {\n      if (!vocab) {\n        term = resolve(term, this.getBaseIriTerm(activeTag).value);\n      }\n      if (!Util.isValidIri(term)) {\n        return null;\n      }\n      return this.dataFactory.namedNode(term);\n    }\n\n    // Handle strict CURIEs\n    if (term.length > 0 && term[0] === '[' && term[term.length - 1] === ']') {\n      term = term.substr(1, term.length - 2);\n\n      // Strict CURIEs MUST have a prefix separator\n      if (term.indexOf(':') < 0) {\n        return null;\n      }\n    }\n\n    // Handle blank nodes\n    if (term.startsWith('_:')) {\n      return allowBlankNode ? this.dataFactory.blankNode(term.substr(2) || 'b_identity') : null;\n    }\n\n    // Handle vocab IRIs\n    if (vocab) {\n      if (activeTag.vocab && term.indexOf(':') < 0) {\n        return this.dataFactory.namedNode(activeTag.vocab + term);\n      }\n    }\n\n    // Handle prefixed IRIs\n    let iri: string = Util.expandPrefixedTerm(term, activeTag);\n    // Resolve against baseIRI if in base-mode, or if the term was a prefixed relative IRI\n    if (!vocab) {\n      iri = resolve(iri, this.getBaseIriTerm(activeTag).value);\n    } else if (term !== iri) {\n      iri = resolve(iri, this.baseIRIDocument.value);\n    }\n    if (!Util.isValidIri(iri)) {\n      return null;\n    }\n    return this.dataFactory.namedNode(iri);\n  }\n\n}\n"]}