{"version":3,"file":"RdfaParser.js","sourceRoot":"","sources":["RdfaParser.ts"],"names":[],"mappings":";;;AAEA,6CAAiD;AAEjD,qDAAuD;AAGvD,sEAAsE;AACtE,0DAA0D;AAE1D,+CAAwE;AACxE,iCAA4B;AAE5B;;GAEG;AACH,MAAa,UAAW,SAAQ,2BAAS;IAavC,YAAY,OAA4B;QACtC,KAAK,CAAC,EAAE,kBAAkB,EAAE,IAAI,EAAE,CAAC,CAAC;QAHrB,mBAAc,GAAiB,EAAE,CAAC;QAIjD,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,IAAI,CAAC,IAAI,GAAG,IAAI,WAAI,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;QAC3D,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC;QACjF,MAAM,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,WAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAC;QAC7G,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,2BAAa,CAAC,OAAO,CAAC,CAAC;QAC3D,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,CAAC;QACnD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAC/D,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAE3E,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC;QAEvD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC;YACvB,iBAAiB,EAAE,EAAE;YACrB,MAAM,EAAE,KAAK;YACb,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,WAAW,EAAE,EAAE;YACf,gBAAgB,EAAE,EAAE;YACpB,IAAI,EAAE,EAAE;YACR,WAAW,kCACN,eAAe,CAAC,UAAU,CAAC,GAC3B,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,CAAC,CAAC,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAC9E;YACD,cAAc,EAAG,EAAE;YACnB,WAAW,EAAE,KAAK;YAClB,KAAK,EAAE,OAAO,CAAC,KAAK;SACrB,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,MAAoB;QAChC,MAAM,MAAM,GAAG,IAAI,6BAAW,CAAC,EAAE,kBAAkB,EAAE,IAAI,EAAE,CAAC,CAAC;QAC7D,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAC3D,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAC/C,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1C,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACzD,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,UAAU,CAAC,KAAU,EAAE,QAAgB,EAAE,QAAoD;QAClG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;QACpC,QAAQ,EAAE,CAAC;IACb,CAAC;IAEM,MAAM,CAAC,QAAoD;QAChE,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;QAClB,QAAQ,EAAE,CAAC;IACb,CAAC;IAEM,SAAS,CAAC,IAAY,EAAE,UAAiC;QAC9D,iDAAiD;QACjD,IAAI,UAAU,GAAW,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;QACxD,OAAO,UAAU,GAAG,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,WAAW,EAAE;YACpE,UAAU,EAAE,CAAC;SACd;QACD,IAAI,SAAS,GAAe,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC5D,2FAA2F;QAC3F,IAAI,UAAU,KAAK,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;YACjD,SAAS,mCACJ,SAAS,KACZ,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,EACtE,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,WAAW,EAC5E,cAAc,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,cAAc,EAClF,KAAK,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,GACjE,CAAC;SACH;QAED,6EAA6E;QAC7E,MAAM,SAAS,GAAe;YAC5B,gBAAgB,EAAE,SAAS,CAAC,gBAAgB;YAC5C,iBAAiB,EAAE,EAAE;YACrB,MAAM,EAAE,QAAQ,IAAI,UAAU;YAC9B,WAAW,EAAsD,EAAE;YACnE,gBAAgB,EAAE,SAAS,CAAC,WAAW;YACvC,YAAY,EAAE,SAAS,CAAC,YAAY;YACpC,IAAI;YACJ,WAAW,EAAE,IAAI;YACjB,cAAc,EAAE,IAAI;YACpB,WAAW,EAAE,KAAK;SACnB,CAAC;QACF,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAEpC,kCAAkC;QAClC,IAAI,SAAS,CAAC,gBAAgB,EAAE;YAC9B,4GAA4G;YAC5G,6EAA6E;YAC7E,KAAK,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,IAAI,EAAE,EAAE;gBACjE,MAAM,MAAM,GAAG,SAAS,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;gBAChD,MAAM,YAAY,GAAG,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,GAAG,MAAM,CAAC;gBACjE,IAAI,CAAC,CAAC,YAAY,IAAI,UAAU,CAAC,EAAE;oBACjC,UAAU,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC;iBACnC;aACF;YAED,MAAM,oBAAoB,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,KAAK,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC3G,SAAS,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,GAAG,oBAAoB,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;YACxF,IAAI,IAAI,CAAC,QAAQ,CAAC,8BAA8B,EAAE;gBAChD,OAAO;aACR;SACF;QAED,IAAI,yBAAyB,GAAY,IAAI,CAAC;QAC9C,IAAI,yBAAyB,GAAY,IAAI,CAAC;QAC9C,IAAI,IAAI,CAAC,QAAQ,CAAC,4BAA4B,EAAE;YAC9C,yDAAyD;YACzD,IAAI,UAAU,IAAI,UAAU,IAAI,KAAK,IAAI,UAAU,EAAE;gBACnD,yBAAyB,GAAG,KAAK,CAAC;gBAClC,IAAI,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACnC,OAAO,UAAU,CAAC,GAAG,CAAC;iBACvB;aACF;YACD,IAAI,UAAU,IAAI,UAAU,IAAI,KAAK,IAAI,UAAU,EAAE;gBACnD,yBAAyB,GAAG,KAAK,CAAC;gBAClC,IAAI,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACnC,OAAO,UAAU,CAAC,GAAG,CAAC;iBACvB;aACF;SACF;QAED,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE;YAClC,yBAAyB;YACzB,IAAI,SAAS,CAAC,mBAAmB,EAAE;gBACjC,MAAM,UAAU,GAAiB;oBAC/B,UAAU;oBACV,QAAQ,EAAE,EAAE;oBACZ,IAAI;oBACJ,UAAU,EAAE,KAAK;oBACjB,WAAW,EAAE,KAAK;oBAClB,IAAI,EAAE,EAAE;iBACT,CAAC;gBACF,SAAS,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACxD,SAAS,CAAC,mBAAmB,GAAG,UAAU,CAAC;gBAC3C,OAAO;aACR;YAED,gDAAgD;YAChD,IAAI,UAAU,CAAC,MAAM,KAAK,cAAc,EAAE;gBACxC,SAAS,CAAC,mBAAmB,GAAG;oBAC9B,UAAU;oBACV,QAAQ,EAAE,EAAE;oBACZ,IAAI;oBACJ,SAAS;oBACT,UAAU,EAAE,KAAK;oBACjB,WAAW,EAAE,IAAI;oBACjB,IAAI,EAAE,EAAE;iBACT,CAAC;gBACF,OAAO;aACR;YAED,oCAAoC;YACpC,IAAI,UAAU,CAAC,QAAQ,KAAK,WAAW,EAAE;gBACvC,MAAM,mBAAmB,GAAW,UAAU,CAAC,QAAQ,IAAI,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,GAAG,CAAC;gBAC7F,IAAI,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,EAAE;oBAC1C,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,EAAE,mBAAmB,CAAC,CAAC;iBAC9F;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,mBAAmB,CAAC,EAAE;wBACvD,IAAI,CAAC,wBAAwB,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC;qBACzD;oBACD,IAAI,CAAC,wBAAwB,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBACpE;gBACD,OAAO;aACR;SACF;QAED,yDAAyD;QACzD,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,IAAI,KAAK,MAAM,IAAI,UAAU,CAAC,IAAI,EAAE;YAC/D,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SAC3D;QACD,2EAA2E;QAC3E,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;YACnD,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;SACvE;QAED,sCAAsC;QACtC,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,IAAI,KAAK,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE;YACpE,SAAS,CAAC,qBAAqB,GAAG,IAAI,CAAC;SACxC;QAED,sEAAsE;QACtE,uBAAuB;QACvB,IAAI,UAAmD,CAAC;QACxD,IAAI,qBAA8D,CAAC;QACnE,IAAI,aAAsD,CAAC;QAE3D,qDAAqD;QACrD,mCAAmC;QACnC,IAAI,OAAO,IAAI,UAAU,EAAE;YACzB,IAAI,UAAU,CAAC,KAAK,EAAE;gBACpB,SAAS,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;gBACnC,IAAI,CAAC,UAAU,CACb,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EACnC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC,EAC7D,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CACjD,CAAC;aACH;iBAAM;gBACL,kGAAkG;gBAClG,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aAChD;SACF;aAAM;YACL,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;SACnC;QAED,qBAAqB;QACrB,SAAS,CAAC,cAAc,GAAG,WAAI,CAAC,aAAa,CAAC,UAAU,EAAE,SAAS,CAAC,cAAc,EAChF,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,CAAC;QACrC,SAAS,CAAC,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,MAAM,GAAG,CAAC;YACtE,CAAC,iCAAM,SAAS,CAAC,WAAW,GAAK,SAAS,CAAC,cAAc,EAAG,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC;QAEtF,wBAAwB;QACxB,IAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,IAAI,UAAU,CAAC,IAAI,EAAE;YAClD,MAAM,WAAW,GAAG,UAAU,CAAC,EAAE;gBAC/B,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,UAAU,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;gBAC1E,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAChC,6BAA6B;YAC7B,MAAM,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC;YACjC,SAAS,CAAC,KAAK,GAAG,qCAAqC,CAAC;YACxD,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE;gBACrF,IAAI,CAAC,UAAU,CACb,WAAW,EACX,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,yCAAyC,CAAC,EAC1E,IAAI,CACL,CAAC;aACH;YACD,SAAS,CAAC,KAAK,GAAG,QAAQ,CAAC;SAC5B;QAED,qBAAqB;QACrB,8CAA8C;QAC9C,IAAI,UAAU,IAAI,UAAU,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,IAAI,MAAM,IAAI,UAAU,CAAC,EAAE;YACrF,SAAS,CAAC,QAAQ,GAAG,UAAU,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC;SAChE;aAAM;YACL,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC;SACzC;QAED,MAAM,SAAS,GAAY,IAAI,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,CAAC;QAC5D,IAAI,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,EAAE;YACpD,gEAAgE;YAChE,IAAI,UAAU,IAAI,UAAU,IAAI,CAAC,CAAC,SAAS,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,EAAE;gBACzF,yDAAyD;gBACzD,wBAAwB;gBACxB,IAAI,OAAO,IAAI,UAAU,EAAE;oBACzB,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;oBACjF,SAAS,CAAC,kBAAkB,GAAG,CAAC,CAAC,UAAU,CAAC;iBAC7C;qBAAM,IAAI,SAAS,EAAE;oBACpB,UAAU,GAAG,IAAI,CAAC;iBACnB;qBAAM,IAAI,SAAS,CAAC,MAAM,EAAE;oBAC3B,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC;iBAC/B;gBAED,iBAAiB;gBACjB,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,IAAI,OAAO,IAAI,UAAU,EAAE;wBACzB,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBACrF;oBACD,IAAI,CAAC,aAAa,IAAI,SAAS,EAAE;wBAC/B,aAAa,GAAG,IAAI,CAAC;qBACtB;oBACD,IAAI,CAAC,aAAa,IAAI,UAAU,IAAI,UAAU,EAAE;wBAC9C,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBACxF;oBACD,IAAI,CAAC,aAAa,IAAI,CAAC,MAAM,IAAI,UAAU,IAAI,KAAK,IAAI,UAAU,CAAC,EAAE;wBACnE,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBACvG;oBACD,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE;wBAC3D,aAAa,GAAG,UAAU,CAAC;qBAC5B;oBACD,IAAI,CAAC,aAAa,EAAE;wBAClB,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;qBAC7C;oBAED,qBAAqB,GAAG,aAAa,CAAC;iBACvC;aACF;iBAAM;gBACL,MAAM;gBACN,IAAI,OAAO,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,EAAE;oBACrD,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,IAAI,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;oBACxG,SAAS,CAAC,kBAAkB,GAAG,CAAC,CAAC,UAAU,CAAC;iBAC7C;gBACD,IAAI,CAAC,UAAU,IAAI,CAAC,MAAM,IAAI,UAAU,IAAI,KAAK,IAAI,UAAU,CAAC,EAAE;oBAChE,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,GAAG,EAChE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;oBACjC,SAAS,CAAC,kBAAkB,GAAG,CAAC,CAAC,UAAU,CAAC;iBAC7C;gBACD,IAAI,CAAC,UAAU,EAAE;oBACf,IAAI,SAAS,EAAE;wBACb,UAAU,GAAG,IAAI,CAAC;qBACnB;yBAAM,IAAI,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE;wBAChD,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC;qBAC/B;yBAAM,IAAI,QAAQ,IAAI,UAAU,EAAE;wBACjC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;wBACzC,SAAS,CAAC,kBAAkB,GAAG,IAAI,CAAC;qBACrC;yBAAM,IAAI,SAAS,CAAC,MAAM,EAAE;wBAC3B,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC;wBAC9B,IAAI,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,EAAE;4BAC/B,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;yBAC9B;qBACF;iBACF;gBAED,iBAAiB;gBACjB,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,aAAa,GAAG,UAAU,CAAC;iBAC5B;aACF;SACF;aAAM,EAAE,+BAA+B;YACtC,2DAA2D;YAE3D,qBAAqB;YACrB,IAAI,OAAO,IAAI,UAAU,EAAE;gBACzB,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;gBACjF,SAAS,CAAC,kBAAkB,GAAG,CAAC,CAAC,UAAU,CAAC;gBAC5C,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,aAAa,GAAG,UAAU,CAAC;iBAC5B;aACF;iBAAM,IAAI,SAAS,EAAE;gBACpB,UAAU,GAAG,IAAI,CAAC;aACnB;iBAAM,IAAI,SAAS,CAAC,MAAM,EAAE;gBAC3B,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC;aAC/B;YAED,gBAAgB;YAChB,IAAI,UAAU,IAAI,UAAU,EAAE;gBAC5B,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;aAChG;YACD,IAAI,CAAC,qBAAqB,EAAE;gBAC1B,IAAI,MAAM,IAAI,UAAU,IAAI,KAAK,IAAI,UAAU,EAAE;oBAC/C,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;iBAC/G;qBAAM,IAAI,QAAQ,IAAI,UAAU,IAAI,CAAC,CAAC,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE;oBACvG,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;iBACrD;aACF;YAED,qBAAqB;YACrB,IAAI,QAAQ,IAAI,UAAU,IAAI,CAAC,CAAC,OAAO,IAAI,UAAU,CAAC,EAAE;gBACtD,IAAI,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE;oBACzC,aAAa,GAAG,UAAU,CAAC;iBAC5B;qBAAM;oBACL,aAAa,GAAG,qBAAqB,CAAC;iBACvC;aACF;SACF;QAED,0DAA0D;QAC1D,IAAI,aAAa,EAAE;YACjB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE;gBACtF,IAAI,CAAC,UAAU,CACb,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,SAAS,CAAC,EACxD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,MAAM,CAAC,EAClD,IAAI,CACL,CAAC;aACH;SACF;QAED,iDAAiD;QACjD,IAAI,UAAU,EAAE;YACd,SAAS,CAAC,WAAW,GAAG,EAAE,CAAC;SAC5B;QAED,mDAAmD;QACnD,IAAI,qBAAqB,EAAE;YACzB,sBAAsB;YACtB,IAAI,KAAK,IAAI,UAAU,IAAI,QAAQ,IAAI,UAAU,EAAE;gBACjD,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;oBACR,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,qBAAqB,CAAC,CAAC;iBAC9E;aACF;YAED,4EAA4E;YAC5E,IAAI,CAAC,CAAC,KAAK,IAAI,UAAU,IAAI,QAAQ,IAAI,UAAU,CAAC,EAAE;gBACpD,IAAI,KAAK,IAAI,UAAU,EAAE;oBACvB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;wBACR,IAAI,CAAC,UAAU,CACb,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,EACrD,SAAS,EACT,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,SAAS,CAAC,CACjE,CAAC;qBACH;iBACF;gBACD,IAAI,KAAK,IAAI,UAAU,EAAE;oBACvB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;wBACR,IAAI,CAAC,UAAU,CACb,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,SAAS,CAAC,EAChE,SAAS,EACT,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,CACtD,CAAC;qBACH;iBACF;aACF;SACF;QAED,qFAAqF;QACrF,IAAI,CAAC,qBAAqB,EAAE;YAC1B,IAAI,KAAK,IAAI,UAAU,EAAE;gBACvB,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;wBACR,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;wBAC5D,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;qBAC7E;iBACF;qBAAM;oBACL,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;wBACR,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;qBACjE;iBACF;aACF;YACD,IAAI,KAAK,IAAI,UAAU,EAAE;gBACvB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,yBAAyB,EACpG,KAAK,CAAC,EAAE;oBACR,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;iBAChE;aACF;YAED,4FAA4F;YAC5F,IAAI,SAAS,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1C,qBAAqB,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;aACrD;SACF;QAED,uCAAuC;QACvC,IAAI,UAAU,IAAI,UAAU,EAAE;YAC5B,oBAAoB;YACpB,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAE9F,8CAA8C;YAC9C,IAAI,mBAAuC,CAAC;YAC5C,IAAI,UAAU,IAAI,UAAU,EAAE;gBAC5B,SAAS,CAAC,QAAQ,GAAmB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC5G,IAAI,SAAS,CAAC,QAAQ;uBACjB,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,KAAK,WAAI,CAAC,GAAG,GAAG,YAAY;2BACnD,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,IAAI,SAAS,CAAC,QAAQ,CAAC,KAAK,KAAK,WAAI,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,EAAE;oBACtF,SAAS,CAAC,gBAAgB,GAAG,IAAI,CAAC;iBACnC;aACF;iBAAM;gBACL,4BAA4B;gBAC5B,IAAI,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,SAAS,IAAI,UAAU,CAAC,EAAE;oBAClF,IAAI,UAAU,IAAI,UAAU,EAAE;wBAC5B,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBAC9F;oBACD,IAAI,CAAC,mBAAmB,IAAI,MAAM,IAAI,UAAU,EAAE;wBAChD,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC3F;oBACD,IAAI,CAAC,mBAAmB,IAAI,KAAK,IAAI,UAAU,EAAE;wBAC/C,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC1F;iBACF;gBACD,IAAI,QAAQ,IAAI,UAAU,IAAI,CAAC,CAAC,OAAO,IAAI,UAAU,CAAC,EAAE;oBACtD,mBAAmB,GAAG,aAAa,CAAC;iBACrC;aACF;YAED,IAAI,SAAS,IAAI,UAAU,EAAE;gBAC3B,2EAA2E;gBAC3E,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBACtE,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC/D;iBACF;qBAAM;oBACL,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;oBACtE,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC7C;iBACF;gBAED,gEAAgE;gBAChE,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;aAC7B;iBAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,iBAAiB,IAAI,UAAU,IAAI,UAAU,EAAE;gBACtE,SAAS,CAAC,qBAAqB,GAAG,IAAI,CAAC;gBACvC,kEAAkE;gBAClE,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACvE,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC/D;iBACF;qBAAM;oBACL,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;oBACtE,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC7C;iBACF;gBAED,gEAAgE;gBAChE,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;aAC7B;iBAAM,IAAI,mBAAmB,EAAE;gBAC9B,wCAAwC;gBACxC,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC;gBAC9E,IAAI,QAAQ,IAAI,UAAU,EAAE;oBAC1B,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC/D;iBACF;qBAAM;oBACL,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;oBACtE,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC7C;iBACF;gBAED,gEAAgE;gBAChE,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;aAC7B;SACF;QAED,kCAAkC;QAClC,IAAI,0BAA0B,GAAG,KAAK,CAAC;QACvC,IAAI,CAAC,SAAS,CAAC,WAAW,IAAI,UAAU,IAAI,SAAS,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;YAClF,0BAA0B,GAAG,IAAI,CAAC;YAClC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;YAC7E,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;YACrE,KAAK,MAAM,gBAAgB,IAAI,SAAS,CAAC,iBAAiB,EAAE;gBAC1D,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;oBAC7B,IAAI,gBAAgB,CAAC,IAAI,EAAE;wBACzB,kEAAkE;wBAClE,IAAI,cAAc,GAAG,IAAI,CAAC;wBAC1B,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;4BACxD,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;gCACjC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gCACxC,MAAM;6BACP;yBACF;wBACD,8CAA8C;wBAC9C,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,UAAU,EAAE,gBAAgB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;qBACrF;yBAAM;wBACL,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,gBAAgB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC9D;iBACF;qBAAM;oBACL,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,gBAAgB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;iBAC9D;aACF;SACF;QACD,IAAI,CAAC,0BAA0B,IAAI,SAAS,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;YACzE,SAAS,CAAC,iBAAiB,GAAG,SAAS,CAAC,iBAAiB,CAAC,MAAM,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;SAC/F;QAED,8CAA8C;QAC9C,SAAS,CAAC,OAAO,GAAG,UAAU,IAAI,SAAS,CAAC,OAAO,CAAC;QACpD,SAAS,CAAC,MAAM,GAAG,qBAAqB,IAAI,UAAU,CAAC;IACzD,CAAC;IAEM,MAAM,CAAC,IAAY;QACxB,MAAM,SAAS,GAAe,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAElF,wCAAwC;QACxC,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,IAAI,SAAS,CAAC,mBAAmB,EAAE;YACnE,SAAS,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC9C,OAAO;SACR;QAED,sCAAsC;QACtC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;YACnB,SAAS,CAAC,IAAI,GAAG,EAAE,CAAC;SACrB;QACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IAEM,UAAU;QACf,qBAAqB;QACrB,MAAM,SAAS,GAAe,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAClF,MAAM,SAAS,GAAe,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAElF,IAAI,CAAC,CAAC,SAAS,CAAC,gBAAgB,IAAI,SAAS,CAAC,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC,8BAA8B,CAAC,EAAE;YAE/G,sDAAsD;YACtD,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,IAAI,SAAS,CAAC,mBAAmB;mBAC9D,SAAS,CAAC,mBAAmB,CAAC,WAAW,EAAE;gBAC9C,MAAM,SAAS,GAAG,SAAS,CAAC,mBAAmB,CAAC,UAAU,CAAC,QAAQ,CAAC;gBAEpE,gFAAgF;gBAChF,OAAO,SAAS,CAAC,mBAAmB,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACzD,OAAO,SAAS,CAAC,mBAAmB,CAAC,UAAU,CAAC,MAAM,CAAC;gBAEvD,oBAAoB;gBACpB,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,mBAAmB,CAAC;gBAE7D,4CAA4C;gBAC5C,IAAI,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,EAAE;oBAC5C,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,EAAE;wBAC1D,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,SAAS,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC;qBACrE;oBACD,OAAO,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;iBACjD;gBAED,uCAAuC;gBACvC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;gBAE1B,OAAO;aACR;YAED,0DAA0D;YAC1D,IAAI,SAAS,CAAC,UAAU,EAAE;gBACxB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBAC7E,IAAI,YAAY,GAAa,SAAS,CAAC,IAAI,IAAI,EAAE,CAAC;gBAClD,IAAI,SAAS,CAAC,gBAAgB,IAAI,SAAS,CAAC,gBAAgB,EAAE;oBAC5D,2GAA2G;oBAC3G,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBACtC;gBACD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;gBACzE,IAAI,SAAS,CAAC,MAAM,EAAE;oBACpB,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC5D;iBACF;qBAAM;oBACL,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;wBAC5C,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;qBAC7C;iBACF;gBAED,wDAAwD;gBACxD,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE;oBACzB,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC;iBACvB;aACF;YAED,gCAAgC;YAChC,IAAI,SAAS,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrE,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;gBAC5E,KAAK,MAAM,cAAc,IAAI,SAAS,CAAC,WAAW,EAAE;oBAClD,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;oBAClE,MAAM,MAAM,GAAG,SAAS,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;oBAErD,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;wBACrB,oEAAoE;wBACpE,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;wBAC7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACtC,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;4BACpE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,OAAO,CAAC,EAC5E,MAAM,CAAC,CAAC;4BACV,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,MAAM,CAAC,EAC3E,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;yBAChG;wBAED,8CAA8C;wBAC9C,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;qBAChD;yBAAM;wBACL,gCAAgC;wBAChC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;qBACxF;iBACF;aACF;SAEF;QAED,uCAAuC;QACvC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;QAE1B,kCAAkC;QAClC,IAAI,SAAS,CAAC,gBAAgB,IAAI,SAAS,CAAC,IAAI,EAAE;YAChD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,IAAI,GAAG,CAAC,CAAC;SAC7C;QAED,qEAAqE;QACrE,IAAI,SAAS,CAAC,IAAI,IAAI,SAAS,EAAE;YAC/B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;gBACnB,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;aACjC;iBAAM;gBACL,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aACxD;SACF;IACH,CAAC;IAEM,KAAK;QACV,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE;YAClC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAEvC,iCAAiC;YACjC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,YAAY,EAAE;gBACzC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;gBAC7C,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;oBACvB,OAAO,CAAC,UAAU,CAAC,MAAM,GAAG,cAAc,CAAC;oBAC3C,OAAO,CAAC,UAAU,CAAC,QAAQ,GAAG,SAAS,CAAC;oBACxC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;oBAC5D,OAAO,CAAC,UAAU,GAAG,KAAK,CAAC;oBAC3B,OAAO,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC;oBACjC,OAAO,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC;iBACpC;aACF;YAED,mCAAmC;YACnC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,wBAAwB,EAAE;gBACrD,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,EAAE;oBAChE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBACpC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE,QAAQ,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC;oBACnE,IAAI,CAAC,UAAU,EAAE,CAAC;oBAClB,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;iBAC3B;aACF;YAED,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC;SACvC;IACH,CAAC;IAED;;;;;OAKG;IACO,0BAA0B,CAAC,IAAY;QAC/C,OAAO,IAAI,CAAC,QAAQ,CAAC,wBAAwB,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,CAAC,CAAC;IACxF,CAAC;IAED;;;;;;;OAOG;IACO,cAAc,CAAC,SAAqB,EAAE,OAAmC,EAAE,SAA6B,EACzF,qBAAgD;QACvE,IAAI,SAAS,CAAC,kBAAkB,EAAE;YAChC,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;YACtF,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,OAAO,CAAC,EACxE,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC,CAAC;YACpE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,MAAM,CAAC,EACvE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;SACtD;aAAM;YACL,IAAI,aAAa,GAAG,SAAS,CAAC,gBAAgB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YAChE,IAAI,CAAC,aAAa,EAAE;gBAClB,SAAS,CAAC,gBAAgB,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,aAAa,GAAG,EAAE,CAAC;aAClE;YACD,IAAI,qBAAqB,EAAE;gBACzB,aAAa,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;aAC3C;SACF;IACH,CAAC;IAED;;;;;OAKG;IACO,UAAU,CAAC,OAAyB,EAAE,SAA6B,EAAE,MAAuB;QACpG,gBAAgB;QAChB,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,WAAW,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;eACnE,CAAC,SAAS,CAAC,QAAQ,KAAK,WAAW,IAAI,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;eACxE,CAAC,MAAM,CAAC,QAAQ,KAAK,WAAW,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;YACvE,OAAO;SACR;QACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;IACvF,CAAC;IAED;;;;;OAKG;IACO,eAAe,CAAC,SAAqB,EAAE,OAAqB,EAAE,aAAqB;QAC3F,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACpC,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;QAE1B,sEAAsE;QACtE,0FAA0F;QAC1F,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE;YAClC,OAAO,CAAC,qBAAqB,GAAG,EAAE,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,GAAG,EAAE;gBAChC,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;gBAChD,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC1C,OAAO,KAAK,CAAC;YACf,CAAC,CAAC;SACH;aAAM;YACL,IAAI,cAAc,GAAG,CAAC,CAAC;YACvB,IAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC,CAAC;SACpF;QAED,sCAAsC;QACtC,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC;QAE3D,IAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;QAClC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;IAC5B,CAAC;IAED;;;;;;;;;OASG;IACO,uBAAuB,CAAC,OAAqB,EAAE,IAAa,EAAE,aAAqB;QAC3F,uCAAuC;QACvC,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC,UAAU,CAAC,QAAQ,KAAK,WAAW,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,KAAK,aAAa,EAAE;YACrG,OAAO;SACR;QAED,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;QACjD,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE;YAC/B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACnB;QACD,KAAK,MAAM,KAAK,IAAI,OAAO,CAAC,QAAQ,EAAE;YACpC,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC;SAC3D;QACD,IAAI,CAAC,UAAU,EAAE,CAAC;IACpB,CAAC;IAES,gBAAgB,CAAC,OAAgB;QACzC,OAAO,IAAI,oBAAU,CACA;YACjB,UAAU,EAAE,GAAG,EAAE;gBACf,IAAI;oBACF,IAAI,CAAC,UAAU,EAAE,CAAC;oBAClB,IAAI,IAAI,CAAC,iBAAiB,EAAE;wBAC1B,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,CAAC;qBACrC;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;iBACvB;YACH,CAAC;YACD,KAAK,EAAE,GAAG,EAAE;gBACV,IAAI;oBACF,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,IAAI,IAAI,CAAC,iBAAiB,EAAE;wBAC1B,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;qBAChC;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;iBACvB;YACH,CAAC;YACD,SAAS,EAAE,CAAC,IAAY,EAAE,UAAiC,EAAE,EAAE;gBAC7D,IAAI;oBACF,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;oBACjC,IAAI,IAAI,CAAC,iBAAiB,EAAE;wBAC1B,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;qBACpD;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;iBACvB;YACH,CAAC;YACD,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;gBACvB,IAAI;oBACF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAClB,IAAI,IAAI,CAAC,iBAAiB,EAAE;wBAC1B,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;qBACrC;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;iBACvB;YACH,CAAC;SACF,EACD;YACE,cAAc,EAAE,IAAI;YACpB,oBAAoB,EAAE,IAAI;YAC1B,OAAO;SACR,CAAC,CAAC;IACP,CAAC;CAEF;AA52BD,gCA42BC","sourcesContent":["import {DomHandler} from \"domhandler\";\nimport EventEmitter = NodeJS.EventEmitter;\nimport {Parser as HtmlParser} from \"htmlparser2\";\nimport * as RDF from \"@rdfjs/types\";\nimport {PassThrough, Transform} from \"readable-stream\";\nimport {IActiveTag} from \"./IActiveTag\";\nimport {IHtmlParseListener} from \"./IHtmlParseListener\";\nimport * as INITIAL_CONTEXT_XHTML from \"./initial-context-xhtml.json\";\nimport * as INITIAL_CONTEXT from \"./initial-context.json\";\nimport {IRdfaPattern} from \"./IRdfaPattern\";\nimport {IRdfaFeatures, RDFA_FEATURES, RdfaProfile} from \"./RdfaProfile\";\nimport {Util} from \"./Util\";\n\n/**\n * A stream transformer that parses RDFa (text) streams to an {@link RDF.Stream}.\n */\nexport class RdfaParser extends Transform implements RDF.Sink<EventEmitter, RDF.Stream> {\n\n  private readonly options: IRdfaParserOptions;\n  private readonly util: Util;\n  private readonly defaultGraph?: RDF.Quad_Graph;\n  private readonly parser: HtmlParser;\n  private readonly features: IRdfaFeatures;\n  private readonly htmlParseListener?: IHtmlParseListener;\n  private readonly rdfaPatterns: {[patternId: string]: IRdfaPattern};\n  private readonly pendingRdfaPatternCopies: {[copyTargetPatternId: string]: IActiveTag[]};\n\n  private readonly activeTagStack: IActiveTag[] = [];\n\n  constructor(options?: IRdfaParserOptions) {\n    super({ readableObjectMode: true });\n    options = options || {};\n    this.options = options;\n\n    this.util = new Util(options.dataFactory, options.baseIRI);\n    this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n    const profile = options.contentType ? Util.contentTypeToProfile(options.contentType) : options.profile || '';\n    this.features = options.features || RDFA_FEATURES[profile];\n    this.htmlParseListener = options.htmlParseListener;\n    this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null;\n    this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null;\n\n    this.parser = this.initializeParser(profile === 'xml');\n\n    this.activeTagStack.push({\n      incompleteTriples: [],\n      inlist: false,\n      language: options.language,\n      listMapping: {},\n      listMappingLocal: {},\n      name: '',\n      prefixesAll: {\n        ...INITIAL_CONTEXT['@context'],\n        ...this.features.xhtmlInitialContext ? INITIAL_CONTEXT_XHTML['@context'] : {},\n      },\n      prefixesCustom : {},\n      skipElement: false,\n      vocab: options.vocab,\n    });\n  }\n\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n  public import(stream: EventEmitter): RDF.Stream {\n    const output = new PassThrough({ readableObjectMode: true });\n    stream.on('error', (error) => parsed.emit('error', error));\n    stream.on('data', (data) => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new RdfaParser(this.options));\n    return parsed;\n  }\n\n  public _transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    this.parser.write(chunk.toString());\n    callback();\n  }\n\n  public _flush(callback: (error?: Error | null, data?: any) => void): void {\n    this.parser.end();\n    callback();\n  }\n\n  public onTagOpen(name: string, attributes: {[s: string]: string}) {\n    // Determine the parent tag (ignore skipped tags)\n    let parentTagI: number = this.activeTagStack.length - 1;\n    while (parentTagI > 0 && this.activeTagStack[parentTagI].skipElement) {\n      parentTagI--;\n    }\n    let parentTag: IActiveTag = this.activeTagStack[parentTagI];\n    // If we skipped a tag, make sure we DO use the lang, prefixes and vocab of the skipped tag\n    if (parentTagI !== this.activeTagStack.length - 1) {\n      parentTag = {\n        ...parentTag,\n        language: this.activeTagStack[this.activeTagStack.length - 1].language,\n        prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,\n        prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,\n        vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab,\n      };\n    }\n\n    // Create a new active tag and inherit language scope and baseIRI from parent\n    const activeTag: IActiveTag = {\n      collectChildTags: parentTag.collectChildTags,\n      incompleteTriples: [],\n      inlist: 'inlist' in attributes,\n      listMapping: <{[predicate: string]: (RDF.Term|boolean)[]}> <any> [],\n      listMappingLocal: parentTag.listMapping,\n      localBaseIRI: parentTag.localBaseIRI,\n      name,\n      prefixesAll: null,\n      prefixesCustom: null,\n      skipElement: false,\n    };\n    this.activeTagStack.push(activeTag);\n\n    // Save the tag contents if needed\n    if (activeTag.collectChildTags) {\n      // Add explicitly defined xmlns, xmlns:* and prefixes to attributes, as required by the spec (Step 11, note)\n      // Sort prefixes alphabetically for deterministic namespace declaration order\n      for (const prefix of Object.keys(parentTag.prefixesCustom).sort()) {\n        const suffix = parentTag.prefixesCustom[prefix];\n        const attributeKey = prefix === '' ? 'xmlns' : 'xmlns:' + prefix;\n        if (!(attributeKey in attributes)) {\n          attributes[attributeKey] = suffix;\n        }\n      }\n\n      const attributesSerialized = Object.keys(attributes).map((key) => `${key}=\"${attributes[key]}\"`).join(' ');\n      activeTag.text = [`<${name}${attributesSerialized ? ' ' + attributesSerialized : ''}>`];\n      if (this.features.skipHandlingXmlLiteralChildren) {\n        return;\n      }\n    }\n\n    let allowTermsInRelPredicates: boolean = true;\n    let allowTermsInRevPredicates: boolean = true;\n    if (this.features.onlyAllowUriRelRevIfProperty) {\n      // Ignore illegal rel/rev values when property is present\n      if ('property' in attributes && 'rel' in attributes) {\n        allowTermsInRelPredicates = false;\n        if (attributes.rel.indexOf(':') < 0) {\n          delete attributes.rel;\n        }\n      }\n      if ('property' in attributes && 'rev' in attributes) {\n        allowTermsInRevPredicates = false;\n        if (attributes.rev.indexOf(':') < 0) {\n          delete attributes.rev;\n        }\n      }\n    }\n\n    if (this.features.copyRdfaPatterns) {\n      // Save the tag if needed\n      if (parentTag.collectedPatternTag) {\n        const patternTag: IRdfaPattern = {\n          attributes,\n          children: [],\n          name,\n          referenced: false,\n          rootPattern: false,\n          text: [],\n        };\n        parentTag.collectedPatternTag.children.push(patternTag);\n        activeTag.collectedPatternTag = patternTag;\n        return;\n      }\n\n      // Store tags with type rdfa:Pattern as patterns\n      if (attributes.typeof === 'rdfa:Pattern') {\n        activeTag.collectedPatternTag = {\n          attributes,\n          children: [],\n          name,\n          parentTag,\n          referenced: false,\n          rootPattern: true,\n          text: [],\n        };\n        return;\n      }\n\n      // Instantiate patterns on rdfa:copy\n      if (attributes.property === 'rdfa:copy') {\n        const copyTargetPatternId: string = attributes.resource || attributes.href || attributes.src;\n        if (this.rdfaPatterns[copyTargetPatternId]) {\n          this.emitPatternCopy(parentTag, this.rdfaPatterns[copyTargetPatternId], copyTargetPatternId);\n        } else {\n          if (!this.pendingRdfaPatternCopies[copyTargetPatternId]) {\n            this.pendingRdfaPatternCopies[copyTargetPatternId] = [];\n          }\n          this.pendingRdfaPatternCopies[copyTargetPatternId].push(parentTag);\n        }\n        return;\n      }\n    }\n\n    // <base> tags override the baseIRI of the whole document\n    if (this.features.baseTag && name === 'base' && attributes.href) {\n      this.util.baseIRI = this.util.getBaseIRI(attributes.href);\n    }\n    // xml:base attributes override the baseIRI of the current tag and children\n    if (this.features.xmlBase && attributes['xml:base']) {\n      activeTag.localBaseIRI = this.util.getBaseIRI(attributes['xml:base']);\n    }\n\n    // <time> tags set an initial datatype\n    if (this.features.timeTag && name === 'time' && !attributes.datatype) {\n      activeTag.interpretObjectAsTime = true;\n    }\n\n    // Processing based on https://www.w3.org/TR/rdfa-core/#s_rdfaindetail\n    // 1: initialize values\n    let newSubject: RDF.NamedNode | RDF.BlankNode | boolean;\n    let currentObjectResource: RDF.NamedNode | RDF.BlankNode | boolean;\n    let typedResource: RDF.NamedNode | RDF.BlankNode | boolean;\n\n    // 2: handle vocab attribute to set active vocabulary\n    // Vocab sets the active vocabulary\n    if ('vocab' in attributes) {\n      if (attributes.vocab) {\n        activeTag.vocab = attributes.vocab;\n        this.emitTriple(\n          this.util.getBaseIriTerm(activeTag),\n          this.util.dataFactory.namedNode(Util.RDFA + 'usesVocabulary'),\n          this.util.dataFactory.namedNode(activeTag.vocab),\n        );\n      } else {\n        // If vocab is set to '', then we fallback to the root vocab as defined via the parser constructor\n        activeTag.vocab = this.activeTagStack[0].vocab;\n      }\n    } else {\n      activeTag.vocab = parentTag.vocab;\n    }\n\n    // 3: handle prefixes\n    activeTag.prefixesCustom = Util.parsePrefixes(attributes, parentTag.prefixesCustom,\n      this.features.xmlnsPrefixMappings);\n    activeTag.prefixesAll = Object.keys(activeTag.prefixesCustom).length > 0\n      ? { ...parentTag.prefixesAll, ...activeTag.prefixesCustom } : parentTag.prefixesAll;\n\n    // Handle role attribute\n    if (this.features.roleAttribute && attributes.role) {\n      const roleSubject = attributes.id\n        ? this.util.createIri('#' + attributes.id, activeTag, false, false, false)\n        : this.util.createBlankNode();\n      // Temporarily override vocab\n      const vocabOld = activeTag.vocab;\n      activeTag.vocab = 'http://www.w3.org/1999/xhtml/vocab#';\n      for (const role of this.util.createVocabIris(attributes.role, activeTag, true, false)) {\n        this.emitTriple(\n          roleSubject,\n          this.util.dataFactory.namedNode('http://www.w3.org/1999/xhtml/vocab#role'),\n          role,\n        );\n      }\n      activeTag.vocab = vocabOld;\n    }\n\n    // 4: handle language\n    // Save language attribute value in active tag\n    if ('xml:lang' in attributes || (this.features.langAttribute && 'lang' in attributes)) {\n      activeTag.language = attributes['xml:lang'] || attributes.lang;\n    } else {\n      activeTag.language = parentTag.language;\n    }\n\n    const isRootTag: boolean = this.activeTagStack.length === 2;\n    if (!('rel' in attributes) && !('rev' in attributes)) {\n      // 5: Determine the new subject when rel and rev are not present\n      if ('property' in attributes && !('content' in attributes) && !('datatype' in attributes)) {\n        // 5.1: property is present, but not content and datatype\n        // Determine new subject\n        if ('about' in attributes) {\n          newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        } else if (isRootTag) {\n          newSubject = true;\n        } else if (parentTag.object) {\n          newSubject = parentTag.object;\n        }\n\n        // Determine type\n        if ('typeof' in attributes) {\n          if ('about' in attributes) {\n            typedResource = this.util.createIri(attributes.about, activeTag, false, true, true);\n          }\n          if (!typedResource && isRootTag) {\n            typedResource = true;\n          }\n          if (!typedResource && 'resource' in attributes) {\n            typedResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n          }\n          if (!typedResource && ('href' in attributes || 'src' in attributes)) {\n            typedResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n          }\n          if (!typedResource && this.isInheritSubjectInHeadBody(name)) {\n            typedResource = newSubject;\n          }\n          if (!typedResource) {\n            typedResource = this.util.createBlankNode();\n          }\n\n          currentObjectResource = typedResource;\n        }\n      } else {\n        // 5.2\n        if ('about' in attributes || 'resource' in attributes) {\n          newSubject = this.util.createIri(attributes.about || attributes.resource, activeTag, false, true, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        }\n        if (!newSubject && ('href' in attributes || 'src' in attributes)) {\n          newSubject = this.util.createIri(attributes.href || attributes.src,\n            activeTag, false, false, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        }\n        if (!newSubject) {\n          if (isRootTag) {\n            newSubject = true;\n          } else if (this.isInheritSubjectInHeadBody(name)) {\n            newSubject = parentTag.object;\n          } else if ('typeof' in attributes) {\n            newSubject = this.util.createBlankNode();\n            activeTag.explicitNewSubject = true;\n          } else if (parentTag.object) {\n            newSubject = parentTag.object;\n            if (!('property' in attributes)) {\n              activeTag.skipElement = true;\n            }\n          }\n        }\n\n        // Determine type\n        if ('typeof' in attributes) {\n          typedResource = newSubject;\n        }\n      }\n    } else { // either rel or rev is present\n      // 6: Determine the new subject when rel or rev are present\n\n      // Define new subject\n      if ('about' in attributes) {\n        newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n        activeTag.explicitNewSubject = !!newSubject;\n        if ('typeof' in attributes) {\n          typedResource = newSubject;\n        }\n      } else if (isRootTag) {\n        newSubject = true;\n      } else if (parentTag.object) {\n        newSubject = parentTag.object;\n      }\n\n      // Define object\n      if ('resource' in attributes) {\n        currentObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n      }\n      if (!currentObjectResource) {\n        if ('href' in attributes || 'src' in attributes) {\n          currentObjectResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n        } else if ('typeof' in attributes && !('about' in attributes) && !this.isInheritSubjectInHeadBody(name)) {\n          currentObjectResource = this.util.createBlankNode();\n        }\n      }\n\n      // Set typed resource\n      if ('typeof' in attributes && !('about' in attributes)) {\n        if (this.isInheritSubjectInHeadBody(name)) {\n          typedResource = newSubject;\n        } else {\n          typedResource = currentObjectResource;\n        }\n      }\n    }\n\n    // 7: If a typed resource was defined, emit it as a triple\n    if (typedResource) {\n      for (const type of this.util.createVocabIris(attributes.typeof, activeTag, true, true)) {\n        this.emitTriple(\n          this.util.getResourceOrBaseIri(typedResource, activeTag),\n          this.util.dataFactory.namedNode(Util.RDF + 'type'),\n          type,\n        );\n      }\n    }\n\n    // 8: Reset list mapping if we have a new subject\n    if (newSubject) {\n      activeTag.listMapping = {};\n    }\n\n    // 9: If an object was defined, emit triples for it\n    if (currentObjectResource) {\n      // Handle list mapping\n      if ('rel' in attributes && 'inlist' in attributes) {\n        for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates,\n          false)) {\n          this.addListMapping(activeTag, newSubject, predicate, currentObjectResource);\n        }\n      }\n\n      // Determine predicates using rel or rev (unless rel and inlist are present)\n      if (!('rel' in attributes && 'inlist' in attributes)) {\n        if ('rel' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates,\n            false)) {\n            this.emitTriple(\n              this.util.getResourceOrBaseIri(newSubject, activeTag),\n              predicate,\n              this.util.getResourceOrBaseIri(currentObjectResource, activeTag),\n            );\n          }\n        }\n        if ('rev' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates,\n            false)) {\n            this.emitTriple(\n              this.util.getResourceOrBaseIri(currentObjectResource, activeTag),\n              predicate,\n              this.util.getResourceOrBaseIri(newSubject, activeTag),\n            );\n          }\n        }\n      }\n    }\n\n    // 10: Store incomplete triples if we don't have an object, but we do have predicates\n    if (!currentObjectResource) {\n      if ('rel' in attributes) {\n        if ('inlist' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates,\n            false)) {\n            this.addListMapping(activeTag, newSubject, predicate, null);\n            activeTag.incompleteTriples.push({ predicate, reverse: false, list: true });\n          }\n        } else {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates,\n            false)) {\n            activeTag.incompleteTriples.push({ predicate, reverse: false });\n          }\n        }\n      }\n      if ('rev' in attributes) {\n        for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates,\n          false)) {\n          activeTag.incompleteTriples.push({ predicate, reverse: true });\n        }\n      }\n\n      // Set a blank node object, so the children can make use of this when completing the triples\n      if (activeTag.incompleteTriples.length > 0) {\n        currentObjectResource = this.util.createBlankNode();\n      }\n    }\n\n    // 11: Determine current property value\n    if ('property' in attributes) {\n      // Create predicates\n      activeTag.predicates = this.util.createVocabIris(attributes.property, activeTag, true, false);\n\n      // Save datatype attribute value in active tag\n      let localObjectResource: RDF.Term | boolean;\n      if ('datatype' in attributes) {\n        activeTag.datatype = <RDF.NamedNode> this.util.createIri(attributes.datatype, activeTag, true, true, false);\n        if (activeTag.datatype\n          && (activeTag.datatype.value === Util.RDF + 'XMLLiteral'\n            || (this.features.htmlDatatype && activeTag.datatype.value === Util.RDF + 'HTML'))) {\n          activeTag.collectChildTags = true;\n        }\n      } else {\n        // Try to determine resource\n        if (!('rev' in attributes) && !('rel' in attributes) && !('content' in attributes)) {\n          if ('resource' in attributes) {\n            localObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n          }\n          if (!localObjectResource && 'href' in attributes) {\n            localObjectResource = this.util.createIri(attributes.href, activeTag, false, false, true);\n          }\n          if (!localObjectResource && 'src' in attributes) {\n            localObjectResource = this.util.createIri(attributes.src, activeTag, false, false, true);\n          }\n        }\n        if ('typeof' in attributes && !('about' in attributes)) {\n          localObjectResource = typedResource;\n        }\n      }\n\n      if ('content' in attributes) {\n        // Emit triples based on content attribute has preference over text content\n        const object = this.util.createLiteral(attributes.content, activeTag);\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        }\n\n        // Unset predicate to avoid text contents to produce new triples\n        activeTag.predicates = null;\n      } else if (this.features.datetimeAttribute && 'datetime' in attributes) {\n        activeTag.interpretObjectAsTime = true;\n        // Datetime attribute on time tag has preference over text content\n        const object = this.util.createLiteral(attributes.datetime, activeTag);\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        }\n\n        // Unset predicate to avoid text contents to produce new triples\n        activeTag.predicates = null;\n      } else if (localObjectResource) {\n        // Emit triples for all resource objects\n        const object = this.util.getResourceOrBaseIri(localObjectResource, activeTag);\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        }\n\n        // Unset predicate to avoid text contents to produce new triples\n        activeTag.predicates = null;\n      }\n    }\n\n    // 12: Complete incomplete triples\n    let incompleteTriplesCompleted = false;\n    if (!activeTag.skipElement && newSubject && parentTag.incompleteTriples.length > 0) {\n      incompleteTriplesCompleted = true;\n      const subject = this.util.getResourceOrBaseIri(parentTag.subject, activeTag);\n      const object = this.util.getResourceOrBaseIri(newSubject, activeTag);\n      for (const incompleteTriple of parentTag.incompleteTriples) {\n        if (!incompleteTriple.reverse) {\n          if (incompleteTriple.list) {\n            // Find the active tag that defined the list by going up the stack\n            let firstInListTag = null;\n            for (let i = this.activeTagStack.length - 1; i >= 0; i--) {\n              if (this.activeTagStack[i].inlist) {\n                firstInListTag = this.activeTagStack[i];\n                break;\n              }\n            }\n            // firstInListTag is guaranteed to be non-null\n            this.addListMapping(firstInListTag, newSubject, incompleteTriple.predicate, object);\n          } else {\n            this.emitTriple(subject, incompleteTriple.predicate, object);\n          }\n        } else {\n          this.emitTriple(object, incompleteTriple.predicate, subject);\n        }\n      }\n    }\n    if (!incompleteTriplesCompleted && parentTag.incompleteTriples.length > 0) {\n      activeTag.incompleteTriples = activeTag.incompleteTriples.concat(parentTag.incompleteTriples);\n    }\n\n    // 13: Save evaluation context into active tag\n    activeTag.subject = newSubject || parentTag.subject;\n    activeTag.object = currentObjectResource || newSubject;\n  }\n\n  public onText(data: string) {\n    const activeTag: IActiveTag = this.activeTagStack[this.activeTagStack.length - 1];\n\n    // Collect text in pattern tag if needed\n    if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag) {\n      activeTag.collectedPatternTag.text.push(data);\n      return;\n    }\n\n    // Save the text inside the active tag\n    if (!activeTag.text) {\n      activeTag.text = [];\n    }\n    activeTag.text.push(data);\n  }\n\n  public onTagClose() {\n    // Get the active tag\n    const activeTag: IActiveTag = this.activeTagStack[this.activeTagStack.length - 1];\n    const parentTag: IActiveTag = this.activeTagStack[this.activeTagStack.length - 2];\n\n    if (!(activeTag.collectChildTags && parentTag.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {\n\n      // If we detect a finalized rdfa:Pattern tag, store it\n      if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag\n        && activeTag.collectedPatternTag.rootPattern) {\n        const patternId = activeTag.collectedPatternTag.attributes.resource;\n\n        // Remove resource and typeof attributes to avoid it being seen as a new pattern\n        delete activeTag.collectedPatternTag.attributes.resource;\n        delete activeTag.collectedPatternTag.attributes.typeof;\n\n        // Store the pattern\n        this.rdfaPatterns[patternId] = activeTag.collectedPatternTag;\n\n        // Apply all pending copies for this pattern\n        if (this.pendingRdfaPatternCopies[patternId]) {\n          for (const tag of this.pendingRdfaPatternCopies[patternId]) {\n            this.emitPatternCopy(tag, activeTag.collectedPatternTag, patternId);\n          }\n          delete this.pendingRdfaPatternCopies[patternId];\n        }\n\n        // Remove the active tag from the stack\n        this.activeTagStack.pop();\n\n        return;\n      }\n\n      // Emit all triples that were determined in the active tag\n      if (activeTag.predicates) {\n        const subject = this.util.getResourceOrBaseIri(activeTag.subject, activeTag);\n        let textSegments: string[] = activeTag.text || [];\n        if (activeTag.collectChildTags && parentTag.collectChildTags) {\n          // If we are inside an XMLLiteral child that also has RDFa content, ignore the tag name that was collected.\n          textSegments = textSegments.slice(1);\n        }\n        const object = this.util.createLiteral(textSegments.join(''), activeTag);\n        if (activeTag.inlist) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, subject, predicate, object);\n          }\n        } else {\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        }\n\n        // Reset text, unless the parent is also collecting text\n        if (!parentTag.predicates) {\n          activeTag.text = null;\n        }\n      }\n\n      // 14: Handle local list mapping\n      if (activeTag.object && Object.keys(activeTag.listMapping).length > 0) {\n        const subject = this.util.getResourceOrBaseIri(activeTag.object, activeTag);\n        for (const predicateValue in activeTag.listMapping) {\n          const predicate = this.util.dataFactory.namedNode(predicateValue);\n          const values = activeTag.listMapping[predicateValue];\n\n          if (values.length > 0) {\n            // Non-empty list, emit linked list of rdf:first and rdf:rest chains\n            const bnodes = values.map(() => this.util.createBlankNode());\n            for (let i = 0; i < values.length; i++) {\n              const object = this.util.getResourceOrBaseIri(values[i], activeTag);\n              this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util.RDF + 'first'),\n                object);\n              this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util.RDF + 'rest'),\n                (i < values.length - 1) ? bnodes[i + 1] : this.util.dataFactory.namedNode(Util.RDF + 'nil'));\n            }\n\n            // Emit triple for the first linked list chain\n            this.emitTriple(subject, predicate, bnodes[0]);\n          } else {\n            // Empty list, just emit rdf:nil\n            this.emitTriple(subject, predicate, this.util.dataFactory.namedNode(Util.RDF + 'nil'));\n          }\n        }\n      }\n\n    }\n\n    // Remove the active tag from the stack\n    this.activeTagStack.pop();\n\n    // Save the tag contents if needed\n    if (activeTag.collectChildTags && activeTag.text) {\n      activeTag.text.push(`</${activeTag.name}>`);\n    }\n\n    // If we still have text contents, try to append it to the parent tag\n    if (activeTag.text && parentTag) {\n      if (!parentTag.text) {\n        parentTag.text = activeTag.text;\n      } else {\n        parentTag.text = parentTag.text.concat(activeTag.text);\n      }\n    }\n  }\n\n  public onEnd() {\n    if (this.features.copyRdfaPatterns) {\n      this.features.copyRdfaPatterns = false;\n\n      // Emit all unreferenced patterns\n      for (const patternId in this.rdfaPatterns) {\n        const pattern = this.rdfaPatterns[patternId];\n        if (!pattern.referenced) {\n          pattern.attributes.typeof = 'rdfa:Pattern';\n          pattern.attributes.resource = patternId;\n          this.emitPatternCopy(pattern.parentTag, pattern, patternId);\n          pattern.referenced = false;\n          delete pattern.attributes.typeof;\n          delete pattern.attributes.resource;\n        }\n      }\n\n      // Emit all unreferenced copy links\n      for (const patternId in this.pendingRdfaPatternCopies) {\n        for (const parentTag of this.pendingRdfaPatternCopies[patternId]) {\n          this.activeTagStack.push(parentTag);\n          this.onTagOpen('link', { property: 'rdfa:copy', href: patternId });\n          this.onTagClose();\n          this.activeTagStack.pop();\n        }\n      }\n\n      this.features.copyRdfaPatterns = true;\n    }\n  }\n\n  /**\n   * If the new subject can be inherited from the parent object\n   * if the resource defines no new subject.\n   * @param {string} name The current tag name.\n   * @returns {boolean} If the subject can be inherited.\n   */\n  protected isInheritSubjectInHeadBody(name: string) {\n    return this.features.inheritSubjectInHeadBody && (name === 'head' || name === 'body');\n  }\n\n  /**\n   * Add a list mapping for the given predicate and object in the active tag.\n   * @param {IActiveTag} activeTag The active tag.\n   * @param {Term | boolean} subject A subject term, this will only be used to create a separate list\n   *                                 if activeTag.explicitNewSubject is true.\n   * @param {Term} predicate A predicate term.\n   * @param {Term | boolean} currentObjectResource The current object resource.\n   */\n  protected addListMapping(activeTag: IActiveTag, subject: RDF.Quad_Subject | boolean, predicate: RDF.Quad_Predicate,\n                           currentObjectResource: RDF.Quad_Object | boolean) {\n    if (activeTag.explicitNewSubject) {\n      const bNode = this.util.createBlankNode();\n      this.emitTriple(this.util.getResourceOrBaseIri(subject, activeTag), predicate, bNode);\n      this.emitTriple(bNode, this.util.dataFactory.namedNode(Util.RDF + 'first'),\n        this.util.getResourceOrBaseIri(currentObjectResource, activeTag));\n      this.emitTriple(bNode, this.util.dataFactory.namedNode(Util.RDF + 'rest'),\n        this.util.dataFactory.namedNode(Util.RDF + 'nil'));\n    } else {\n      let predicateList = activeTag.listMappingLocal[predicate.value];\n      if (!predicateList) {\n        activeTag.listMappingLocal[predicate.value] = predicateList = [];\n      }\n      if (currentObjectResource) {\n        predicateList.push(currentObjectResource);\n      }\n    }\n  }\n\n  /**\n   * Emit the given triple to the stream.\n   * @param {Term} subject A subject term.\n   * @param {Term} predicate A predicate term.\n   * @param {Term} object An object term.\n   */\n  protected emitTriple(subject: RDF.Quad_Subject, predicate: RDF.Quad_Predicate, object: RDF.Quad_Object) {\n    // Validate IRIs\n    if ((subject.termType === 'NamedNode' && subject.value.indexOf(':') < 0)\n      || (predicate.termType === 'NamedNode' && predicate.value.indexOf(':') < 0)\n      || (object.termType === 'NamedNode' && object.value.indexOf(':') < 0)) {\n      return;\n    }\n    this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n  }\n\n  /**\n   * Emit an instantiation of the given pattern with the given parent tag.\n   * @param {IActiveTag} parentTag The parent tag to instantiate in.\n   * @param {IRdfaPattern} pattern The pattern to instantiate.\n   * @param {string} rootPatternId The pattern id.\n   */\n  protected emitPatternCopy(parentTag: IActiveTag, pattern: IRdfaPattern, rootPatternId: string) {\n    this.activeTagStack.push(parentTag);\n    pattern.referenced = true;\n\n    // Ensure that blank nodes within patterns are instantiated only once.\n    // All next pattern copies will reuse the instantiated blank nodes from the first pattern.\n    if (!pattern.constructedBlankNodes) {\n      pattern.constructedBlankNodes = [];\n      this.util.blankNodeFactory = () => {\n        const bNode = this.util.dataFactory.blankNode();\n        pattern.constructedBlankNodes.push(bNode);\n        return bNode;\n      };\n    } else {\n      let blankNodeIndex = 0;\n      this.util.blankNodeFactory = () => pattern.constructedBlankNodes[blankNodeIndex++];\n    }\n\n    // Apply everything within the pattern\n    this.emitPatternCopyAbsolute(pattern, true, rootPatternId);\n\n    this.util.blankNodeFactory = null;\n    this.activeTagStack.pop();\n  }\n\n  /**\n   * Emit an instantiation of the given pattern with the given parent tag.\n   *\n   * This should probably not be called directly,\n   * call {@link emitPatternCopy} instead.\n   *\n   * @param {IRdfaPattern} pattern The pattern to instantiate.\n   * @param {boolean} root If this is the root call for the given pattern.\n   * @param {string} rootPatternId The pattern id.\n   */\n  protected emitPatternCopyAbsolute(pattern: IRdfaPattern, root: boolean, rootPatternId: string) {\n    // Stop on detection of cyclic patterns\n    if (!root && pattern.attributes.property === 'rdfa:copy' && pattern.attributes.href === rootPatternId) {\n      return;\n    }\n\n    this.onTagOpen(pattern.name, pattern.attributes);\n    for (const text of pattern.text) {\n      this.onText(text);\n    }\n    for (const child of pattern.children) {\n      this.emitPatternCopyAbsolute(child, false, rootPatternId);\n    }\n    this.onTagClose();\n  }\n\n  protected initializeParser(xmlMode: boolean): HtmlParser {\n    return new HtmlParser(\n      <DomHandler> <any> {\n        onclosetag: () => {\n          try {\n            this.onTagClose();\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onTagClose();\n            }\n          } catch (e) {\n            this.emit('error', e);\n          }\n        },\n        onend: () => {\n          try {\n            this.onEnd();\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onEnd();\n            }\n          } catch (e) {\n            this.emit('error', e);\n          }\n        },\n        onopentag: (name: string, attributes: {[s: string]: string}) => {\n          try {\n            this.onTagOpen(name, attributes);\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onTagOpen(name, attributes);\n            }\n          } catch (e) {\n            this.emit('error', e);\n          }\n        },\n        ontext: (data: string) => {\n          try {\n            this.onText(data);\n            if (this.htmlParseListener) {\n              this.htmlParseListener.onText(data);\n            }\n          } catch (e) {\n            this.emit('error', e);\n          }\n        },\n      },\n      {\n        decodeEntities: true,\n        recognizeSelfClosing: true,\n        xmlMode,\n      });\n  }\n\n}\n\nexport interface IRdfaParserOptions {\n  /**\n   * A custom RDFJS DataFactory to construct terms and triples.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * An initital default base IRI.\n   */\n  baseIRI?: string;\n  /**\n   * A default language for string literals.\n   */\n  language?: string;\n  /**\n   * The initial vocabulary.\n   */\n  vocab?: string;\n  /**\n   * The default graph for constructing quads.\n   */\n  defaultGraph?: RDF.Quad_Graph;\n  /**\n   * A hash of features that should be enabled.\n   * Defaults to the features defined by the profile.\n   */\n  features?: IRdfaFeatures;\n  /**\n   * The RDFa profile to use.\n   * Defaults to a profile with all possible features enabled.\n   */\n  profile?: RdfaProfile;\n  /**\n   * The content type of the document that should be parsed.\n   * This can be used as an alternative to the 'profile' option.\n   */\n  contentType?: string;\n  /**\n   * An optional listener for the internal HTML parse events.\n   */\n  htmlParseListener?: IHtmlParseListener;\n}\n"]}