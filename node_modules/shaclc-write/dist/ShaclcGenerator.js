"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-unused-vars */
/* eslint-disable lines-between-class-members */
/* eslint-disable no-dupe-class-members */
/**
 * Generates a SHACLC file stream from a quad stream, since SHACLC is
 * lossy with respect to N3, a stream of quads that could not be
 * written is also output.
 */
const n3_1 = require("n3");
const prefixcc_1 = require("@jeswr/prefixcc");
const rdf_string_ttl_1 = require("rdf-string-ttl");
const utils_1 = require("./utils");
const property_param_1 = __importDefault(require("./property-param "));
const base_prefixes_1 = __importDefault(require("./base-prefixes"));
const node_param_1 = __importDefault(require("./node-param"));
function getNamespace(str) {
    var _a;
    return (_a = /^[^]*[#/]/.exec(str)) === null || _a === void 0 ? void 0 : _a[0];
}
const knownNamespaces = {
    'http://www.w3.org/1999/02/22-rdf-syntax-ns#': 'rdf',
    'http://www.w3.org/2000/01/rdf-schema#': 'rdfs',
    'http://www.w3.org/ns/shacl#': 'sh',
    'http://www.w3.org/2001/XMLSchema#': 'xsd',
};
const knownPrefixes = {
    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
    sh: 'http://www.w3.org/ns/shacl#',
    xsd: 'http://www.w3.org/2001/XMLSchema#',
};
class SHACLCWriter {
    constructor(
    // eslint-disable-next-line no-unused-vars
    store, 
    // eslint-disable-next-line no-unused-vars
    writer, prefixes = {}, 
    // eslint-disable-next-line no-unused-vars
    base = undefined, errorOnExtraQuads = true, mintUnspecifiedPrefixes = false, fetch, extendedSyntax = false) {
        this.store = store;
        this.base = base;
        this.errorOnExtraQuads = errorOnExtraQuads;
        this.mintUnspecifiedPrefixes = mintUnspecifiedPrefixes;
        this.fetch = fetch;
        this.extendedSyntax = extendedSyntax;
        this.prefixes = {};
        this.prefixRev = {};
        for (const key of Object.keys(prefixes)) {
            const iri = prefixes[key];
            const value = typeof iri === 'string' ? iri : iri.value;
            if (!(value in knownNamespaces) && !(key in knownPrefixes)) {
                this.prefixRev[value] = key;
                this.prefixes[key] = value;
            }
        }
        this.writer = writer;
    }
    /**
     * Used to initiate the flow of data through the writer.
     */
    // TODO: Make initialisation async
    write() {
        return __awaiter(this, void 0, void 0, function* () {
            const onotology = this.store.getQuads(null, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" /* rdf.type */, "http://www.w3.org/2002/07/owl#Ontology" /* owl.Ontology */, null);
            if (onotology.length === 1 && onotology[0].subject.termType === 'NamedNode') {
                const base = onotology[0].subject;
                this.store.removeQuads(onotology);
                // Don't write default
                if (!base.equals(new n3_1.NamedNode('urn:x-base:default')))
                    this.writer.add(`BASE ${(0, rdf_string_ttl_1.termToString)(base)}`);
                yield this.writeImports(base);
            }
            else {
                throw new Error('Base expected');
            }
            if (this.mintUnspecifiedPrefixes) {
                const namespaces = new Set();
                for (const term of [
                    ...this.store.getSubjects(null, null, null),
                    ...this.store.getPredicates(null, null, null),
                    ...this.store.getObjects(null, null, null),
                ]) {
                    if (term.termType === 'NamedNode') {
                        const namespace = getNamespace(term.value);
                        if (namespace && !(namespace in this.prefixRev) && !(namespace in knownNamespaces)) {
                            namespaces.add(namespace);
                        }
                    }
                }
                const existingPrefixes = Object.assign(Object.assign({}, this.prefixes), knownPrefixes);
                yield Promise.all([...namespaces].map((ns) => (0, prefixcc_1.uriToPrefix)(ns, {
                    fetch: this.fetch,
                    mintOnUnknown: true,
                    existingPrefixes,
                }).then((pref) => {
                    this.prefixes[pref] = ns;
                    existingPrefixes[pref] = ns;
                    this.prefixRev[ns] = pref;
                })));
            }
            const allNamespaces = new Set([
                ...this.store.getSubjects(null, null, null),
                ...this.store.getPredicates(null, null, null),
                ...this.store.getObjects(null, null, null),
            ]
                .filter((term) => term.termType === 'NamedNode')
                .map((term) => getNamespace(term.value))
                .filter((str) => typeof str === 'string'));
            for (const key in this.prefixRev) {
                if (!allNamespaces.has(key)) {
                    delete this.prefixes[this.prefixRev[key]];
                    delete this.prefixRev[key];
                }
            }
            yield this.writePrefixes();
            this.prefixes = Object.assign(Object.assign({}, this.prefixes), knownPrefixes);
            this.prefixRev = Object.assign(Object.assign({}, this.prefixRev), knownNamespaces);
            this.writer.newLine();
            yield this.writeShapes();
            if (this.extendedSyntax) {
                const subjects = this.store.getSubjects(null, null, null);
                if (subjects.length > 0) {
                    this.writer.newLine(1);
                }
                for (const subject of subjects) {
                    this.writer.add(yield this.termToString(subject, true, true));
                    this.writer.add(' ');
                    this.writer.indent();
                    yield this.writeTurtlePredicates(subject);
                    this.writer.deindent();
                }
                if (subjects.length > 0) {
                    this.writer.add(' .');
                    this.writer.newLine();
                }
            }
            if (this.errorOnExtraQuads && this.store.size > 0) {
                throw new Error(`Dataset contains quads that cannot be written in SHACLC [\n${new n3_1.Writer({ prefixes: this.prefixes }).quadsToString(this.store.getQuads(null, null, null, null))}]`);
            }
            this.writer.end();
            // this.failedQuads.append(this.store.getQuads(null, null, null, null))
        });
    }
    writeImports(base) {
        return __awaiter(this, void 0, void 0, function* () {
            const imports = this.store.getObjectsOnce(base, new n3_1.NamedNode("http://www.w3.org/2002/07/owl#imports" /* owl.imports */), null);
            if (imports.length > 0) {
                for (const imp of imports) {
                    this.writer.add(`IMPORTS <${imp.value}>`, true);
                }
            }
        });
    }
    writePrefixes() {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = Object.keys(this.prefixes).filter((key) => !(key in base_prefixes_1.default)).sort();
            if (keys.length > 0) {
                for (const key of keys) {
                    this.writer.add(`PREFIX ${key}: <${this.prefixes[key]}>`, true);
                }
            }
        });
    }
    termToString(term, disableShaclName = false, allowBlankNodes = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Make sure this does not introduce any errors
            try {
                if (disableShaclName) {
                    throw new Error('Shacl name disabled');
                }
                return (0, utils_1.getShaclName)(term);
                // eslint-disable-next-line no-empty
            }
            catch (e) { }
            if (term.termType === 'NamedNode') {
                const namespace = getNamespace(term.value);
                if (namespace && namespace in this.prefixRev) {
                    if (namespace in this.prefixRev) {
                        return `${this.prefixRev[namespace]}:${term.value.slice(namespace.length)}`;
                    }
                }
                return (0, rdf_string_ttl_1.termToString)(term);
            }
            if (term.termType === 'Literal') {
                if (term.datatypeString === 'http://www.w3.org/2001/XMLSchema#integer'
                    || term.datatypeString === 'http://www.w3.org/2001/XMLSchema#boolean') {
                    return term.value;
                }
                return (0, rdf_string_ttl_1.termToString)(term);
            }
            if (term.termType === 'BlankNode' && allowBlankNodes) {
                (0, rdf_string_ttl_1.termToString)(term);
            }
            throw new Error(`Invalid term type for extra statement ${term.value} (${term.termType})`);
        });
    }
    writeShapes() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Determine sorting
            /**
             * Get every nodeshape declared at the top level
             */
            for (const subject of this.store.getSubjectsOnce(new n3_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type" /* rdf.type */), new n3_1.NamedNode("http://www.w3.org/ns/shacl#NodeShape" /* sh.NodeShape */), null)) {
                if (this.store.getQuadsOnce(subject, new n3_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type" /* rdf.type */), new n3_1.NamedNode("http://www.w3.org/2000/01/rdf-schema#Class" /* rdfs.Class */), null).length > 0) {
                    this.writer.add('shapeClass ');
                }
                else {
                    this.writer.add('shape ');
                }
                this.writer.add(yield this.termToString(subject));
                this.writer.add(' ');
                const targetClasses = this.store.getObjectsOnce(subject, new n3_1.NamedNode("http://www.w3.org/ns/shacl#targetClass" /* sh.targetClass */), null);
                if (targetClasses.length > 0) {
                    this.writer.add('-> ');
                    for (const targetClass of targetClasses) {
                        if (targetClass.termType === 'NamedNode') {
                            this.writer.add(yield this.termToString(targetClass));
                        }
                        else {
                            this.writer.add('!');
                            this.writer.add(yield this.termToString(this.singleObject(targetClass, new n3_1.NamedNode("http://www.w3.org/ns/shacl#not" /* sh.not */), true)));
                        }
                        this.writer.add(' ');
                    }
                }
                const unusedPredicates = this.store.getPredicates(subject, null, null)
                    .filter((property) => [
                    new n3_1.NamedNode("http://www.w3.org/ns/shacl#targetClass" /* sh.targetClass */),
                    new n3_1.NamedNode("http://www.w3.org/ns/shacl#property" /* sh.property */),
                    // TODO: See if "and" should be here as well
                    new n3_1.NamedNode("http://www.w3.org/ns/shacl#or" /* sh.or */),
                    ...Object.keys(node_param_1.default).map((key) => new n3_1.NamedNode("http://www.w3.org/ns/shacl#" /* sh._ */ + key)),
                ].every((elem) => !property.equals(elem)));
                if (unusedPredicates.length > 0) {
                    this.writer.add(';');
                    this.writer.indent();
                    this.writer.newLine(1);
                }
                if (this.extendedSyntax) {
                    yield this.writeGivenTurtlePredicates(subject, unusedPredicates);
                }
                if (unusedPredicates.length > 0) {
                    this.writer.add(' ');
                    this.writer.deindent();
                }
                yield this.writeShapeBody(subject, false);
            }
        });
    }
    getSingleProperty(quad, allowedPredicates) {
        // let tempQuad = quad;
        let examining = [quad];
        try {
            let name = (0, utils_1.getShaclName)(quad.predicate);
            let type = 'pred';
            if (name === 'not') {
                const quads = this.store.getQuadsOnce(quad.object, null, null, null);
                // TODO: See if this line is necessary
                examining = examining.concat(quads);
                if (quads.length !== 1) {
                    throw new Error('Can only handle having one predicate of \'not\'');
                }
                // eslint-disable-next-line no-param-reassign
                [quad] = quads;
                name = (0, utils_1.getShaclName)(quad.predicate);
                type = 'not';
            }
            if (!(name in allowedPredicates)) {
                throw new Error(`${name} is not allowed`);
            }
            return { name, type, object: quad.object };
        }
        catch (e) {
            this.store.addQuads(examining);
        }
        return undefined;
    }
    singleLayerPropertiesList(term, allowedPredicates) {
        const result = [];
        for (const quad of this.store.getQuadsOnce(term, null, null, null)) {
            const property = this.getSingleProperty(quad, allowedPredicates);
            if (property) {
                result.push(property);
            }
        }
        return result;
    }
    expectOneProperty(term, allowedPredicates) {
        const quads = this.store.getQuadsOnce(term, null, null, null);
        if (quads.length === 1) {
            const data = this.getSingleProperty(quads[0], allowedPredicates);
            if (data) {
                return data;
            }
        }
        this.store.addQuads(quads);
        return undefined;
    }
    orProperties(term, allowedPredicates) {
        const orProperties = [];
        for (const quad of this.store.getQuadsOnce(term, new n3_1.NamedNode("http://www.w3.org/ns/shacl#or" /* sh.or */), null, null)) {
            const statement = [];
            for (const item of this.getList(quad.object)) {
                const property = this.expectOneProperty(item, allowedPredicates);
                if (!property) {
                    // TODO HANDLE THIS CASE BY EXTENDING SHACLC SYNTAX
                    this.store.addQuad(quad);
                    throw new Error('Each entry of the \'or\' statement must declare exactly one property');
                }
                statement.push(property);
            }
            orProperties.push(statement);
        }
        return orProperties;
    }
    /**
     * Extract an rdf:list
     */
    getList(term) {
        // TODO: Fix gross type casting
        let termTemp = term;
        const list = [];
        // TODO: Handle poorly formed RDF lists
        while (!termTemp.equals(new n3_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil" /* rdf.nil */))) {
            list.push(this.singleObject(termTemp, new n3_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first" /* rdf.first */), true));
            termTemp = this.singleObject(termTemp, new n3_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest" /* rdf.rest */), true);
        }
        return list;
    }
    writeIriLiteralOrArray(object) {
        return __awaiter(this, void 0, void 0, function* () {
            if (object.termType === 'BlankNode') {
                this.writer.add('[');
                let first = true;
                for (const term of this.getList(object)) {
                    if (first) {
                        first = false;
                    }
                    else {
                        this.writer.add(' ');
                    }
                    this.writer.add(yield this.termToString(term));
                }
                this.writer.add(']');
            }
            else {
                this.writer.add(yield this.termToString(object));
            }
        });
    }
    singleObject(subject, predicate, strict) {
        var _a;
        return (_a = this.singleQuad(subject, predicate, strict)) === null || _a === void 0 ? void 0 : _a.object;
    }
    singleQuad(subject, predicate, strict = false) {
        const objects = this.store.getQuadsOnce(subject, predicate, null, null);
        if (strict && objects.length !== 1) {
            this.store.addQuads(objects);
            throw new Error(`The subject and predicate ${subject === null || subject === void 0 ? void 0 : subject.value} ${predicate === null || predicate === void 0 ? void 0 : predicate.value} must have exactly one object. Instead has ${objects.length}`);
        }
        if (objects.length > 1) {
            this.store.addQuads(objects);
            throw new Error(`The subject and predicate ${subject === null || subject === void 0 ? void 0 : subject.value} ${predicate === null || predicate === void 0 ? void 0 : predicate.value} can have at most one object. Instead has ${objects.length}`);
        }
        return objects.length === 1 ? objects[0] : undefined;
    }
    writeAssigment({ name, type, object }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === 'not') {
                this.writer.add('!');
                // object = this.singleObject(object, DataFactory.namedNode(sh._ + name), true)
            }
            this.writer.add(name);
            this.writer.add('=');
            yield this.writeIriLiteralOrArray(object);
        });
    }
    writeAtom({ name, type, object }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === 'not') {
                this.writer.add('!');
            }
            switch (name) {
                case 'node': {
                    if (object.termType === 'NamedNode') {
                        this.writer.add(`@${yield this.termToString(object)}`);
                    }
                    else if (object.termType === 'BlankNode') {
                        yield this.writeShapeBody(object);
                    }
                    else {
                        throw new Error('Invalid nested shape, must be blank node or IRI');
                    }
                    return;
                }
                case 'nodeKind': {
                    this.writer.add((0, utils_1.getShaclName)(object));
                    return;
                }
                case 'class': {
                    this.writer.add(yield this.termToString(object));
                    return;
                }
                case 'datatype': {
                    this.writer.add(yield this.termToString(object));
                    return;
                }
                default:
                    this.writer.add(name);
                    this.writer.add('=');
                    yield this.writeIriLiteralOrArray(object);
            }
        });
    }
    writeAssigments(assignments, divider = ' ', first = true, shortcuts) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const assignment of assignments) {
                if (first) {
                    // eslint-disable-next-line no-param-reassign
                    first = false;
                }
                else {
                    this.writer.add(divider);
                }
                if (shortcuts) {
                    yield this.writeAtom(assignment);
                }
                else {
                    yield this.writeAssigment(assignment);
                }
            }
        });
    }
    writeParams(term, first = true, allowedParam, shortcuts = false, surroundings = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO Stream this part
            const or = this.orProperties(term, allowedParam);
            const params = this.singleLayerPropertiesList(term, allowedParam);
            if (surroundings && (or.length > 0 || params.length > 0)) {
                this.writer.newLine(1);
            }
            for (const statement of or) {
                if (first) {
                    // eslint-disable-next-line no-param-reassign
                    first = false;
                }
                else {
                    this.writer.add(' ');
                }
                yield this.writeAssigments(statement, '|', true, shortcuts);
            }
            yield this.writeAssigments(params, ' ', first, shortcuts);
            if (surroundings && (or.length > 0 || params.length > 0)) {
                this.writer.add(' .');
            }
        });
    }
    writeShapeBody(term, nested = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.writer.add('{').indent();
            const properties = this.store.getObjectsOnce(term, new n3_1.NamedNode("http://www.w3.org/ns/shacl#property" /* sh.property */), null);
            yield this.writeParams(term, true, node_param_1.default, false, true);
            for (const property of properties) {
                this.writer.newLine(1);
                yield this.writeProperty(property);
            }
            this.writer.deindent().newLine(1);
            if (nested) {
                this.writer.add('} .');
            }
            else {
                this.writer.add('}').newLine(1);
            }
        });
    }
    writeProperty(property) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.writePath(this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#path" /* sh.path */), true));
            const min = this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#minCount" /* sh.minCount */));
            const max = this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#maxCount" /* sh.maxCount */));
            const nodeKind = this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#nodeKind" /* sh.nodeKind */));
            // eslint-disable-next-line no-underscore-dangle
            const propertyClass = this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#class" /* sh._class */));
            const datatype = this.singleObject(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#datatype" /* sh.datatype */));
            const nodeShapes = this.store.getObjectsOnce(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#node" /* sh.node */), null);
            if (nodeKind) {
                this.writer.add(' ');
                this.writer.add((0, utils_1.getShaclName)(nodeKind));
            }
            if (propertyClass) {
                this.writer.add(' ');
                this.writer.add(yield this.termToString(propertyClass));
            }
            if (datatype) {
                this.writer.add(' ');
                this.writer.add(yield this.termToString(datatype));
            }
            if (min !== undefined || max !== undefined) {
                this.writer.add(' [');
                if (min) {
                    if (min.termType !== 'Literal' || min.datatypeString !== 'http://www.w3.org/2001/XMLSchema#integer') {
                        throw new Error('Invalid min value, must me an integer literal');
                    }
                    this.writer.add(min.value);
                }
                else {
                    this.writer.add('0');
                }
                this.writer.add('..');
                if (max) {
                    if (max.termType !== 'Literal' || max.datatypeString !== 'http://www.w3.org/2001/XMLSchema#integer') {
                        throw new Error('Invalid max value, must me an integer literal');
                    }
                    this.store.removeMatches(property, new n3_1.NamedNode("http://www.w3.org/ns/shacl#maxCount" /* sh.maxCount */), undefined, undefined);
                    this.writer.add(max.value);
                }
                else {
                    this.writer.add('*');
                }
                this.writer.add(']');
            }
            yield this.writeParams(property, false, property_param_1.default, true);
            const nestedShapes = [];
            for (const node of nodeShapes) {
                if (node.termType === 'NamedNode') {
                    this.writer.add(' ');
                    this.writer.add(`@${yield this.termToString(node)}`);
                }
                else if (node.termType === 'BlankNode') {
                    nestedShapes.push(node);
                }
                else {
                    throw new Error('Invalid nested shape, must be blank node or IRI');
                }
            }
            for (const shape of nestedShapes) {
                this.writer.add(' ');
                yield this.writeShapeBody(shape);
            }
            if (this.extendedSyntax && this.store.getQuads(property, null, null, null).length > 0) {
                this.writer.add(' %');
                this.writer.indent();
                this.writer.newLine(1);
                yield this.writeTurtlePredicates(property);
                this.writer.deindent();
                this.writer.newLine(1);
                this.writer.add('%');
            }
            if (nestedShapes.length === 0) {
                this.writer.add(' .');
            }
        });
    }
    writeTurtlePredicates(term) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.writeGivenTurtlePredicates(term, this.store.getPredicates(term, null, null));
        });
    }
    writeGivenTurtlePredicates(term, predicates) {
        return __awaiter(this, void 0, void 0, function* () {
            let semi = false;
            if (predicates.some((predicate) => predicate.equals(n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')))) {
                const types = this.store.getObjectsOnce(term, n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), null);
                if (types.length > 0) {
                    semi = true;
                    this.writer.add('a ');
                    yield this.writeTurtleObjects(types);
                }
            }
            for (const predicate of predicates) {
                if (!predicate.equals(n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'))) {
                    if (semi) {
                        this.writer.add(' ;');
                        this.writer.newLine(1);
                    }
                    else {
                        semi = true;
                    }
                    this.writer.add(yield this.termToString(predicate, true));
                    this.writer.add(' ');
                    yield this.writeTurtleObjects(this.store.getObjectsOnce(term, predicate, null));
                }
            }
        });
    }
    writeTurtleObjects(objects) {
        return __awaiter(this, void 0, void 0, function* () {
            const blankObjects = [];
            const nonBlankObjects = [];
            for (const object of objects) {
                if (object.termType === 'BlankNode'
                    && [...this.store.match(null, null, object), ...this.store.match(null, object, null)].length === 0) {
                    blankObjects.push(object);
                }
                else {
                    nonBlankObjects.push(object);
                }
            }
            this.writer.add((yield Promise.all(nonBlankObjects.map((object) => this.termToString(object, true, true)))).join(', '));
            let comma = nonBlankObjects.length > 0;
            if (blankObjects.length > 0) {
                for (const blank of blankObjects) {
                    if (comma) {
                        this.writer.add(', ');
                    }
                    else {
                        comma = true;
                    }
                    if (!(yield this.writeList(blank))) {
                        this.writer.add('[');
                        this.writer.indent();
                        this.writer.newLine(1);
                        yield this.writeTurtlePredicates(blank);
                        this.writer.deindent();
                        this.writer.newLine(1);
                        this.writer.add(']');
                    }
                }
            }
        });
    }
    writeList(object) {
        return __awaiter(this, void 0, void 0, function* () {
            let node = object;
            const elems = [];
            const quads = [];
            while (!node.equals(n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'))) {
                const first = this.store.getQuadsOnce(node, n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first'), null, null);
                const rest = this.store.getQuadsOnce(node, n3_1.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'), null, null);
                quads.push(...first, ...rest);
                if (first.length !== 1 || rest.length !== 1 || this.store.getQuads(node, null, null, null).length !== 0) {
                    this.store.addQuads(quads);
                    return false;
                }
                elems.push(first[0].object);
                node = rest[0].object;
            }
            let space = false;
            this.writer.add('(');
            for (const elem of elems) {
                if (space) {
                    this.writer.add(' ');
                }
                else {
                    space = true;
                }
                yield this.writeTurtleObjects([elem]);
            }
            this.writer.add(')');
            return true;
        });
    }
    writePath(term, braces = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (term.termType === 'NamedNode') {
                this.writer.add(yield this.termToString(term));
            }
            else if (term.termType === 'BlankNode') {
                const quads = this.store.getQuadsOnce(term, null, null, null);
                if (quads.length === 1) {
                    const { predicate, object } = quads[0];
                    switch (predicate.value) {
                        case "http://www.w3.org/ns/shacl#inversePath" /* sh.inversePath */:
                            this.writer.add('^');
                            yield this.writePath(object, true);
                            return;
                        case "http://www.w3.org/ns/shacl#alternativePath" /* sh.alternativePath */: {
                            const alternatives = this.getList(object);
                            if (alternatives.length === 0) {
                                throw new Error('Invalid Alternative Path - no options');
                            }
                            else if (alternatives.length === 1) {
                                yield this.writePath(alternatives[0]);
                            }
                            else {
                                if (braces) {
                                    this.writer.add('(');
                                }
                                let first = true;
                                for (const alt of alternatives) {
                                    if (first) {
                                        first = false;
                                    }
                                    else {
                                        this.writer.add('|');
                                    }
                                    yield this.writePath(alt, true);
                                }
                                if (braces) {
                                    this.writer.add(')');
                                }
                            }
                            return;
                        }
                        case "http://www.w3.org/ns/shacl#zeroOrMorePath" /* sh.zeroOrMorePath */:
                            yield this.writePath(object, true);
                            this.writer.add('*');
                            return;
                        case "http://www.w3.org/ns/shacl#oneOrMorePath" /* sh.oneOrMorePath */:
                            yield this.writePath(object, true);
                            this.writer.add('+');
                            return;
                        case "http://www.w3.org/ns/shacl#zeroOrOnePath" /* sh.zeroOrOnePath */:
                            yield this.writePath(object, true);
                            this.writer.add('?');
                            return;
                        default:
                            throw new Error(`Invalid path type ${term.value}`);
                    }
                }
                else {
                    // TODO Make more efficient
                    this.store.addQuads(quads);
                    const sequence = this.getList(term);
                    if (sequence.length === 0) {
                        throw new Error('Invalid Path');
                        // TODO: See if the following case is necessary
                        // else if (sequence.length === 1) {
                        //   await this.writePath(sequence[0]);
                        // }
                    }
                    else {
                        if (braces) {
                            this.writer.add('(');
                        }
                        let first = true;
                        for (const alt of sequence) {
                            if (first) {
                                first = false;
                            }
                            else {
                                this.writer.add('/');
                            }
                            yield this.writePath(alt, true);
                        }
                        if (braces) {
                            this.writer.add(')');
                        }
                    }
                }
            }
            else {
                throw new Error('Path should be named node or blank node');
            }
        });
    }
}
exports.default = SHACLCWriter;
