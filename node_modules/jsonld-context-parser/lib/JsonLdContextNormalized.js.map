{"version":3,"file":"JsonLdContextNormalized.js","sourceRoot":"","sources":["JsonLdContextNormalized.ts"],"names":[],"mappings":";;;AAAA,uEAAiD;AACjD,6CAAqD;AAErD,iCAA4B;AAE5B;;GAEG;AACH,MAAa,uBAAuB;IAIlC,YAAY,UAAuC;QACjD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAED;;OAEG;IACI,aAAa;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;OAoBG;IACI,UAAU,CAAC,IAAY,EAAE,WAAqB,EACnC,UAA0B,4BAAoB;QAC9D,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAE3C,6DAA6D;QAC7D,IAAI,YAAY,KAAK,IAAI,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,EAAE;YAC3E,OAAO,IAAI,CAAC;SACb;QAED,gBAAgB;QAChB,IAAI,eAAe,GAAG,IAAI,CAAC;QAC3B,IAAI,YAAY,IAAI,WAAW,EAAE;YAC/B,MAAM,KAAK,GAAG,WAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;YACnD,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,EAAE;gBAC3B,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,CAAC,WAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,WAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE;oBACzF,6FAA6F;oBAC7F,IAAI,CAAC,WAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,EAAE;wBACnC,eAAe,GAAG,KAAK,CAAC;qBACzB;iBACF;qBAAM;oBACL,OAAO,KAAK,CAAC;iBACd;aACF;SACF;QAED,gCAAgC;QAChC,MAAM,MAAM,GAAkB,WAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QACpE,MAAM,KAAK,GAA8B,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACnE,MAAM,aAAa,GAAY,CAAC,CAAC,CAAC,KAAK,IAAI,KAAK,KAAK,EAAE,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACnF,MAAM,IAAI,GAA8B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QACjE,MAAM,gBAAgB,GAAG,WAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,MAAM,EAAE;YACV,MAAM,kBAAkB,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACnD,MAAM,KAAK,GAAG,WAAI,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;YAEzD,IAAI,KAAK,EAAE;gBACT,IAAI,OAAO,kBAAkB,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE;oBACzE,uCAAuC;oBACvC,qFAAqF;oBACrF,6EAA6E;oBAC7E,IAAI,CAAC,WAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,OAAO,CAAC,EAAE;wBACtD,oCAAoC;wBACpC,OAAO,IAAI,CAAC;qBACb;iBACF;qBAAM;oBACL,oEAAoE;oBACpE,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,gBAAgB,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE;wBACzG,oCAAoC;wBACpC,OAAO,IAAI,CAAC;qBACb;iBACF;gBAED,OAAO,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAC/C;SACF;aAAM,IAAI,WAAW,IAAI,CAAC,CAAC,KAAK,IAAI,KAAK,KAAK,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,wBAAwB,IAAI,CAAC,IAAI,IAAI,aAAa,CAAC,CAAC,CAAC;eAC/G,CAAC,gBAAgB,IAAI,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;YAClD,IAAI,aAAa,EAAE;gBACjB,IAAI,OAAO,CAAC,wBAAwB,EAAE;oBACpC,OAAO,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,IAAA,kCAAO,EAAU,KAAK,EAAQ,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;iBAC5E;qBAAM;oBACL,MAAM,IAAI,uBAAU,CAAC,sCAAsC,IAAI,iBAC7D,KAAK,mBAAmB,EAAE,wBAAW,CAAC,qBAAqB,CAAC,CAAC;iBAChE;aACF;iBAAM;gBACL,OAAO,KAAK,GAAG,IAAI,CAAC;aACrB;SACF;aAAM,IAAI,CAAC,WAAW,IAAI,IAAI,IAAI,CAAC,gBAAgB,IAAI,CAAC,WAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;YAChF,OAAO,IAAA,kCAAO,EAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SAC5B;QAED,2GAA2G;QAC3G,IAAI,eAAe,EAAE;YACnB,OAAO,IAAI,CAAC;SACb;aAAM;YACL,MAAM,IAAI,uBAAU,CAAC,gDAAgD,IAAI,OACvE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,EAAE,wBAAW,CAAC,mBAAmB,CAAC,CAAC;SACrE;IACH,CAAC;IAED;;;;;;;;;OASG;IACI,UAAU,CAAC,GAAW,EAAE,KAAe;QAC5C,wBAAwB;QACxB,IAAI,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE;YACnF,OAAO,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC;SACrD;QAED,uBAAuB;QACvB,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;YAClF,OAAO,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;SACpD;QAED,qCAAqC;QACrC,gDAAgD;QAChD,2FAA2F;QAC3F,MAAM,iBAAiB,GAAuC,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC;QAC1F,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,UAAU,EAAE;YACjC,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,KAAK,IAAI,CAAC,WAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE;gBAC1C,MAAM,UAAU,GAAG,WAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;gBACjD,IAAI,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;oBAC9B,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;oBAC7C,IAAI,CAAC,MAAM,EAAE;wBACX,IAAI,KAAK,EAAE;4BACT,wCAAwC;4BACxC,OAAO,GAAG,CAAC;yBACZ;qBACF;yBAAM,IAAI,MAAM,CAAC,MAAM,GAAG,iBAAiB,CAAC,MAAM,CAAC,MAAM,EAAE;wBAC1D,gCAAgC;wBAChC,iBAAiB,CAAC,MAAM,GAAG,GAAG,CAAC;wBAC/B,iBAAiB,CAAC,MAAM,GAAG,MAAM,CAAC;qBACnC;iBACF;aACF;SACF;QAED,6BAA6B;QAC7B,IAAI,iBAAiB,CAAC,MAAM,EAAE;YAC5B,OAAO,iBAAiB,CAAC,MAAM,GAAG,GAAG,GAAG,iBAAiB,CAAC,MAAM,CAAC;SAClE;QAED,OAAO,GAAG,CAAC;IACb,CAAC;CAEF;AAxKD,0DAwKC;AAkBY,QAAA,oBAAoB,GAAmB;IAClD,kBAAkB,EAAE,IAAI;IACxB,uBAAuB,EAAE,KAAK;IAC9B,wBAAwB,EAAE,IAAI;CAC/B,CAAC","sourcesContent":["import {resolve} from \"relative-to-absolute-iri\";\nimport {ERROR_CODES, ErrorCoded} from \"./ErrorCoded\";\nimport {IJsonLdContextNormalizedRaw} from \"./JsonLdContext\";\nimport {Util} from \"./Util\";\n\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nexport class JsonLdContextNormalized {\n\n  private readonly contextRaw: IJsonLdContextNormalizedRaw;\n\n  constructor(contextRaw: IJsonLdContextNormalizedRaw) {\n    this.contextRaw = contextRaw;\n  }\n\n  /**\n   * @return The raw inner context.\n   */\n  public getContextRaw(): IJsonLdContextNormalizedRaw {\n    return this.contextRaw;\n  }\n\n  /**\n   * Expand the term or prefix of the given term if it has one,\n   * otherwise return the term as-is.\n   *\n   * This will try to expand the IRI as much as possible.\n   *\n   * Iff in vocab-mode, then other references to other terms in the context can be used,\n   * such as to `myTerm`:\n   * ```\n   * {\n   *   \"myTerm\": \"http://example.org/myLongTerm\"\n   * }\n   * ```\n   *\n   * @param {string} term A term that is an URL or a prefixed URL.\n   * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n   *                              otherwise it is considered a regular term that is expanded based on @base.\n   * @param {IExpandOptions} options Options that define the way how expansion must be done.\n   * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n   * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n   */\n  public expandTerm(term: string, expandVocab?: boolean,\n                    options: IExpandOptions = defaultExpandOptions): string | null {\n    const contextValue = this.contextRaw[term];\n\n    // Immediately return if the term was disabled in the context\n    if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n      return null;\n    }\n\n    // Check the @id\n    let validIriMapping = true;\n    if (contextValue && expandVocab) {\n      const value = Util.getContextValueId(contextValue);\n      if (value && value !== term) {\n        if (typeof value !== 'string' || (!Util.isValidIri(value) && !Util.isValidKeyword(value))) {\n          // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n          if (!Util.isPotentialKeyword(value)) {\n            validIriMapping = false;\n          }\n        } else {\n          return value;\n        }\n      }\n    }\n\n    // Check if the term is prefixed\n    const prefix: string | null = Util.getPrefix(term, this.contextRaw);\n    const vocab: string | undefined | null = this.contextRaw['@vocab'];\n    const vocabRelative: boolean = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n    const base: string | undefined | null = this.contextRaw['@base'];\n    const potentialKeyword = Util.isPotentialKeyword(term);\n    if (prefix) {\n      const contextPrefixValue = this.contextRaw[prefix];\n      const value = Util.getContextValueId(contextPrefixValue);\n\n      if (value) {\n        if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n          // If we have a simple term definition,\n          // check the last character of the prefix to determine whether or not it is a prefix.\n          // Validate that prefix ends with gen-delim character, unless @prefix is true\n          if (!Util.isSimpleTermDefinitionPrefix(value, options)) {\n            // Treat the term as an absolute IRI\n            return term;\n          }\n        } else {\n          // If we have an expanded term definition, default to @prefix: false\n          if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n            // Treat the term as an absolute IRI\n            return term;\n          }\n        }\n\n        return value + term.substr(prefix.length + 1);\n      }\n    } else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n      && !potentialKeyword && !Util.isCompactIri(term)) {\n      if (vocabRelative) {\n        if (options.allowVocabRelativeToBase) {\n          return ((vocab || base) ? resolve(<string> vocab, <any> base) : '') + term;\n        } else {\n          throw new ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${\n            vocab}' is not allowed.`, ERROR_CODES.INVALID_VOCAB_MAPPING);\n        }\n      } else {\n        return vocab + term;\n      }\n    } else if (!expandVocab && base && !potentialKeyword && !Util.isCompactIri(term)) {\n      return resolve(term, base);\n    }\n\n    // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n    if (validIriMapping) {\n      return term;\n    } else {\n      throw new ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${\n        JSON.stringify(contextValue)}'`, ERROR_CODES.INVALID_IRI_MAPPING);\n    }\n  }\n\n  /**\n   * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n   *\n   * This will try to compact the IRI as much as possible.\n   *\n   * @param {string} iri An IRI to compact.\n   * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n   *                        otherwise it is considered a regular term that is compacted based on @base.\n   * @return {string} The compacted term or the IRI as-is.\n   */\n  public compactIri(iri: string, vocab?: boolean): string {\n    // Try @vocab compacting\n    if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n      return iri.substr(this.contextRaw['@vocab'].length);\n    }\n\n    // Try @base compacting\n    if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n      return iri.substr(this.contextRaw['@base'].length);\n    }\n\n    // Loop over all terms in the context\n    // This will try to prefix as short as possible.\n    // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n    const shortestPrefixing: { prefix: string, suffix: string } = { prefix: '', suffix: iri };\n    for (const key in this.contextRaw) {\n      const value = this.contextRaw[key];\n      if (value && !Util.isPotentialKeyword(key)) {\n        const contextIri = Util.getContextValueId(value);\n        if (iri.startsWith(contextIri)) {\n          const suffix = iri.substr(contextIri.length);\n          if (!suffix) {\n            if (vocab) {\n              // Immediately return on compacted alias\n              return key;\n            }\n          } else if (suffix.length < shortestPrefixing.suffix.length) {\n            // Overwrite the shortest prefix\n            shortestPrefixing.prefix = key;\n            shortestPrefixing.suffix = suffix;\n          }\n        }\n      }\n    }\n\n    // Return the shortest prefix\n    if (shortestPrefixing.prefix) {\n      return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n    }\n\n    return iri;\n  }\n\n}\n\nexport interface IExpandOptions {\n  /**\n   * If compact IRI prefixes can end with any kind of character in simple term definitions,\n   * instead of only the default gen-delim characters (:,/,?,#,[,],@).\n   */\n  allowPrefixNonGenDelims: boolean;\n  /**\n   * If compact IRI prefixes ending with a non-gen-delim character\n   * can be forced as a prefix using @prefix: true.\n   */\n  allowPrefixForcing: boolean;\n  /**\n   * If @vocab values are allowed contain IRIs relative to @base.\n   */\n  allowVocabRelativeToBase: boolean;\n}\nexport const defaultExpandOptions: IExpandOptions = {\n  allowPrefixForcing: true,\n  allowPrefixNonGenDelims: false,\n  allowVocabRelativeToBase: true,\n};"]}