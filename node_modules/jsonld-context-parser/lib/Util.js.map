{"version":3,"file":"Util.js","sourceRoot":"","sources":["Util.ts"],"names":[],"mappings":"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","sourcesContent":["import {IExpandOptions} from \"./JsonLdContextNormalized\";\nimport {IJsonLdContextNormalizedRaw, JsonLdContext} from \"./JsonLdContext\";\n\nexport class Util {\n\n  // Regex for valid IRIs\n  public static readonly IRI_REGEX: RegExp = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n  // Weaker regex for valid IRIs, this includes relative IRIs\n  public static readonly IRI_REGEX_WEAK: RegExp = /(?::[^:])|\\//;\n  // Regex for keyword form\n  public static readonly KEYWORD_REGEX: RegExp = /^@[a-z]+$/i;\n  // Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\n  public static readonly ENDS_WITH_GEN_DELIM: RegExp = /[:/?#\\[\\]@]$/;\n  // Regex for language tags\n  public static readonly REGEX_LANGUAGE_TAG: RegExp = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n  // Regex for base directions\n  public static readonly REGEX_DIRECTION_TAG: RegExp = /^(ltr)|(rtl)$/;\n\n  // All known valid JSON-LD keywords\n  // @see https://www.w3.org/TR/json-ld11/#keywords\n  public static readonly VALID_KEYWORDS: {[keyword: string]: boolean} = {\n    '@annotation': true, // https://json-ld.github.io/json-ld-star/\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n  };\n  // Keys in the contexts that will not be expanded based on the base IRI\n  public static readonly EXPAND_KEYS_BLACKLIST: string[] = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n  ];\n  // Keys in the contexts that may not be aliased from\n  public static readonly ALIAS_DOMAIN_BLACKLIST: string[] = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n  ];\n  // Keys in the contexts that may not be aliased to\n  public static readonly ALIAS_RANGE_BLACKLIST: string[] = [\n    '@context',\n    '@preserve',\n  ];\n  // All valid @container values\n  public static readonly CONTAINERS: string[] = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n  ];\n  // All valid @container values under processing mode 1.0\n  public static readonly CONTAINERS_1_0: string[] = [\n    '@list',\n    '@set',\n    '@index',\n  ];\n\n  /**\n   * Check if the given term is a valid compact IRI.\n   * Otherwise, it may be an IRI.\n   * @param {string} term A term.\n   * @return {boolean} If it is a compact IRI.\n   */\n  public static isCompactIri(term: string) {\n    return term.indexOf(':') > 0 && !(term && term[0] === '#');\n  }\n\n  /**\n   * Get the prefix from the given term.\n   * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n   * @param {string} term A term that is an URL or a prefixed URL.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @return {string} The prefix or null.\n   */\n  public static getPrefix(term: string, context: IJsonLdContextNormalizedRaw): string | null {\n    // Do not consider relative IRIs starting with a hash as compact IRIs\n    if (term && term[0] === '#') {\n      return null;\n    }\n\n    const separatorPos: number = term.indexOf(':');\n    if (separatorPos >= 0) {\n      // Suffix can not begin with two slashes\n      if (term.length > separatorPos + 1\n        && term.charAt(separatorPos + 1) === '/'\n        && term.charAt(separatorPos + 2) === '/') {\n        return null;\n      }\n\n      const prefix: string = term.substr(0, separatorPos);\n\n      // Prefix can not be an underscore (this is a blank node)\n      if (prefix === '_' ) {\n        return null;\n      }\n\n      // Prefix must match a term in the active context\n      if (context[prefix]) {\n        return prefix;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * From a given context entry value, get the string value, or the @id field.\n   * @param contextValue A value for a term in a context.\n   * @return {string} The id value, or null.\n   */\n  public static getContextValueId(contextValue: any): string {\n    if (contextValue === null || typeof contextValue === 'string') {\n      return contextValue;\n    }\n    const id = contextValue['@id'];\n    return id ? id : null;\n  }\n\n  /**\n   * Check if the given simple term definition (string-based value of a context term)\n   * should be considered a prefix.\n   * @param value A simple term definition value.\n   * @param options Options that define the way how expansion must be done.\n   */\n  public static isSimpleTermDefinitionPrefix(value: unknown, options: IExpandOptions): boolean {\n    return !Util.isPotentialKeyword(value)\n      && (options.allowPrefixNonGenDelims || (typeof value === 'string' && (value[0] === '_' || Util.isPrefixIriEndingWithGenDelim(value))));\n  }\n\n  /**\n   * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n   * @param {string} keyword A potential keyword.\n   * @return {boolean} If the given keyword is of the keyword format.\n   */\n  public static isPotentialKeyword(keyword: any): boolean {\n    return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n  }\n\n  /**\n   * Check if the given prefix ends with a gen-delim character.\n   * @param {string} prefixIri A prefix IRI.\n   * @return {boolean} If the given prefix IRI is valid.\n   */\n  public static isPrefixIriEndingWithGenDelim(prefixIri: string): boolean {\n    return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n  }\n\n  /**\n   * Check if the given context value can be a prefix value.\n   * @param value A context value.\n   * @return {boolean} If it can be a prefix value.\n   */\n  public static isPrefixValue(value: any): boolean {\n    return value && (typeof value === 'string' || (value && typeof value === 'object'));\n  }\n\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n  public static isValidIri(iri: string | null): boolean {\n    return Boolean(iri && Util.IRI_REGEX.test(iri));\n  }\n\n  /**\n   * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n  public static isValidIriWeak(iri: string | null): boolean {\n    return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n  }\n\n  /**\n   * Check if the given keyword is a defined according to the JSON-LD specification.\n   * @param {string} keyword A potential keyword.\n   * @return {boolean} If the given keyword is valid.\n   */\n  public static isValidKeyword(keyword: any): boolean {\n    return Util.VALID_KEYWORDS[keyword];\n  }\n\n  /**\n   * Check if the given term is protected in the context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {string} key A context term.\n   * @return {boolean} If the given term has an @protected flag.\n   */\n  public static isTermProtected(context: IJsonLdContextNormalizedRaw, key: string): boolean {\n    const value = context[key];\n    return !(typeof value === 'string') && value && value['@protected'];\n  }\n\n  /**\n   * Check if the given context has at least one protected term.\n   * @param context A context.\n   * @return If the context has a protected term.\n   */\n  public static hasProtectedTerms(context: IJsonLdContextNormalizedRaw) {\n    for (const key of Object.keys(context)) {\n      if (Util.isTermProtected(context, key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the given key is an internal reserved keyword.\n   * @param key A context key.\n   */\n  public static isReservedInternalKeyword(key: string) {\n    return key.startsWith('@__');\n  }\n\n  /**\n   * Check if two objects are deepEqual to on another.\n   * @param object1 The first object to test.\n   * @param object2 The second object to test.\n   */\n  public static deepEqual(object1: any, object2: any): boolean {\n    const objKeys1 = Object.keys(object1);\n    const objKeys2 = Object.keys(object2);\n\n    if (objKeys1.length !== objKeys2.length) return false;\n    return objKeys1.every((key) => {\n      const value1 = object1[key];\n      const value2 = object2[key];\n      return (value1 === value2) || (\n        value1 !== null &&\n        value2 !== null &&\n        typeof value1 === \"object\" &&\n        typeof value2 === \"object\" &&\n        this.deepEqual(value1, value2)\n      );\n    });\n  };\n}\n"]}