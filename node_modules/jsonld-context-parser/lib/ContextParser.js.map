{"version":3,"file":"ContextParser.js","sourceRoot":"","sources":["ContextParser.ts"],"names":[],"mappings":"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","sourcesContent":["import 'cross-fetch/polyfill';\nimport {resolve} from \"relative-to-absolute-iri\";\nimport {ERROR_CODES, ErrorCoded} from \"./ErrorCoded\";\nimport {FetchDocumentLoader} from \"./FetchDocumentLoader\";\nimport {IDocumentLoader} from \"./IDocumentLoader\";\nimport {IJsonLdContext, IJsonLdContextNormalizedRaw, IPrefixValue, JsonLdContext} from \"./JsonLdContext\";\nimport {JsonLdContextNormalized, defaultExpandOptions, IExpandOptions} from \"./JsonLdContextNormalized\";\nimport {Util} from \"./Util\";\n\n/**\n * Parses JSON-LD contexts.\n */\nexport class ContextParser {\n\n  public static readonly DEFAULT_PROCESSING_MODE: number = 1.1;\n\n  private readonly documentLoader: IDocumentLoader;\n  private readonly documentCache: {[url: string]: JsonLdContext};\n  private readonly validateContext: boolean;\n  private readonly expandContentTypeToBase: boolean;\n  private readonly remoteContextsDepthLimit: number;\n  private readonly redirectSchemaOrgHttps: boolean;\n\n  constructor(options?: IContextParserOptions) {\n    options = options || {};\n    this.documentLoader = options.documentLoader || new FetchDocumentLoader();\n    this.documentCache = {};\n    this.validateContext = !options.skipValidation;\n    this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n    this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n    this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n  }\n\n  /**\n   * Validate the given @language value.\n   * An error will be thrown if it is invalid.\n   * @param value An @language value.\n   * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n   * @param {string} errorCode The error code to emit on errors.\n   * @return {boolean} If validation passed.\n   *                   Can only be false if strictRange is false and the string value did not pass the regex.\n   */\n  public static validateLanguage(value: any, strictRange: boolean, errorCode: string): boolean {\n    if (typeof value !== 'string') {\n      throw new ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n    }\n\n    if (!Util.REGEX_LANGUAGE_TAG.test(value)) {\n      if (strictRange) {\n        throw new ErrorCoded(`The value of an '@language' must be a valid language tag, got '${\n          JSON.stringify(value)}'`, errorCode);\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate the given @direction value.\n   * An error will be thrown if it is invalid.\n   * @param value An @direction value.\n   * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n   * @return {boolean} If validation passed.\n   *                   Can only be false if strictRange is false and the string value did not pass the regex.\n   */\n  public static validateDirection(value: any, strictValues: boolean) {\n    if (typeof value !== 'string') {\n      throw new ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`,\n        ERROR_CODES.INVALID_BASE_DIRECTION);\n    }\n\n    if (!Util.REGEX_DIRECTION_TAG.test(value)) {\n      if (strictValues) {\n        throw new ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${\n          JSON.stringify(value)}'`, ERROR_CODES.INVALID_BASE_DIRECTION);\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Add an @id term for all @reverse terms.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n   */\n  public idifyReverseTerms(context: IJsonLdContextNormalizedRaw): IJsonLdContextNormalizedRaw {\n    for (const key of Object.keys(context)) {\n      let value = context[key];\n      if (value && typeof value === 'object') {\n        if (value['@reverse'] && !value['@id']) {\n          if (typeof value['@reverse'] !== 'string' || Util.isValidKeyword(value['@reverse'])) {\n            throw new ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`,\n              ERROR_CODES.INVALID_IRI_MAPPING);\n          }\n          value = context[key] = {...value, '@id': value['@reverse']};\n          value['@id'] = <string> value['@reverse'];\n          if (Util.isPotentialKeyword(value['@reverse'])) {\n            delete value['@reverse'];\n          } else {\n            value['@reverse'] = <any> true;\n          }\n        }\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Expand all prefixed terms in the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n   *                                          via @base if @vocab is set to null.\n   * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all\n   * keys in the context will be expanded.\n   */\n  public expandPrefixedTerms(context: JsonLdContextNormalized, expandContentTypeToBase: boolean, keys?: string[]) {\n    const contextRaw = context.getContextRaw();\n    for (const key of (keys || Object.keys(contextRaw))) {\n      // Only expand allowed keys\n      if (Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util.isReservedInternalKeyword(key)) {\n        // Error if we try to alias a keyword to something else.\n        const keyValue = contextRaw[key];\n        if (Util.isPotentialKeyword(key) && Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n          if (key !== '@type' || typeof contextRaw[key] === 'object'\n            && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n            throw new ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ERROR_CODES.KEYWORD_REDEFINITION);\n          }\n        }\n\n        // Error if we try to alias to an illegal keyword\n        if (Util.ALIAS_RANGE_BLACKLIST.indexOf(Util.getContextValueId(keyValue)) >= 0) {\n          throw new ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ERROR_CODES.INVALID_KEYWORD_ALIAS);\n        }\n\n        // Error if this term was marked as prefix as well\n        if (keyValue && Util.isPotentialKeyword(Util.getContextValueId(keyValue))\n          && keyValue['@prefix'] === true) {\n          throw new ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`,\n            ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n\n        // Loop because prefixes might be nested\n        while (Util.isPrefixValue(contextRaw[key])) {\n          const value: IPrefixValue = contextRaw[key];\n          let changed: boolean = false;\n          if (typeof value === 'string') {\n            contextRaw[key] = context.expandTerm(value, true);\n            changed = changed || value !== contextRaw[key];\n          } else {\n            const id = value['@id'];\n            const type = value['@type'];\n            // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n            const canAddIdEntry = !('@prefix' in value) || Util.isValidIri(key);\n            if ('@id' in value) {\n              // Use @id value for expansion\n              if (id !== undefined && id !== null && typeof id === 'string') {\n                contextRaw[key] = { ...contextRaw[key], '@id': context.expandTerm(id, true) };\n                changed = changed || id !== contextRaw[key]['@id'];\n              }\n            } else if (!Util.isPotentialKeyword(key) && canAddIdEntry) {\n              // Add an explicit @id value based on the expanded key value\n              const newId = context.expandTerm(key, true);\n              if (newId !== key) {\n                // Don't set @id if expansion failed\n                contextRaw[key] = { ...contextRaw[key], '@id': newId };\n                changed = true;\n              }\n            }\n            if (type && typeof type === 'string' && type !== '@vocab'\n              && (!value['@container'] || !(<any> value['@container'])['@type'])\n              && canAddIdEntry) {\n              // First check @vocab, then fallback to @base\n              let expandedType = context.expandTerm(type, true);\n              if (expandContentTypeToBase && type === expandedType) {\n                expandedType = context.expandTerm(type, false);\n              }\n              if (expandedType !== type) {\n                changed = true;\n                contextRaw[key] = { ...contextRaw[key], '@type': expandedType };\n              }\n            }\n          }\n          if (!changed) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Normalize the @language entries in the given context to lowercase.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} parseOptions The parsing options.\n   */\n  public normalize(context: IJsonLdContextNormalizedRaw,\n                   { processingMode, normalizeLanguageTags }: IParseOptions) {\n    // Lowercase language keys in 1.0\n    if (normalizeLanguageTags || processingMode === 1.0) {\n      for (const key of Object.keys(context)) {\n        if (key === '@language' && typeof context[key] === 'string') {\n          context[key] = (<string> context[key]).toLowerCase();\n        } else {\n          const value = context[key];\n          if (value && typeof value === 'object') {\n            if (typeof value['@language'] === 'string') {\n              const lowercase = value['@language'].toLowerCase();\n              if (lowercase !== value['@language']) {\n                context[key] = {...value, '@language': lowercase};\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert all @container strings and array values to hash-based values.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   */\n  public containersToHash(context: IJsonLdContextNormalizedRaw) {\n    for (const key of Object.keys(context)) {\n      const value = context[key];\n      if (value && typeof value === 'object') {\n        if (typeof value['@container'] === 'string') {\n          context[key] = { ...value, '@container': { [value['@container']]: true } };\n        } else if (Array.isArray(value['@container'])) {\n          const newValue: {[key: string]: boolean} = {};\n          for (const containerValue of value['@container']) {\n            newValue[containerValue] = true;\n          }\n          context[key] = { ...value, '@container': newValue };\n        }\n      }\n    }\n  }\n\n  /**\n   * Normalize and apply context-level @protected terms onto each term separately.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {number} processingMode The processing mode.\n   */\n  public applyScopedProtected(context: IJsonLdContextNormalizedRaw, { processingMode }: IParseOptions, expandOptions: IExpandOptions) {\n    if (processingMode && processingMode >= 1.1) {\n      if (context['@protected']) {\n        for (const key of Object.keys(context)) {\n          if (Util.isReservedInternalKeyword(key)) {\n            continue;\n          }\n\n          if (!Util.isPotentialKeyword(key) && !Util.isTermProtected(context, key)) {\n            const value: unknown = context[key];\n            if (value && typeof value === 'object') {\n              if (!('@protected' in context[key])) {\n                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                context[key] = {...context[key], '@protected': true};\n              }\n            } else {\n              // Convert string-based term values to object-based values with @protected: true\n              context[key] = {\n                '@id': value,\n                '@protected': true,\n              };\n              if (Util.isSimpleTermDefinitionPrefix(value, expandOptions)) {\n                context[key] = {...context[key], '@prefix': true};\n              }\n            }\n          }\n        }\n        delete context['@protected'];\n      }\n    }\n  }\n\n  /**\n   * Check if the given context inheritance does not contain any overrides of protected terms.\n   * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n   * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n   * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n   * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all\n   * keys defined in contextAfter will be checked.\n   */\n  public validateKeywordRedefinitions(contextBefore: IJsonLdContextNormalizedRaw,\n                                      contextAfter: IJsonLdContextNormalizedRaw,\n                                      expandOptions?: IExpandOptions,\n                                      keys?: string[]) {\n    for (const key of (keys ?? Object.keys(contextAfter) )) {\n      if (Util.isTermProtected(contextBefore, key)) {\n        // The entry in the context before will always be in object-mode\n        // If the new entry is in string-mode, convert it to object-mode\n        // before checking if it is identical.\n        if (typeof contextAfter[key] === 'string') {\n          contextAfter[key] = { '@id': contextAfter[key], '@protected': true };\n        } else {\n        // We modify this deliberately,\n        // as we need it for the value comparison (they must be identical modulo '@protected')),\n        // and for the fact that this new value will override the first one.\n          contextAfter[key] = {...contextAfter[key], '@protected': true};\n        }\n\n        // Error if they are not identical\n        if (!Util.deepEqual(contextBefore[key], contextAfter[key])) {\n          throw new ErrorCoded(`Attempted to override the protected keyword ${key} from ${\n            JSON.stringify(Util.getContextValueId(contextBefore[key]))} to ${\n            JSON.stringify(Util.getContextValueId(contextAfter[key]))}`,\n            ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate the entries of the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} options The parse options.\n   */\n  public validate(context: IJsonLdContextNormalizedRaw, { processingMode }: IParseOptions) {\n    for (const key of Object.keys(context)) {\n      // Ignore reserved internal keywords.\n      if (Util.isReservedInternalKeyword(key)) {\n        continue;\n      }\n\n      // Do not allow empty term\n      if (key === '') {\n        throw new ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`,\n          ERROR_CODES.INVALID_TERM_DEFINITION);\n      }\n\n      const value = context[key];\n      const valueType = typeof value;\n      // First check if the key is a keyword\n      if (Util.isPotentialKeyword(key)) {\n        switch (key.substr(1)) {\n        case 'vocab':\n          if (value !== null && valueType !== 'string') {\n            throw new ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ERROR_CODES.INVALID_VOCAB_MAPPING);\n          }\n          break;\n        case 'base':\n          if (value !== null && valueType !== 'string') {\n            throw new ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ERROR_CODES.INVALID_BASE_IRI);\n          }\n          break;\n        case 'language':\n          if (value !== null) {\n            ContextParser.validateLanguage(value, true, ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n          }\n          break;\n        case 'version':\n          if (value !== null && valueType !== 'number') {\n            throw new ErrorCoded(`Found an invalid @version number: ${value}`, ERROR_CODES.INVALID_VERSION_VALUE);\n          }\n          break;\n        case 'direction':\n          if (value !== null) {\n            ContextParser.validateDirection(value, true);\n          }\n          break;\n        case 'propagate':\n          if (processingMode === 1.0) {\n            throw new ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ERROR_CODES.INVALID_CONTEXT_ENTRY);\n          }\n          if (value !== null && valueType !== 'boolean') {\n            throw new ErrorCoded(`Found an invalid @propagate value: ${value}`, ERROR_CODES.INVALID_PROPAGATE_VALUE);\n          }\n          break;\n        }\n\n        // Don't allow keywords to be overridden\n        if (Util.isValidKeyword(key) && Util.isValidKeyword(Util.getContextValueId(value))) {\n          throw new ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util\n              .getContextValueId(value)}'`,\n            ERROR_CODES.KEYWORD_REDEFINITION);\n        }\n\n        continue;\n      }\n\n      // Otherwise, consider the key a term\n      if (value !== null) {\n        switch (valueType) {\n        case 'string':\n          if (Util.getPrefix(value, context) === key) {\n            throw new ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n              .stringify(value)}'`, ERROR_CODES.CYCLIC_IRI_MAPPING);\n          }\n          if (Util.isValidIriWeak(key)) {\n            if (value === '@type') {\n              throw new ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`,\n                ERROR_CODES.INVALID_IRI_MAPPING);\n            } else if (Util.isValidIri(value) && value !== new JsonLdContextNormalized(context).expandTerm(key)) {\n              throw new ErrorCoded(\n                `IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`,\n                ERROR_CODES.INVALID_IRI_MAPPING);\n            }\n          }\n          break;\n        case 'object':\n          if (!Util.isCompactIri(key) && !('@id' in value)\n            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n            throw new ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`,\n              ERROR_CODES.INVALID_IRI_MAPPING);\n          }\n\n          for (const objectKey of Object.keys(value)) {\n            const objectValue = value[objectKey];\n            if (!objectValue) {\n              continue;\n            }\n\n            switch (objectKey) {\n            case '@id':\n              if (Util.isValidKeyword(objectValue)\n                && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph' && objectValue !== '@nest') {\n                throw new ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`,\n                  ERROR_CODES.INVALID_IRI_MAPPING);\n              }\n              if (Util.isValidIriWeak(key)) {\n                if (objectValue === '@type') {\n                  throw new ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`,\n                    ERROR_CODES.INVALID_IRI_MAPPING);\n                } else if (Util.isValidIri(objectValue)\n                  && objectValue !== new JsonLdContextNormalized(context).expandTerm(key)) {\n                  throw new ErrorCoded(\n                    `IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`,\n                    ERROR_CODES.INVALID_IRI_MAPPING);\n                }\n              }\n              if (typeof objectValue !== 'string') {\n                throw new ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`,\n                  ERROR_CODES.INVALID_IRI_MAPPING);\n              }\n\n              if (Util.getPrefix(objectValue, context) === key) {\n                throw new ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                  .stringify(value)}'`, ERROR_CODES.CYCLIC_IRI_MAPPING);\n              }\n\n              break;\n            case '@type':\n              if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                throw new ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${\n                    key}': '${objectValue}'`,\n                  ERROR_CODES.INVALID_TYPE_MAPPING);\n              }\n              if (typeof objectValue !== 'string') {\n                throw new ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`,\n                  ERROR_CODES.INVALID_TYPE_MAPPING);\n              }\n              if (objectValue !== '@id' && objectValue !== '@vocab'\n                && (processingMode === 1.0 || objectValue !== '@json')\n                && (processingMode === 1.0 || objectValue !== '@none')\n                && (objectValue[0] === '_' || !Util.isValidIri(objectValue))) {\n                throw new ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`,\n                  ERROR_CODES.INVALID_TYPE_MAPPING);\n              }\n              break;\n            case '@reverse':\n              if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                throw new ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ERROR_CODES.INVALID_REVERSE_PROPERTY);\n              }\n              if ('@nest' in value) {\n                throw new ErrorCoded(`@nest is not allowed in the reverse property '${key}'`,\n                  ERROR_CODES.INVALID_REVERSE_PROPERTY);\n              }\n              break;\n            case '@container':\n              if (processingMode === 1.0) {\n                if (Object.keys(objectValue).length > 1\n                  || Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                  throw new ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util.CONTAINERS_1_0.join(', ')}`, ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                }\n              }\n              for (const containerValue of Object.keys(objectValue)) {\n                if (containerValue === '@list' && value['@reverse']) {\n                  throw new ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${\n                    key}'`, ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                }\n                if (Util.CONTAINERS.indexOf(containerValue) < 0) {\n                  throw new ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util.CONTAINERS.join(', ')}`, ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                }\n              }\n              break;\n            case '@language':\n              ContextParser.validateLanguage(objectValue, true, ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n              break;\n            case '@direction':\n              ContextParser.validateDirection(objectValue, true);\n              break;\n            case '@prefix':\n              if (objectValue !== null && typeof objectValue !== 'boolean') {\n                throw new ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`,\n                  ERROR_CODES.INVALID_PREFIX_VALUE);\n              }\n              if (!('@id' in value) && !Util.isValidIri(key)) {\n                throw new ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`,\n                  ERROR_CODES.INVALID_TERM_DEFINITION);\n              }\n              break;\n            case '@index':\n              if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                throw new ErrorCoded(`Attempt to add illegal key to value object: '${\n                  key}': '${JSON.stringify(value)}'`, ERROR_CODES.INVALID_TERM_DEFINITION);\n              }\n              break;\n            case '@nest':\n              if (Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                throw new ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`,\n                  ERROR_CODES.INVALID_NEST_VALUE);\n              }\n            }\n          }\n          break;\n        default:\n          throw new ErrorCoded(`Found an invalid term value: '${key}': '${value}'`,\n            ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply the @base context entry to the given context under certain circumstances.\n   * @param context A context.\n   * @param options Parsing options.\n   * @param inheritFromParent If the @base value from the parent context can be inherited.\n   * @return The given context.\n   */\n  public applyBaseEntry(context: IJsonLdContextNormalizedRaw, options: IParseOptions,\n                        inheritFromParent: boolean): IJsonLdContextNormalizedRaw {\n    // In some special cases, this can be a string, so ignore those.\n    if (typeof context === 'string') {\n      return context;\n    }\n\n    // Give priority to @base in the parent context\n    if (inheritFromParent && !('@base' in context) && options.parentContext\n      && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n      context['@base'] = options.parentContext['@base'];\n      if (options.parentContext['@__baseDocument']) {\n        context['@__baseDocument'] = true;\n      }\n    }\n\n    // Override the base IRI if provided.\n    if (options.baseIRI && !options.external) {\n      if (!('@base' in context)) {\n        // The context base is the document base\n        context['@base'] = options.baseIRI;\n        context['@__baseDocument'] = true;\n      } else if (context['@base'] !== null && typeof context['@base'] === 'string'\n        && !Util.isValidIri(<string> context['@base'])) {\n        // The context base is relative to the document base\n        context['@base'] = resolve(<string> context['@base'],\n          options.parentContext && options.parentContext['@base'] || options.baseIRI);\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Resolve relative context IRIs, or return full IRIs as-is.\n   * @param {string} contextIri A context IRI.\n   * @param {string} baseIRI A base IRI.\n   * @return {string} The normalized context IRI.\n   */\n  public normalizeContextIri(contextIri: string, baseIRI?: string) {\n    if (!Util.isValidIri(contextIri)) {\n      try {\n        contextIri = resolve(contextIri, baseIRI);\n      } catch {\n        throw new Error(`Invalid context IRI: ${contextIri}`);\n      }\n    }\n\n    // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n    if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n      contextIri = 'https://schema.org/';\n    }\n\n    return contextIri;\n  }\n\n  /**\n   * Parse scoped contexts in the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} options Parsing options.\n   * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n   * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all\n   * keys in the context will be iterated over.\n   */\n  public async parseInnerContexts(context: IJsonLdContextNormalizedRaw, options: IParseOptions, keys?: string[]): Promise<IJsonLdContextNormalizedRaw> {\n    for (const key of (keys ?? Object.keys(context))) {\n      const value = context[key];\n      if (value && typeof value === 'object') {\n        if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n          // Simulate a processing based on the parent context to check if there are any (potential errors).\n          // Honestly, I find it a bit weird to do this here, as the context may be unused,\n          // and the final effective context may differ based on any other embedded/scoped contexts.\n          // But hey, it's part of the spec, so we have no choice...\n          // https://w3c.github.io/json-ld-api/#h-note-10\n          if (this.validateContext) {\n            try {\n              const parentContext = {...context, [key]: {...context[key]}};\n              delete parentContext[key]['@context'];\n              await this.parse(value['@context'],\n                { ...options, external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true });\n            } catch (e) {\n              throw new ErrorCoded(e.message, ERROR_CODES.INVALID_SCOPED_CONTEXT);\n            }\n          }\n          context[key] = {...value, '@context': (await this.parse(value['@context'],\n          { ...options, external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context }))\n          .getContextRaw()}\n        }\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Parse a JSON-LD context in any form.\n   * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n   * @param {IParseOptions} options Optional parsing options.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n   */\n  public async parse(context: JsonLdContext, options?: IParseOptions): Promise<JsonLdContextNormalized>\n  public async parse(context: JsonLdContext,\n                     options: IParseOptions = {},\n                     // These options are only for internal use on recursive calls and should not be used by\n                     // libraries consuming this function\n                     internalOptions: { skipValidation?: boolean } = {}): Promise<JsonLdContextNormalized> {\n    const {\n      baseIRI,\n      parentContext,\n      external,\n      processingMode = ContextParser.DEFAULT_PROCESSING_MODE,\n      normalizeLanguageTags,\n      ignoreProtection,\n      minimalProcessing,\n    } = options;\n    const remoteContexts = options.remoteContexts || {};\n\n    // Avoid remote context overflows\n    if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n      throw new ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts),\n        ERROR_CODES.CONTEXT_OVERFLOW);\n    }\n\n    if (context === null || context === undefined) {\n      // Don't allow context nullification and there are protected terms\n      if (!ignoreProtection && parentContext && Util.hasProtectedTerms(parentContext)) {\n        throw new ErrorCoded('Illegal context nullification when terms are protected',\n          ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n      }\n\n      // Context that are explicitly set to null are empty.\n      return new JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n    } else if (typeof context === 'string') {\n      const contextIri = this.normalizeContextIri(context, baseIRI);\n      const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n      if (overriddenLoad) {\n        return new JsonLdContextNormalized(overriddenLoad);\n      }\n      const parsedStringContext = await this.parse(await this.load(contextIri),\n        {\n          ...options,\n          baseIRI: contextIri,\n          external: true,\n          remoteContexts: { ...remoteContexts, [contextIri]: true },\n        });\n      this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n      return parsedStringContext;\n    } else if (Array.isArray(context)) {\n      // As a performance consideration, first load all external contexts in parallel.\n      const contextIris: string[] = [];\n      const contexts = await Promise.all(context.map((subContext, i) => {\n        if (typeof subContext === 'string') {\n          const contextIri = this.normalizeContextIri(subContext, baseIRI);\n          contextIris[i] = contextIri;\n          const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n          if (overriddenLoad) {\n            return overriddenLoad;\n          }\n          return this.load(contextIri);\n        } else {\n          return subContext;\n        }\n      }));\n\n      // Don't apply inheritance logic on minimal processing\n      if (minimalProcessing) {\n        return new JsonLdContextNormalized(contexts);\n      }\n\n      const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n          .then((accContext) => this.parse(contextEntry, {\n            ...options,\n            baseIRI: contextIris[i] || options.baseIRI,\n            external: !!contextIris[i] || options.external,\n            parentContext: accContext.getContextRaw(),\n            remoteContexts: contextIris[i] ? { ...remoteContexts, [contextIris[i]]: true } : remoteContexts,\n          },\n          // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers\n            {\n              skipValidation: i < contexts.length - 1,\n            })),\n        Promise.resolve(new JsonLdContextNormalized(parentContext || {})));\n\n      // Override the base IRI if provided.\n      this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n\n      return reducedContexts;\n    } else if (typeof context === 'object') {\n      if ('@context' in context) {\n        return await this.parse(context['@context'], options);\n      }\n\n      // Make a deep clone of the given context, to avoid modifying it.\n      context = <IJsonLdContextNormalizedRaw> {...context};\n\n      // According to the JSON-LD spec, @base must be ignored from external contexts.\n      if (external) {\n        delete context['@base'];\n      }\n\n      // Override the base IRI if provided.\n      this.applyBaseEntry(context, options, true);\n\n      // Hashify container entries\n      // Do this before protected term validation as that influences term format\n      this.containersToHash(context);\n\n      // Don't perform any other modifications if only minimal processing is needed.\n      if (minimalProcessing) {\n        return new JsonLdContextNormalized(context);\n      }\n\n      // In JSON-LD 1.1, load @import'ed context prior to processing.\n      let importContext = {};\n      if ('@import' in context) {\n        if (processingMode >= 1.1) {\n          // Only accept string values\n          if (typeof context['@import'] !== 'string') {\n            throw new ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'],\n              ERROR_CODES.INVALID_IMPORT_VALUE);\n          }\n\n          // Load context\n          importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n          delete context['@import'];\n        } else {\n          throw new ErrorCoded('Context importing is not supported in JSON-LD 1.0',\n            ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n      }\n\n      this.applyScopedProtected(importContext, { processingMode }, defaultExpandOptions);\n\n      const newContext: IJsonLdContextNormalizedRaw = Object.assign(importContext, context);\n\n      // Handle terms (before protection checks)\n      this.idifyReverseTerms(newContext);\n      this.normalize(newContext, { processingMode, normalizeLanguageTags });\n      this.applyScopedProtected(newContext, { processingMode }, defaultExpandOptions);\n\n      const keys = Object.keys(newContext);\n\n      const overlappingKeys: string[] = [];\n      if (typeof parentContext === 'object') {\n        // Merge different parts of the final context in order\n        for (const key in parentContext) {\n          if (key in newContext) {\n            overlappingKeys.push(key);\n          } else {\n            newContext[key] = parentContext[key];\n          }\n        }\n      }\n\n      // Parse inner contexts with minimal processing\n      await this.parseInnerContexts(newContext, options, keys);\n\n      const newContextWrapped = new JsonLdContextNormalized(newContext);\n\n      // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context, or a compact IRI.\n      if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n        && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')) {\n        if (parentContext && '@vocab' in parentContext && context['@vocab'].indexOf(':') < 0) {\n          newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n        } else if (Util.isCompactIri(context['@vocab']) || context['@vocab'] in newContext) {\n            // @vocab is a compact IRI or refers exactly to a prefix\n          newContext['@vocab'] = newContextWrapped.expandTerm(context['@vocab'], true);\n\n        }\n      }\n\n      this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase, keys);\n\n      // In JSON-LD 1.1, check if we are not redefining any protected keywords\n      if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n        this.validateKeywordRedefinitions(parentContext, newContext, defaultExpandOptions, overlappingKeys);\n      }\n\n      if (this.validateContext && !internalOptions.skipValidation) {\n        this.validate(newContext, { processingMode });\n      }\n      return newContextWrapped;\n    } else {\n      throw new ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`,\n        ERROR_CODES.INVALID_LOCAL_CONTEXT);\n    }\n  }\n\n  /**\n   * Fetch the given URL as a raw JSON-LD context.\n   * @param url An URL.\n   * @return A promise resolving to a raw JSON-LD context.\n   */\n  public async load(url: string): Promise<JsonLdContext> {\n    // First try to retrieve the context from cache\n    const cached = this.documentCache[url];\n    if (cached) {\n      return cached;\n    }\n\n    // If not in cache, load it\n    let document: IJsonLdContext;\n    try {\n      document = await this.documentLoader.load(url);\n    } catch (e) {\n      throw new ErrorCoded(`Failed to load remote context ${url}: ${e.message}`,\n        ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n    }\n\n    // Validate the context\n    if (!('@context' in document)) {\n      throw new ErrorCoded(`Missing @context in remote context at ${url}`,\n        ERROR_CODES.INVALID_REMOTE_CONTEXT);\n    }\n\n    return this.documentCache[url] = document['@context'];\n  }\n\n  /**\n   * Override the given context that may be loaded.\n   *\n   * This will check whether or not the url is recursively being loaded.\n   * @param url An URL.\n   * @param options Parsing options.\n   * @return An overridden context, or null.\n   *         Optionally an error can be thrown if a cyclic context is detected.\n   */\n  public getOverriddenLoad(url: string, options: IParseOptions): IJsonLdContextNormalizedRaw | null {\n    if (url in (options.remoteContexts || {})) {\n      if (options.ignoreRemoteScopedContexts) {\n        return <IJsonLdContextNormalizedRaw> <any> url;\n      } else {\n        throw new ErrorCoded('Detected a cyclic context inclusion of ' + url,\n          ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Load an @import'ed context.\n   * @param importContextIri The full URI of an @import value.\n   */\n  public async loadImportContext(importContextIri: string): Promise<IJsonLdContextNormalizedRaw> {\n    // Load the context - and do a deep clone since we are about to mutate it\n    let importContext = await this.load(importContextIri);\n\n    // Require the context to be a non-array object\n    if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n      throw new ErrorCoded('An imported context must be a single object: ' + importContextIri,\n        ERROR_CODES.INVALID_REMOTE_CONTEXT);\n    }\n\n    // Error if the context contains another @import\n    if ('@import' in importContext) {\n      throw new ErrorCoded('An imported context can not import another context: ' + importContextIri,\n        ERROR_CODES.INVALID_CONTEXT_ENTRY);\n    }\n    importContext = {...importContext};\n\n    // Containers have to be converted into hash values the same way as for the importing context\n    // Otherwise context validation will fail for container values\n    this.containersToHash(importContext);\n    return importContext;\n  }\n\n}\n\nexport interface IContextParserOptions {\n  /**\n   * An optional loader that should be used for fetching external JSON-LD contexts.\n   */\n  documentLoader?: IDocumentLoader;\n  /**\n   * By default, JSON-LD contexts will be validated.\n   * This can be disabled by setting this option to true.\n   * This will achieve slightly better performance for large contexts,\n   * and may be useful if contexts are known to be valid.\n   */\n  skipValidation?: boolean;\n  /**\n   * If @type inside the context may be expanded via @base is @vocab is set to null.\n   */\n  expandContentTypeToBase?: boolean;\n  /**\n   * The maximum number of remote contexts that can be fetched recursively.\n   *\n   * Defaults to 32.\n   */\n  remoteContextsDepthLimit?: number;\n  /**\n   * If http-based schema.org contexts should internally be redirected to https.\n   * WARNING: this option is a temporary workaround for https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465\n   * and will be removed once that issue is fixed.\n   * Defaults to true.\n   */\n  redirectSchemaOrgHttps?: boolean;\n}\n\nexport interface IParseOptions {\n  /**\n   * An optional fallback base IRI to set.\n   */\n  baseIRI?: string;\n  /**\n   * The parent context.\n   */\n  parentContext?: IJsonLdContextNormalizedRaw;\n  /**\n   * If the parsing context is an external context.\n   */\n  external?: boolean;\n  /**\n   * The default JSON-LD version that the context should be parsed with.\n   */\n  processingMode?: number;\n  /**\n   * If language tags should be normalized to lowercase.\n   * This is always true for JSON-LD 1.0,\n   * but false by default for all following versions.\n   */\n  normalizeLanguageTags?: boolean;\n  /**\n   * If checks for validating term protection should be skipped.\n   */\n  ignoreProtection?: boolean;\n  /**\n   * If the context should only be parsed and validated,\n   * without performing normalizations and other modifications.\n   *\n   * If true, this *will* dereference external contexts.\n   *\n   * This option is used internally when handling type-scoped and property-scoped contexts.\n   */\n  minimalProcessing?: boolean;\n  /**\n   * If true, a remote context that will be looked up,\n   * and is already contained in `remoteContexts`,\n   * will not emit an error but will produce an empty context.\n   */\n  ignoreRemoteScopedContexts?: boolean;\n  /**\n   * A hash containing all remote contexts that have been looked up before.\n   *\n   * This is used to avoid stack overflows on cyclic context references.\n   */\n  remoteContexts?: {[url: string]: boolean};\n  /**\n   * If further processing of scoped contexts should be skipped.\n   *\n   * This is done to avoid combinatorial explosions when handling a scoped context if there are many scoped contexts.\n   */\n  ignoreScopedContexts?: boolean;\n}\n"]}